<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type" />
  <title>asynDriver</title>
</head>
<body>
  <div style="text-align: center">
    <h1>
      asynDriver: Asynchronous Driver Support</h1>
    <p>
      <span style="font-weight: bold; font-size: 14pt">Release 4-31</span></p>
    <p>
      <span style="font-weight: bold; font-size: 14pt">Mark Rivers, Eric Norum, and Marty
        Kraimer</span></p>
    <p>
      <span style="font-weight: bold; font-size: 14pt">February 18, 2017</span></p>
    <h3>
      Other Contributers</h3>
    <p>
      <span style="font-weight: bold; font-size: 14pt">Gasper Jansa (cosyLab) - linuxGpib
        support.</span></p>
  </div>
  <hr />
  <div style="text-align: center">
    <h2>
      License Agreement</h2>
  </div>
  <p>
    This product is available via the <a href="#LicenseAgreement">open source license</a>
    described at the end of this document.</p>
  <hr />
  <div style="text-align: center">
    <h2>
      Contents</h2>
  </div>
  <div>
    <a href="#Purpose">Purpose</a>
    <br />
    <a href="#Status">Status</a>
    <br />
    <a href="#Acknowledgments">Acknowledgments</a>
    <br />
    <a href="#Overview">Overview of asynDriver</a>
    <br />
    <a href="#theoryOfOperation">Theory of Operation</a>
    <br />
    <a href="#asynDriver">asynDriver Structures and Interfaces</a>
    <br />
    <a href="#standardMessageInterfaces">Standard Message Based Interfaces</a><br />
    <a href="#standardRegisterInterfaces">Standard Register Based Interfaces</a><br />
    <a href="#asynStandardInterfacesBase">asynStandardInterfacesBase</a><br />
    <a href="#interposeInterfaces">Standard Interpose Interfaces</a>
    <br />
    <a href="#genericEpicsSupport">Generic Device Support for EPICS records</a><br />
    <a href="#asynRecord">asynRecord: Generic Record Support</a>
    <br />
    <a href="#Example">Example</a>
    <br />
    <a href="#Test">Test Example</a>
    <br />
    <a href="#asynGpib">asynGpib</a>
    <br />
    <a href="#PortDrivers">Port Drivers</a>
    <ul>
      <li><a href="#drvAsynSerialPort">Local Serial Port</a></li>
      <li><a href="#drvAsynIPPort">TCP/IP or UDP/IP Port</a></li>
      <li><a href="#drvAsynIPServerPort">TCP/IP or UDP/IP Server</a></li>
      <li><a href="#usbtmc">USB TMC (Test and Measurement Class)</a></li>
      <li><a href="#vxi11">VXI-11</a></li>
      <li><a href="#Linux-gpib">Linux-Gpib</a></li>
      <li><a href="#gsIP488">Green Springs IP488</a></li>
      <li><a href="#ni1014">National Instruments GPIB-1014D</a></li>
      <li><a href="#Additional_Drivers">Additonal Drivers</a></li>
    </ul>
    <a href="#asynPortDriver">asynPortDriver C++ base class</a>
    <br />
    <a href="#asynPortClient">asynPortClient C++ classes</a>
    <br />
    <a href="#DiagnosticAids">Diagnostic Aids</a>
    <br />
    <a href="#InstallBuild">Install and Build</a>
    <br />
  </div>
  <hr />
  <div style="text-align: center">
    <h2 id="Purpose">
      Purpose</h2>
  </div>
  <p>
    <b>asynDriver</b> is a general purpose facility for interfacing device specific
    code to low level drivers. asynDriver allows non-blocking device support that works
    with both blocking and non-blocking drivers.</p>
  <p>
    A primary target for asynDriver is EPICS IOC device support but, other than using
    libCom, much of it is independent of EPICS.</p>
  <p>
    asynDriver has the following key concepts:</p>
  <ul>
    <li>Device support communicates with drivers via interfaces
      <p>
        Drivers take care of the details of how to communicate with a device and implement
        interfaces for use by device support. Interfaces are defined for both message and
        register based devices. In the past when support was written for a new type of device,
        device support for standard EPICS records had to be written in addition to the driver
        support. Now a driver just implements one or more of the standard interfaces.</p>
    </li>
    <li>A port provides access to device instances
      <p>
        A port, which has a portName, identifies a communication path to one or more device
        instances. For example a GPIB port can have up to 15 devices connected to it. An
        RS232 port communicates with a single device. Drivers register a port. Device support
        connects to a port.</p>
    </li>
    <li>asynManager controls access to a port
      <p>
        asynManager, a component of asynDriver, provides exclusive access to a driver via
        calls to queueRequest, lockPort/unlockPort, and queueLockPort/queueUnlockPort. Once
        device support has access, it can make an arbitrary number of calls to the driver
        knowing that no other support can call the driver. Device and driver support do
        not need to implement queues or semaphores since asynManager does this for them.</p>
    </li>
    <li>asynTrace provides a general purpose diagnostic facility
      <p>
        Rules are defined for providing diagnostic messages. Provided device and driver
        support follow the rules, a user can obtain several levels of diagnostic information
        that can be displayed on the console, written to a file, or sent to the EPICS errlog
        facility.</p>
    </li>
    <li>asynRecord - Generic access to an device/port
      <p>
        asynRecord is an EPICS record and set of associated MEDM displays that provide access
        to:</p>
      <ul>
        <li>A port or a device connected to a port
          <p>
            The port or port,addr can be changed dynamically. Thus with one asynRecord in an
            IOC, it is possible to talk to any device that has an asyn compatible driver.</p>
        </li>
        <li>asynTrace - All asynTrace options can be controlled with the asynRecord.</li>
        <li>Connection Management
          <p>
            Display and change connection, enable, and autoConnect state</p>
        </li>
        <li>Standard interfaces
          <p>
            These can be used to communicate with devices. For example if a new instrument arrives
            that has a serial, GPIB, or ethernet port, then it is often possible to communicate
            with it just by attaching an asynRecord to it.</p>
        </li>
      </ul>
    </li>
    <li>Extensive Serial Support
      <p>
        asynDriver provides many facilities for communicating with RS232, RS485, GPIB, and
        ethernet.</p>
    </li>
  </ul>
  <hr />
  <div style="text-align: center">
    <h2 id="Status">
      Status</h2>
  </div>
  <p>
    This version provides</p>
  <ul>
    <li>asynManager: the software layer between device support and drivers.</li>
    <li>asynRecord: EPICS record support that provides a generic interface to asynManager,
      asynCommon, asynOctet, asynGpib, and other interfaces.</li>
    <li>asynPortDriver: a C++ base class that makes it easy to write asyn drivers, with
      much of the boilerplate asyn code handled in the base class methods.</li>
    <li>asynPortClient: C++ classes that makes it easy to write C++ asyn clients that
      communicate directly with asyn port drivers without running an EPICS IOC.</li>
    <li>standard interfaces: Standard message and register based interfaces are defined.
      Low Level Drivers implement standard interfaces. Device support communicates with
      low level drivers via standard interfaces.</li>
    <li>devEpics: Generic device support for EPICS records.</li>
    <li>devGpib: EPICS device support that replaces the device support layer of the Winans/Franksen
      gpibCore support.</li>
    <li>asynGpib: a replacement for the drvGpibCommon layer of the Franksen gpibCore support.</li>
    <li>drvAsynSerialPort: Support for devices connected to serial ports.</li>
    <li>drvAsynIPPort: Support for TCP/IP and UDP/IP socket communication, including serial
      devices accessed via Ethernet/Serial converter boxes.</li>
    <li>drvAsynIPServerPort: Support for asyn socket servers that are accessed from remote
      clients. TCP/IP sockets and UDP are supported.</li>
    <li>VXI-11: A replacement for the VXI-11 support of the Franksen gpibCore support.</li>
    <li>Linux-gpib: Support for the Linux GPIB Package library.</li>
    <li>gsIP488: A low level driver for the Greensprings IP488 Industry Pack module.</li>
    <li>ni1014: A low level driver for the National Instruments VME 1014D.</li>
    <li>Serial Bus Support: The asynLockPortNotify interface was added to make it easier
      to support serial bus drivers that use the standard serial support.</li>
  </ul>
  <p>
    The following are some of the existing EPICS general purpose device support systems
    that have been converted to use asynDriver.</p>
  <ul>
    <li>StreamDevice. This is the protocol file-based support for serial/GPIB/CAN from
      Dirk Zimoch.</li>
    <li>gpibCore. This is the operating-system-independent version of the Winans/Franksen
      GPIB support.</li>
    <li>synApps (The APS BCDA synchrotron applications). The mca, dxp, motor, Ip330, IpUnidig,
      DAC128V and quadEM applications in this package have all been converted to asyn.
      The serial and GPIB modules in this package are no longer needed, because the asyn
      record replaces them. The areaDetector module was written to use asyn, and was the
      original motivation for the development of asynPortDriver.</li>
  </ul>
  <hr />
  <div style="text-align: center">
    <h2 id="Acknowledgments">
      Acknowledgments</h2>
  </div>
  <p>
    The idea of creating asynDriver resulted from many years of experience with writing
    device support for serial and GPIB devices. The following individuals have been
    most influential.</p>
  <dl>
    <dt>John Winans</dt>
    <dd>
      John provided the original EPICS GPIB support. Databases using John's support can
      be used without modification with devGpib. With small modifications, device support
      modules written for John's support can be used.</dd>
    <dt>Benjamin Franksen</dt>
    <dd>
      John's support only worked on vxWorks. In addition, the driver support was implemented
      as a single source file. Benjamin defined an interface between drvCommon and low
      level controllers and split the code into drvGpib and the low level drivers. He
      also created the support for drvVxi11.</dd>
    <dt>Eric Norum</dt>
    <dd>
      Eric started with Benjamin's code and converted it to use the Operating System Independent
      features of EPICS 3.14.</dd>
    <dt>Marty Kraimer</dt>
    <dd>
      Marty started with Eric's version and made changes to support secondary addressing;
      and to replace ioctl with code to support general bus management, universal commands,
      and addressed commands.</dd>
    <dt>Pete Owens</dt>
    <dd>
      Pete, for the Diamond Light Source, did a survey of several types of device/driver
      support packages for serial devices. Diamond decided to use the StreamDevice support
      developed by Dirk Zimoch.</dd>
    <dt>Dirk Zimoch</dt>
    <dd>
      Dirk developed StreadDevice, which has a single device support model, but supports
      arbitrary low level message based drivers, i.e. GPIB, serial, etc.</dd>
    <dt>Jun-ichi Odagare</dt>
    <dd>
      Jun-ichi developed NetDev, a system that provides EPICS device support for network
      based devices. It has a single device support model, but provides a general framework
      for communicating with network based devices.</dd>
    <dt>Mark Rivers</dt>
    <dd>
      Mark became an active developer of asynDriver soon after he started converting SynApps
      to use asynDriver. He soon pushed to have asynDriver support synchronous drivers,
      support register based drivers, and support interrupts. With these additions asynDriver
      is a framework for interfacing to a large class of devices instead of just message
      based asynchronous devices.</dd>
    <dt>Yevgeny A. Gusev</dt>
    <dd>
      Yevgeny has found bugs and suggested improvements in the way asynManager handles
      queue timeouts and cancels. He provides an expert and welcome set of eyes to look
      at difficult code!!!</dd>
  </dl>
  <hr />
  <div style="text-align: center">
    <h2 id="Overview">
      Overview of asynDriver</h2>
  </div>
  <h3>
    Definitions</h3>
  <p>
    asynDriver is a software layer between device specific code and drivers that communicate
    with devices. It supports both blocking and non-blocking communication and can be
    used with both register and message based devices. asynDriver uses the following
    terminology:</p>
  <ul>
    <li>interface
      <p>
        All communication between software layers is done via interfaces. An interface definition
        is a C language structure consisting entirely of function pointers. An asynDriver
        interface is analogous to a C++ or Java pure virtual interface. Although the implementation
        is in C, the spirit is object oriented. Thus this document uses the term "method"
        rather than "function pointer".</p>
    </li>
    <li>port
      <p>
        A physical or logical entity which provides access to a device. A port provides
        access to one or more devices.</p>
    </li>
    <li>portDriver
      <p>
        Code that communicates with a port.</p>
    </li>
    <li>portThread
      <p>
        If a portDriver can block, a thread is created for each port, and all I/O to the
        portDriver is done via this thread.</p>
    </li>
    <li>device
      <p>
        A device (instrument) connected to a port. For example a GPIB interface can have
        up to 15 devices connected to it. Other ports, e.g. RS-232 serial ports, only support
        a single device. Whenever this document uses the word device without a qualifier,
        it means something that is connected to a port.</p>
    </li>
    <li>device support
      <p>
        Code that interacts with a device.</p>
    </li>
    <li>synchronous
      <p>
        Support that does not voluntarily give up control of the CPU.</p>
    </li>
    <li>asynchronous
      <p>
        Support that is not synchronous. Some examples of asynchronous operations are epicsThreadSleep,
        epicsEventWait, and stdio operations. Calls to epicsMutexTake are considered to
        be synchronous operations, i.e. they are permitted in synchronous support.</p>
    </li>
    <li>asynDriver
      <p>
        The name for the support described in this manual. It is also the name of the header
        file that describes the core interfaces.</p>
    </li>
    <li>asynManager
      <p>
        An interface and the code which implements the methods for interfaces asynManager
        and asynTrace.</p>
    </li>
    <li>asynchronous Driver
      <p>
        A driver that blocks while communicating with a device. Typical examples are serial,
        gpib, and network based drivers.</p>
    </li>
    <li>synchronous Driver
      <p>
        A driver that does not block while communicating with a device. Typical examples
        are VME register based devices.</p>
    </li>
    <li>Message Based Interfaces
      <p>
        Interfaces that use octet arrays for read/write operations.</p>
    </li>
    <li>Register Based Interfaces
      <p>
        Interfaces that use integers or floats for read/write operations.</p>
    </li>
    <li>interrupt
      <p>
        As implemented by asynManager, interrupt just means "I have a new value for port,
        address".</p>
    </li>
  </ul>
  <p>
    Synchronous/asynchronous and message/register are orthogonal concepts. For example
    a register based driver can be either synchronous or asynchronous. The terminology
    register vs message is adapted from VXI.</p>
  <p>
    Standard interfaces are defined so that device specific code can communicate with
    multiple port drivers. For example if device support does all its communication
    via reads and writes consisting of 8 bit bytes (octets), then it should work with
    all port drivers that support octet messages. If device support requires more complicated
    support, then the types of ports will be more limited. Standard interfaces are also
    defined for drivers that accept 32 bit integers or 64 bit floats. Additional interfaces
    can be defined, and it is expected that additional standard interfaces will be defined.</p>
  <p>
    One or more devices can be attached to a port. For example, only one device can
    be attached to an RS-232 port, but up to 15 devices can be attached to a GPIB port.</p>
  <p>
    Multiple layers can exist between device specific code and a port driver. A software
    layer calls interposeInterface in order to be placed between device specific code
    and drivers. For more complicated protocols, additional layers can be created. For
    example, GPIB support is implemented as an asynGpib interface which is called by
    user code, and an asynGpibPort interface which is called by asynGpib.</p>
  <p>
    A driver normally implements multiple interfaces. For example asynGpib implements
    asynCommon, asynOctet, and asynGpib.</p>
  <p>
    asynManager uses the Operating System Independent features of EPICS base. It is,
    however, independent of record/device support. Thus, it can be used by other code,
    e.g. a sequence program.</p>
  <h3>
    Standard Interfaces</h3>
  <p>
    These are interfaces provided by asynManager or interfaces implemented by all or
    most port drivers.</p>
  <p>
    The interfaces are:</p>
  <p>
    <span style="font-weight: bold">asynManager</span> provides services for communicating
    with a device connected to a port.</p>
  <p>
    <span style="font-weight: bold">asynCommon</span> is an interface that must be implemented
    by all low level drivers. The methods are:</p>
  <ul>
    <li>report - Report status of port.</li>
    <li>connect - Connect to the port or device.</li>
    <li>disconnect - Disconnect from the port or device.</li>
  </ul>
  <p>
    <span style="font-weight: bold">asynTrace</span> is an interface for generating
    diagnostic messages.</p>
  <p>
    <span style="font-weight: bold">asynLockPortNotify</span> is an interface that is
    implemented by a driver which is an asynUser of another driver. An example is a
    serial bus driver that uses standard serial support. asynManager calls asynLockPortNotify
    whenever it locks or unlocks the port.</p>
  <p>
    <span style="font-weight: bold">asynDrvUser</span> is an interface for communicating
    information from device support to a driver without the device support knowing any
    details about what is passed.</p>
  <h3>
    Generic Interfaces</h3>
  <p>
    In addition to <span style="font-weight: bold">asynCommon</span> and optionally
    <span style="font-weight: bold">asynDrvUser</span>, port drivers can implement one
    or more of the following message and/or register based interfaces.</p>
  <p>
    <span style="font-weight: bold">asynOctet</span> methods for message based devices</p>
  <p>
    <span style="font-weight: bold">asynFloat64</span> methods for devices that read/write
    IEEE float values</p>
  <p>
    <span style="font-weight: bold">asynFloat32Array</span> methods for devices that
    read/write arrays of IEEE 32-bit float values</p>
  <p>
    <span style="font-weight: bold">asynFloat64Array</span> methods for devices that
    read/write arrays of IEEE 64-bit float values</p>
  <p>
    <span style="font-weight: bold">asynInt32</span> methods for devices that read/write
    integer values. Many analog I/O drivers can use this interface.</p>
  <p>
    <span style="font-weight: bold">asynInt8Array</span> methods for devices that read/write
    arrays of 8-bit integer values</p>
  <p>
    <span style="font-weight: bold">asynInt16Array</span> methods for devices that read/write
    arrays of 16-bit integer values</p>
  <p>
    <span style="font-weight: bold">asynInt32Array</span> methods for devices that read/write
    arrays of 32-bit integer values</p>
  <p>
    <span style="font-weight: bold">asynUInt32Digital</span> methods for devices that
    read/write arrays of digital values. This interface provides a mask to address individual
    bits within registers.</p>
  <p>
    <span style="font-weight: bold">asynGenericPointer</span> methods for devices that
    read/write arbitrary structures, passed via a void* pointer. The client and the
    server of course need to agree on the structure type being pointed to.</p>
  <p>
    <span style="font-weight: bold">asynEnum</span> methods for devices to define enum
    strings, values, and severities.</p>
  <p>
    <span style="font-weight: bold">asynOption</span> methods for device configuration
    using key/value pairs.</p>
  <h3>
    asynManager</h3>
  <p>
    asynManager is an interface and associated code. It is the "heart" of asynDriver
    since it manages the interactions between device support code and drivers. It provides
    the following services:</p>
  <ul>
    <li>reporting
      <p>
        Method: report</p>
    </li>
    <li>asynUser creation
      <p>
        Methods: createAsynUser, duplicateAsynUser, freeAsynUser</p>
      <p>
        An asynUser is a "handle" for accessing asynManager services and for calling interfaces
        implemented by drivers. An asynUser must only be created via a call to createAsynUser
        or duplicateAsynUser since asynManager keeps private information for each asynUser.
        freeAsynUser puts the asynUser on a free list rather than calling free. Clients
        can continually create and free asynUsers quickly and without fragmenting memory.</p>
      <p>
        The call to createAsynUser specifies a processCallback and a timeoutCallback. These
        are the callbacks that will be called as a result of a queueRequest.</p>
      <p>
        An asynUser should not be shared between parts of code that can simultaneously access
        a driver. For example device support for standard EPICS records should create an
        asynUser for each record instance.</p>
    </li>
    <li>Basic asynUser services
      <p>
        Methods: connectDevice, disconnect, findInterface</p>
      <p>
        These methods should only be called by the code that created the asynUser.</p>
      <p>
        After an asynUser is created the user calls connectDevice. The user is connected
        to a port driver that can communicate with a device. findInterface is called for
        each interface the user requires. disconnect is called when the user is done with
        the device.</p>
    </li>
    <li>Queuing services
      <p>
        Methods: queueRequest, cancelRequest, lockPort, unlockPort, queueLockPort, queueUnlockPort,
        blockProcessCallback, unblockProcessCallback</p>
      <p>
        queueRequest is a request to call the processCallback specified in the call to createAsynUser.
        Most interface methods must only be called from processCallback via a call to queueRequest
        or between calls to lockPort/unlockPort.. Exceptions to this rule must be clearly
        documented (a common exception are methods registerInterruptUser/cancelInterruptUser).</p>
      <p>
        queueRequest semantics differ for ports that can block and ports that do not block</p>
      <p>
        When registerPort is called by a driver that can block, a thread is created for
        the port. A set of queues, based on priority, is created for the thread. queueRequest
        puts the request on one of the queues. The port thread takes the requests from the
        queues and calls the associated callback. Only one callback is active at a time.</p>
      <p>
        When registerPort is called by a driver that does not block, a mutex is created
        for the port. queueRequest takes the mutex, calls the callback, and releases the
        mutex. The mutex guarantees that two callbacks to a port are not active at the same
        time.</p>
      <p>
        lockPort is a request to lock all access to low level drivers until unlockPort is
        called. If the port blocks then lockPort and all calls to the port driver may block.
        lockPort/unlockPort are provided for use by code that is willing to block or for
        communication with synchronous ports. A call to lockPort locks all addresses associated
        with a multi-address port. Prior to asyn R4-14 pasynManager-&gt;lockPort() immediately
        took the port mutex when it was available, rather than queueing a request to take
        the mutex. From asyn R4-14 to R4-20 lockPort queues a request to access the port
        and then blocks until the queue request callback runs in the portThread. When the
        queue request runs, the thread that called pasynManager-&gt;lockPort() executes,
        and the portThread blocks, until pasynManager-&gt;unlockPort() is called. In R4-21
        the queued lockPort and unlockPort functions were renamed to queueLockPort and queueUnlockPort,
        and the original lightweight lockPort and unlockPort functions were restored.</p>
      <p>
        blockProcessCallback is a request to prevent acccess to a device or port by other
        asynUsers between queueRequests. blockProcessCallback can be called from a processCallback
        or when the asynUser has no request queued. When called from processCallback blocking
        starts immediately, otherwise blocking starts the next time processCallback is called.
        Blocking means that no other asynUser's processCallback will be called until unblockProcessCallback
        is called. blockProcessCallback only works with drivers that can block and an error
        is returned if it is called for non-blocking drivers.</p>
    </li>
    <li>Basic Driver services
      <p>
        Methods: registerPort,registerInterface</p>
      <p>
        registerPort is called by a portDriver. registerInterface is called by a portDriver
        or an interposeInterface.</p>
      <p>
        Each port driver provides a configuration command that is executed for each port
        instance. The configuration command performs port specific initializations, calls
        registerPort, and registerInterface for each interface it implements.</p>
    </li>
    <li>Attribute Retrieval
      <p>
        Methods: isMultiDevice, canBlock, getAddr, getPortName, isConnected, isEnabled,
        isAutoConnect</p>
      <p>
        These methods can be called by any code that has access to the asynUser</p>
    </li>
    <li>Connection services
      <p>
        Methods: enable,autoConnect,setAutoConnectTimeout</p>
      <p>
        These methods can be called by any code that has access to the asynUser.</p>
      <p>
        These methods can be called to set the enable and autoConnect settings for a port
        and/or device. If autoConnect is true then asynManager does the following:</p>
      <ul>
        <li>When the port registers its asynCommon interface, asynManager queues a connection
          request. It then waits for a short time for the connection callback to complete.
          The default time is 0.5 seconds, but this time can be changed with a call to the
          function pasynManager-&gt;setAutoConnectTimeout(double timeout). This function can
          be accessed from the iocsh shell with the asynSetAutoConnectTimeout(double timeout)
          command. This short timeout is designed to allow devices time to connect if they
          are available, but not to excessively slow down booting of the IOC by waiting, for
          example, for the system timeout on TCP connections. Note that this means that it
          is very likely that the pasynCommon-&gt;connect() call will occur as soon as the
          asynCommon interface is registered, which means that the driver must have already
          done all initialization required for the asynCommon-&gt;connect() callback before
          it registers the asynCommon interface. If the port does not connect initially, or
          if it subsequently disconnects, then asynManager will queue a connection request
          every 20 seconds. If autoConnect is true and port/device is enabled but the device
          is not connected, then queueManager calls calling asynCommon:connect just before
          it calls processCallback.</li>
      </ul>
    </li>
    <li>Exception services
      <p>
        Methods: exceptionCallbackAdd, exceptionCallbackRemove, exceptionConnect, exceptionDisconnect</p>
      <p>
        Device support code calls exceptionCallbackAdd and exceptionCallbackRemove. The
        complete list of exceptions is defined in asynDriver.h as "enum asynException".</p>
      <p>
        Whenever a port driver connects or disconnects, normally as a result of a call to
        asynCommon:connect or asynCommon:disconnect, it must also call exceptionConnect
        or exceptionDisconnect.</p>
    </li>
    <li>Interrupt services
      <p>
        Methods: registerInterruptSource, getInterruptPvt, createInterruptNode, freeInterruptNode,
        addInterruptUser, removeInterruptUser, interruptStart, interruptEnd</p>
      <p>
        Interrupt just means: "I have a new value." Many asyn interfaces, e.g. asynInt32,
        provide interrupt support. These interfaces provide methods addInterruptUser and
        removeInterruptUser. Device support calls addInterruptUser if it wants to be called
        whenever an interrupt occurs. Drivers or other code that implements the interface
        calls the registered users when it has new data. asynManager provides services that
        help drivers implement thread-safe support for interrupts.</p>
      <p>
        A driver that supports interrupts calls registerInterruptSource for each interface
        that has associated interrupts. It calls interruptStart to obtain a list of all
        registered users and interruptEnd after it calls the registered users. The driver
        is also responsible for calling addInterruptUser and removeInterruptUser.</p>
      <p>
        If any calls are made to addInterruptUser or removeInterruptUser between the calls
        to interruptStart and interruptEnd, asynManager puts the request on a list and processes
        the request after interruptEnd is called.</p>
      <p>
        Many standard interfaces, e.g. asynInt32, provide methods registerInterruptUser,
        cancelInterruptUser. These interfaces also provide an auxilliary interface, e.g.
        asynInt32Base, and code which implements registerInterruptUser and cancelInterruptUser.</p>
      <p>
        On operating systems like vxWorks or RTEMS interruptStart,interruptEnd MUST NOT
        be called from interupt level.</p>
    </li>
    <li>Timestamp services
      <p>
        Methods: updateTimeStamp, getTimeStamp, setTimeStamp, registerTimeStampSource, unregisterTimeStampSource.</p>
      <p>
        These methods provide support for setting a timestamp for a port. This timestamp
        is typically used to set the pasynUser-&gt;timestamp field that is passed to device
        support on read or callback operations. Device support uses the pasynUser-&gt;timestamp
        field to set the record TIME field. This will then be the record timestamp if the
        record TSE field is -2. asynManager provides a default timestamp source function
        which just calls epicsTimeGetCurrent(). However, registerTimeStampSource can be
        used to supply a different user-provided timestamp source function, for example
        one that calls epicsTimeGetEvent(), or some other site-specific timestamp source.
        unregisterTimeStampSource reverts to the default timestamp source in pasynManager.</p>
    </li>
    <li>General purpose freelist service
      <p>
        Methods: memMalloc, memFree</p>
      <p>
        These methods do not require an asynUser. They are provided for code that must continually
        allocate and free memory. Since memFree puts the memory on a free list instead of
        calling free, they are more efficient that calloc/free and also help prevent memory
        fragmentation.</p>
    </li>
    <li>Interpose service
      <p>
        Method: interposeInterface</p>
      <p>
        Code that calls interposeInterface implements an interface which is either not supported
        by a port driver or that is "interposed" between the caller and the port driver.
        For example asynInterposeEos interposes asynOctet. It performs end of string processing
        for port drivers that do not support it.</p>
      <p>
        interposeInterface is recursive, i.e. an arbitrary number of interpose layers can
        exist above a single port,addr.</p>
    </li>
  </ul>
  <h3>
    Multiple Device vs Single Device Port Drivers</h3>
  <p>
    When a low level driver calls registerPort, it declares if it handles multiple devices.
    This determines how the addr argument to connectDevice is handled and what getAddr
    returns.</p>
  <ul>
    <li>multiDevice false
      <p>
        The addr argument to connectDevice is ignored and getAddr always returns -1</p>
    </li>
    <li>multiDevice true
      <p>
        If connectDevice is called with addr&lt;0, the connection is to the port and getAddr
        always returns -1. If addr&gt;=0, then the caller is connected to the device at
        the specified address. getAddr will return this address. An asynUser connected to
        the port can issue requests that affect all address on the port. For example disabling
        access to the port prevents access to all addresses on the port.</p>
    </li>
  </ul>
  <h3>
    Connection Management</h3>
  <p>
    asynManager keeps track of the following states:</p>
  <ul>
    <li>connection
      <p>
        Is the port or device connected? This state is initialized to disconnected.</p>
    </li>
    <li>enabled
      <p>
        Is the port or device enabled? This state is initialized to enabled.</p>
    </li>
    <li>autoConnect
      <p>
        Does asynManager automatically attempt to connect if it finds the port or device
        disconnected? This is initialized to the state specified in the call to registerPort.</p>
    </li>
  </ul>
  <p>
    If the port does not support multiple devices, then port and device status are the
    same. If the port does support multiple devices, then asynManager keeps track of
    the states for the port and for every device connected to the port.</p>
  <p>
    Whenever any of the states change for a port or device, then all users that previously
    called exceptionCallbackAdd for that port or device are called.</p>
  <p>
    Low level drivers must call pasynManager:exceptionConnect whenever they connect
    to a port or port,addr and exceptionDisconnect whenever they disconnect.</p>
  <h3>
    Protecting a Thread from Blocking</h3>
  <p>
    The methods asynManager:report and asynCommon:report can be called by any thread,
    but the caller is blocked until the report finishes. lockPort, unlockPort, queueLockPort,
    queueUnlockPort, and most port methods may block. The other asynManager methods
    can be called by any thread including portThread. None of these methods block.</p>
  <p>
    Unless stated otherwise the methods for other interfaces must only be called by
    processCallback or by calls between lockPort/unlockPort, or queueLockPort/queueUnlockPort.</p>
  <p>
    Interface methods registerInterruptUser and cancelInterruptUser must never block.
    The registerInterruptUser callback must not block because it could be called by
    a non blocking driver.</p>
  <h3>
    portThread</h3>
  <p>
    If a driver calls asynManager:registerPort with the ASYN_CANBLOCK attributes bit
    set, then asynManager creates a thread for the port. Each portThread has its own
    set of queues for the calls to queueRequest. Four queues are maintained. One queue
    is used only for asynCommon:connect and asynCommon:disconnect requests. The other
    queues provide different priorities: low, medium, and high. queueRequests to any
    queue other then the connection queue will be rejected if the port is not connected.
    portThread runs forever implementing the following algorithm:</p>
  <ol>
    <li>Wait for work by calling epicsEventMustWait. Other code such as queueRequest call
      epicsEventSignal.</li>
    <li>If the port is disabled, go back to 1.</li>
    <li>For every element in queue, asynQueuePriorityConnect:
      <ul>
        <li>Removes the element from the queue.</li>
        <li>Calls the user's callback</li>
      </ul>
    </li>
    <li>For each element of the queues asynQueuePriorityHigh, ...,asynQueuePriorityLow.
      <ul>
        <li>If disabled, skip this element.</li>
        <li>If not connected and autoConnect is true for the device, then attempt to connect
          to the device.</li>
        <li>If not connected, skip this element.</li>
        <li>If blocked by another thread, skip this element.</li>
        <li>If not blocked and user has requested blocking, then blocked.</li>
        <li>Remove from queue and:
          <ul>
            <li>lock port</li>
            <li>call user callback</li>
            <li>unlock port</li>
          </ul>
        </li>
      </ul>
    </li>
  </ol>
  <p>
    The actual code is more complicated because it unlocks before it calls code outside
    asynManager. This means that the queues can be modified and exceptions may occur.</p>
  <hr />
  <div style="text-align: center">
    <h2 id="theoryOfOperation">
      Theory of Operation</h2>
  </div>
  <h3>
    Initialization</h3>
  <p>
    During initialization, port drivers register each communication port as well as
    all supported interfaces.</p>
  <p>
    User code creates an asynUser, which is a "handle" for accessing asynDriver facilities,
    by calling</p>
  <pre>    pasynManager-&gt;createAsynUser(processCallback,timeoutCallback);</pre>
  <p>
    An asynUser has the following features:</p>
  <ul>
    <li>An asynUser is the means by which asynManager manages multiple requests for accessing
      a port.</li>
    <li>processCallback,which is used by queueRequest described below, is the addresss
      of a user supplied callback routine.</li>
    <li>timeoutCallback is the address of caller supplied callback that will be called
      if a queueRequest remains on the queue too long.</li>
    <li>Device support code should create an asynUser for each "atomic" access to low
      level drivers, i.e. a set of calls that must not be interlaced with other calls
      to the low level drivers. For example device support for EPICS record support should
      create an asynUser for each record instance.</li>
    <li>Device support code should NOT try to share an asynUser between multiple sources
      of requests for access to a port. If this is done then device support must itself
      handle contention issues that are already handled by asynManager.</li>
  </ul>
  <p>
    User code connects to a low level driver via a call to</p>
  <pre>    status = pasynManager-&gt;connectDevice(pasynUser,portName,addr);</pre>
  <p>
    This call must specify the name of the port and the address of the device. It then
    calls findInterface to locate the interfaces with which it calls the driver. For
    example:</p>
  <pre>     pasynInterface = pasynManager-&gt;findInterface(pasynUser,asynOctetType,1);</pre>
  <h3>
    Requesting access to a port</h3>
  <p>
    User code can request access to a port by two methods:</p>
  <ul>
    <li>queueRequest -
      <p>
        The processCallback passed to createAsynUser makes calls to the port interfaces.</p>
    </li>
    <li>lockPort/unlockPort, queueLockPort/queueUnlockPort -
      <p>
        The caller can make calls to the port interfaces while the lock is held. These calls
        and calls to the port may block and thus should NOT be used by code that should
        not block, e.g. synchronous device support for EPICS records.</p>
    </li>
  </ul>
  <h3>
    queueRequest - Flow of Control</h3>
  <p>
    User code requests access to a port by calling:</p>
  <pre>    status = pasynManager-&gt;queueRequest(pasynUser,priority,timeout);</pre>
  <p>
    This results in either processCallback or timeoutCallback being called. Most requests
    to a port must be made from processCallback. queueRequest does not block. If queueRequest
    is called for a port that can block the request is queued to a thread dedicated
    to the port. If queueRequest is called for a port does not block it just calls processCallback.
    guarantee is valid only if low level drivers are only accessed by calling queueRequest,
    lockPort/unlockPort, and/or queueLockPort/queueUnlockPort</p>
  <p>
    The following examples are based on EPICS IOC record/device support.</p>
  <p>
    The first example shows access to a port that can block.</p>
  <p>
  </p>
  <div style="text-align: center">
    <img alt="AsynFlow.jpg" src="AsynFlow.jpg" />
    <p>
    </p>
    <p>
      Figure 1: Asynchronous Control Flow</p>
  </div>
  <p>
    The sequence of record device support events that occurs starting with an application
    thread is pictured above in Figure 1, and explained below in the following steps:</p>
  <ol>
    <li>Record processing calls device support with PACT 0 (Processing is not active).</li>
    <li>Device support calls queueRequest.</li>
    <li>queueRequest places the request on the driver work queue. The application thread
      is now able to go on and perform other operations. Subsequent operations for this
      I/O request are handled in the port driver thread.</li>
    <li>The portThread removes the I/O request from the work queue.</li>
    <li>The portThread calls the processCallback located in Record device support.</li>
    <li>processCallback calls the low-level driver. The low-level driver read or write
      routine blocks until the I/O completes or until a timeout occurs. The low-level
      driver routine returns the results of the I/O operation to processCallback.</li>
    <li>processCallback requests that the record be processed. NOTE: The process request
      will be made by one of the standard callback requests rather than the port thread.</li>
    <li>Record support calls device support again, this time with PACT 1(processing is
      active). Device support updates fields in the record and returns to record support
      which completes record processing.</li>
  </ol>
  <p>
    The second example shows access to a port that cannot block.</p>
  <p>
  </p>
  <div style="text-align: center">
    <img alt="AsynSynFlow.jpg" src="AsynSynFlow.jpg" />
    <p>
      Figure 2: Synchronous Control Flow</p>
  </div>
  <p>
    The sequence of record device support events that occurs starting with an application
    thread is pictured above in Figure 2, and explained below in the following steps:</p>
  <ol>
    <li>Record processing calls device support.</li>
    <li>Device support calls queueRequest.</li>
    <li>Since the port is synchronous, i.e. can not block, queueRequest locks the port
      and then calls the processCallback.</li>
    <li>processCallback calls the low-level driver read or write routine. The low-level
      driver routine returns the results of the I/O operation to processCallback.</li>
    <li>processCallback returns to queueRequest, which unlocks the port and returns to
      device support, which returns to record support, which completes record processing.</li>
  </ol>
  <hr />
  <div style="text-align: center">
    <h2 id="asynDriver">
      asynDriver Structures and Interfaces</h2>
  </div>
  <p>
    asynDriver.h describes the following:</p>
  <ul>
    <li>asynStatus - An enum that describes the status returned by many methods.</li>
    <li>asynException - An enum that describes exceptions.</li>
    <li>asynQueuePriority - An enum that describes the queue priorities.</li>
    <li>asynUser - A struture that contains generic information and is the "handle" for
      calling most methods.</li>
    <li>asynInterface - a structure that describes an interface.</li>
    <li>userCallback - a typedef for the user process callback function described above.</li>
    <li>exceptionCallback - a typedef for a user callback to be called when exceptions
      occur.</li>
    <li>timeStampCallback - a typedef for a user callback function that will be called
      by updateTimeStamp.</li>
    <li>asynManager - An interface for communicating with asynDriver.</li>
    <li>asynCommon - An interface providing methods that must be implemented by all low
      level drivers.</li>
    <li>asynTrace - An interface plus associated functions and definitions that implement
      the trace facility.</li>
  </ul>
  <h3>
    asynStatus</h3>
  <p>
    Defines the status returned by most methods. If a method returns a status other
    than asynSuccess, and one of the arguments to the method is pasynUser, then the
    method is expected to write a message into pasynUser-&gt;errorMessage.</p>
  <pre>typedef enum {
    asynSuccess,asynTimeout,asynOverflow,asynError,asynDisconnected,asynDisabled
}asynStatus;</pre>
  <table border="1">
    <caption>
      asynStatus</caption>
    <tbody>
      <tr>
        <td>
          asynSuccess</td>
        <td>
          The request was successful.</td>
      </tr>
      <tr>
        <td>
          asynTimeout</td>
        <td>
          The request failed with a timeout.</td>
      </tr>
      <tr>
        <td>
          asynOverflow</td>
        <td>
          The driver has lost input data. This can happen if an internal buffer or the user
          supplied buffer is too small. Whenever possible, low level drivers should be written
          so that the user can read input in small pieces.</td>
      </tr>
      <tr>
        <td>
          asynError</td>
        <td>
          Some other error occured.</td>
      </tr>
      <tr>
        <td>
          asynDisconnected</td>
        <td>
          The request failed because the port is not connected.</td>
      </tr>
      <tr>
        <td>
          asynDisabled</td>
        <td>
          The request failed because the port or device is disabled.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynException</h3>
  <p>
    Defines the exceptions for method exceptionOccurred</p>
  <pre>typedef enum {
    asynExceptionConnect,asynExceptionEnable,asynExceptionAutoConnect,
    asynExceptionTraceMask,asynExceptionTraceIOMask,asynExceptionTraceInfoMask,
    asynExceptionTraceFile,asynExceptionTraceIOTruncateSize
} asynException;</pre>
  <table border="1">
    <caption>
      asynException</caption>
    <tbody>
      <tr>
        <td>
          asynExceptionConnect</td>
        <td>
          The connection state of the port or device has changed.</td>
      </tr>
      <tr>
        <td>
          asynExceptionEnable</td>
        <td>
          The enable state of the port or device has changed.</td>
      </tr>
      <tr>
        <td>
          asynExceptionAutoConnect</td>
        <td>
          The autoConnect state of the port or device has changed.</td>
      </tr>
      <tr>
        <td>
          asynExceptionTraceMask</td>
        <td>
          The traceMask for the port or device has changed.</td>
      </tr>
      <tr>
        <td>
          asynExceptionTraceIOMask</td>
        <td>
          The traceIOMask for the port or device has changed.</td>
      </tr>
      <tr>
        <td>
          asynExceptionTraceInfoMask</td>
        <td>
          The traceInfoMask for the port or device has changed.</td>
      </tr>
      <tr>
        <td>
          asynExceptionTraceFile</td>
        <td>
          The trace file for the port or device has changed.</td>
      </tr>
      <tr>
        <td>
          asynExceptionTraceIOTruncateSize</td>
        <td>
          The traceIOTruncateSize for the port or device has changed.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynQueuePriority</h3>
  <p>
    This defines the priority passed to queueRequest.</p>
  <pre>typedef enum {
    asynQueuePriorityLow,asynQueuePriorityMedium,asynQueuePriorityHigh,
    asynQueuePriorityConnect
}asynQueuePriority;</pre>
  <table border="1">
    <caption>
      asynQueuePriority</caption>
    <tbody>
      <tr>
        <td>
          asynQueuePriorityLow</td>
        <td>
          Lowest queue priority.</td>
      </tr>
      <tr>
        <td>
          asynQueuePriorityMedium</td>
        <td>
          Medium queue priority.</td>
      </tr>
      <tr>
        <td>
          asynQueuePriorityHigh</td>
        <td>
          High queue priority.</td>
      </tr>
      <tr>
        <td>
          asynQueuePriorityConnect</td>
        <td>
          Queue a connect or disconnect request. This priority must be used for and only for
          connect/disconnect requests.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynUser</h3>
  <p>
    Describes a structure that user code passes to most asynManager and driver methods.
    Code must allocate and free an asynUser by calling asynManager:createAsynUser (or
    asynManager:duplicateAsynUser) and asynManager:freeAsynUser.</p>
  <pre>typedef struct asynUser {
    char          *errorMessage;
    int            errorMessageSize;
    /* timeout must be set by the user */
    double         timeout;  /* Timeout for I/O operations*/
    void          *userPvt; 
    void          *userData; 
    /* The following is for use by driver */
    void          *drvUser;
    /* The following is normally set by driver via asynDrvUser->create() */
    int            reason;
    epicsTimeStamp timestamp;
    /* The following are for additional information from method calls */
    int            auxStatus;     /* For auxillary status*/
    int            alarmStatus;   /* Typically for EPICS record alarm status */
    int            alarmSeverity; /* Typically for EPICS record alarm severity */
}asynUser;</pre>
  <table border="1">
    <caption>
      asynUser</caption>
    <tbody>
      <tr>
        <td>
          errorMessage</td>
        <td>
          When a method returns asynError it should put an error message into errorMessage
          via a call to:
          <pre>epicsSnprintf(pasynUser-&gt;errorMessage,pasynUser-&gt;errorMessageSize,</pre>
          <pre>              "&lt;format&gt;",...)</pre>
          The error message should <em>not</em> end with (nor contain) a newline character
          sequence (e.g. <tt>\n</tt>). It is up to user code to decide whether and how to
          display the error message. Keeping newlines out of the error message make it easy
          for user code to embed the error message in another message or output format.
        </td>
      </tr>
      <tr>
        <td>
          errorMessageSize</td>
        <td>
          The size of errorMessage. The user can not change this value.</td>
      </tr>
      <tr>
        <td>
          timeout</td>
        <td>
          The number of seconds before timeout for I/O requests. This is set by the user and
          can be changed between calls to a driver. If a call to a low level driver results
          in the driver making many I/O requests this is the time for each I/O request.
          <p>
            The meaning is as follows:</p>
          <p>
            &gt; 0.0 Wait for up to timeout seconds for the I/O to complete</p>
          <p>
            = 0.0 Peform any I/O that can be done without blocking. Return timeout error if
            no I/O can be done without blocking.</p>
          <p>
            &lt; 0.0 Infinite timeout. Wait forever for I/O to complete.</p>
        </td>
      </tr>
      <tr>
        <td>
          userPvt</td>
        <td>
          For use by the user. The user should set this immediately after the call to pasynManager-&gt;createAsynUser.
          <p>
            If this is changed while asynUser is queued, the results are undefined, e.g. it
            could cause a crash.</p>
        </td>
      </tr>
      <tr>
        <td>
          userData</td>
        <td>
          Also for use by the user.</td>
      </tr>
      <tr>
        <td>
          drvUser</td>
        <td>
          A driver can use this to hold asynUser specific data. The asynDrvUser interface
          is used for communication between asynUser and the driver.</td>
      </tr>
      <tr>
        <td>
          reason</td>
        <td>
          Drivers and asynUsers can use this as a general purpose field. By convention it
          is used to determine what "command" is being sent over a particular interface. For
          example an A/D driver implementing the asynInt32 interface might define reason=0
          to mean "return the A/D conversion", while reason=1 might mean "return the amplifier
          gain". Typically drivers implement the asynDrvUser interface, and use this to convert
          from descriptive strings for commands (e.g. "DATA" or "GAIN" in this example) to
          the enum "reason". A driver that is calling an interrupt users often uses reason
          to decide if the users callback should be called. Values of reason less than 0 are
          reserved for standard meanings. For example ASYN_REASON_SIGNAL is used to mean "out
          of band" request. The devGpib support uses this to report SRQs.</td>
      </tr>
      <tr>
        <td>
          timestamp</td>
        <td>
          Devices which provide their own time stamps use this field to provide the time value
          for records whose TSE field is set to "-2".</td>
      </tr>
      <tr>
        <td>
          auxStatus</td>
        <td>
          Any method can provide additional return information in auxStatus. The meaning is
          determined by the method. Callbacks can use auxStatus to set record alarm status
          in device support callback functions.</td>
      </tr>
      <tr>
        <td>
          alarmStatus</td>
        <td>
          Any method can provide additional return information in alarmStatus. The meaning
          is determined by the method. Callbacks can use alarmStatus to set record alarm status
          in device support callback functions.</td>
      </tr>
      <tr>
        <td>
          alarmSeverity</td>
        <td>
          Any method can provide additional return information in alarmStatus. The meaning
          is determined by the method. Callbacks can use alarmSeverity to set record alarm
          severity in device support callback functions.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynInterface</h3>
  <p>
    This defines an interface registered with asynPortManager:registerPort or asynManager:interposeInterface.</p>
  <pre>typedef struct asynInterface{
    const char *interfaceType; /*For example, asynCommonType */
    void *pinterface;          /*For example, pasynCommon */
    void *drvPvt;
}asynInterface;</pre>
  <table border="1">
    <caption>
      asynInterface</caption>
    <tbody>
      <tr>
        <td>
          interfaceType</td>
        <td>
          A character string describing the interface.</td>
      </tr>
      <tr>
        <td>
          pinterface</td>
        <td>
          A pointer to the interface. The user must cast this to the correct type.</td>
      </tr>
      <tr>
        <td>
          drvPvt</td>
        <td>
          For the exclusive use of the code that called registerPort or interposeInterface.
        </td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynManager</h3>
  <p>
    This is the main interface for communicating with asynDriver.</p>
  <pre>/*registerPort attributes*/
#define ASYN_MULTIDEVICE  0x0001
#define ASYN_CANBLOCK     0x0002

/*standard values for asynUser.reason*/
#define ASYN_REASON_SIGNAL -1

typedef struct interruptNode{
    ELLNODE node;
    void    *drvPvt;
}interruptNode;

typedef void (*userCallback)(asynUser *pasynUser);
typedef void (*exceptionCallback)(asynUser *pasynUser,asynException exception);
typedef void (*timeStampCallback)(void *userPvt, epicsTimeStamp *pTimeStamp);

typedef struct asynManager {
    void      (*report)(FILE *fp,int details,const char*portName);
    asynUser  *(*createAsynUser)(userCallback process,userCallback timeout);
    asynUser  *(*duplicateAsynUser)(asynUser *pasynUser,
                                 userCallback queue,userCallback timeout);
    asynStatus (*freeAsynUser)(asynUser *pasynUser);
    void       *(*memMalloc)(size_t size);
    void       (*memFree)(void *pmem,size_t size);
    asynStatus (*isMultiDevice)(asynUser *pasynUser,
                                const char *portName,int *yesNo);
    /* addr = (-1,&gt;=0) =&gt; connect to (port,device) */
    asynStatus (*connectDevice)(asynUser *pasynUser,
                                const char *portName,int addr);
    asynStatus (*disconnect)(asynUser *pasynUser);
    asynStatus (*exceptionCallbackAdd)(asynUser *pasynUser,
                                       exceptionCallback callback);
    asynStatus (*exceptionCallbackRemove)(asynUser *pasynUser);
    asynInterface *(*findInterface)(asynUser *pasynUser,
                            const char *interfaceType,int interposeInterfaceOK);
    asynStatus (*queueRequest)(asynUser *pasynUser,
                              asynQueuePriority priority,double timeout);
    asynStatus (*cancelRequest)(asynUser *pasynUser,int *wasQueued);
    asynStatus (*blockProcessCallback)(asynUser *pasynUser, int allDevices);
    asynStatus (*unblockProcessCallback)(asynUser *pasynUser, int allDevices);
    asynStatus (*lockPort)(asynUser *pasynUser);
    asynStatus (*unlockPort)(asynUser *pasynUser);
    asynStatus (*queueLockPort)(asynUser *pasynUser);
    asynStatus (*queueUnlockPort)(asynUser *pasynUser);
    asynStatus (*canBlock)(asynUser *pasynUser,int *yesNo);
    asynStatus (*getAddr)(asynUser *pasynUser,int *addr);
    asynStatus (*getPortName)(asynUser *pasynUser,const char **pportName);
    /* drivers call the following*/
    asynStatus (*registerPort)(const char *portName,
                              int attributes,int autoConnect,
                              unsigned int priority,unsigned int stackSize);
    asynStatus (*registerInterface)(const char *portName,
                              asynInterface *pasynInterface);
    asynStatus (*exceptionConnect)(asynUser *pasynUser);
    asynStatus (*exceptionDisconnect)(asynUser *pasynUser);
    /*any code can call the following*/
    asynStatus (*interposeInterface)(const char *portName, int addr,
                              asynInterface *pasynInterface,
                              asynInterface **ppPrev);
    asynStatus (*enable)(asynUser *pasynUser,int yesNo);
    asynStatus (*autoConnect)(asynUser *pasynUser,int yesNo);
    asynStatus (*isConnected)(asynUser *pasynUser,int *yesNo);
    asynStatus (*isEnabled)(asynUser *pasynUser,int *yesNo);
    asynStatus (*isAutoConnect)(asynUser *pasynUser,int *yesNo);
    asynStatus (*setAutoConnectTimeout)(double timeout);
    asynStatus (*waitConnect)(asynUser *pasynUser, double timeout);
    /*The following are methods for interrupts*/
    asynStatus (*registerInterruptSource)(const char *portName,
                               asynInterface *pasynInterface, void **pasynPvt);
    asynStatus (*getInterruptPvt)(asynUser *pasynUser,
                               const char *interfaceType, void **pasynPvt);
    interruptNode *(*createInterruptNode)(void *pasynPvt);
    asynStatus (*freeInterruptNode)(asynUser *pasynUser,interruptNode *pnode);
    asynStatus (*addInterruptUser)(asynUser *pasynUser,
                                  interruptNode*pinterruptNode);
    asynStatus (*removeInterruptUser)(asynUser *pasynUser,
                                  interruptNode*pinterruptNode);
    asynStatus (*interruptStart)(void *pasynPvt,ELLLIST **plist);
    asynStatus (*interruptEnd)(void *pasynPvt);
    /* Time stamp functions */
    asynStatus (*registerTimeStampSource)(asynUser *pasynUser, void *userPvt, timeStampCallback callback);
    asynStatus (*unregisterTimeStampSource)(asynUser *pasynUser);
    asynStatus (*updateTimeStamp)(asynUser *pasynUser);
    asynStatus (*getTimeStamp)(asynUser *pasynUser, epicsTimeStamp *pTimeStamp);
    asynStatus (*setTimeStamp)(asynUser *pasynUser, const epicsTimeStamp *pTimeStamp);

    const char *(*strStatus)(asynStatus status);
}asynManager;
epicsShareExtern asynManager *pasynManager;</pre>
  <table border="1">
    <caption>
      asynManager</caption>
    <tbody>
      <tr>
        <td>
          report</td>
        <td>
          Reports status about the asynPortManager. If portName is non-NULL it reports for
          a specific port. If portName is NULL then it reports for each registered port. It
          also calls asynCommon:report for each port being reported.</td>
      </tr>
      <tr>
        <td>
          createAsynUser</td>
        <td>
          Creates an asynUser. The caller specifies two callbacks, process and timeout. These
          callback are only called as a result of a queueRequest. The timeout callback is
          optional. errorMessageSize characters are allocated for errorMessage. The amount
          of storage can not be changed. This method doesn't return if it is unable to allocate
          the storage.</td>
      </tr>
      <tr>
        <td>
          duplicateAsynUser</td>
        <td>
          Creates an asynUser by calling createAsynUser. It then initializes the new asynUser
          as follows: The fields timeout, userPvt, userData, and drvUser are initialized with
          values taken from pasynUser. Its connectDevice state is the same as that for pasynUser.
        </td>
      </tr>
      <tr>
        <td>
          freeAsynUser</td>
        <td>
          Free an asynUser. The user must free an asynUser only via this call. If the asynUser
          is connected to a port, asynManager:disconnect is called. If the disconnect fails,
          this call will also fail. The storage for the asynUser is saved on a free list and
          will be reused in later calls to createAsynUser or duplicateAsynUser. Thus continually
          calling createAsynUser (or duplicateAsynUser) and freeAsynUser is efficient.</td>
      </tr>
      <tr>
        <td>
          memMalloc
          <p>
            memFree</p>
        </td>
        <td>
          Allocate/Free memory. memMalloc/memFree maintain a set of freelists of different
          sizes. Thus any application that needs storage for a short time can use memMalloc/memFree
          to allocate and free the storage without causing memory fragmentation. The size
          passed to memFree MUST be the same as the value specified in the call to memMalloc.
        </td>
      </tr>
      <tr>
        <td>
          isMultiDevice</td>
        <td>
          Answers the question "Does the port support multiple devices?" This method can be
          called before calling connectDevice.</td>
      </tr>
      <tr>
        <td>
          connectDevice</td>
        <td>
          Connect the asynUser structure to a device specified by portName, addr. The port
          Name is the same as that specified in a call to registerPort. The call will fail
          if the asynUser is already connected to a device. If the port does not support multiple
          devices, than addr is ignored. connectDevice only connects the asynUser to the port
          driver for the portName,addr. The port driver may or may not be connected to the
          actual device. Thus, connectDevice and asynCommon:connect are completely different.
          <p>
            See the Theory of Operation section for a description of the difference between
            single and multi-device port drivers.</p>
        </td>
      </tr>
      <tr>
        <td>
          disconnect</td>
        <td>
          Disconnect the asynUser from the port,addr to which it is connected via a previous
          call to connectDevice. The call will fail if the asynUser is queued or locked, or
          has a callback registered via exceptionCallbackAdd. Note that asynManager:disconnect
          and asynCommon:disconnect are completely different. </td>
      </tr>
      <tr>
        <td>
          exceptionCallbackAdd</td>
        <td>
          Callback will be called whenever one of the exceptions defined by asynException
          occurs. The callback can call isConnected, isEnabled, or isAutoConnect to find the
          connection state. asynTrace provides methods to find out the current trace settings.
        </td>
      </tr>
      <tr>
        <td>
          exceptionCallbackRemove</td>
        <td>
          Callback is removed. This must be called before disconnect.</td>
      </tr>
      <tr>
        <td>
          findInterface</td>
        <td>
          Find a driver interface. If interposeInterfaceOK is true, then findInterface returns
          the last interface registered or interposed. Otherwise, the interface registered
          by registerPort is returned. It returns 0 if the interfaceType is not supported.
          <p>
            The user needs the address of the driver's interface and of pdrvPvt so that calls
            can be made to the driver. For example:</p>
          <pre>asynInterface *pasynInterface;
asynOctet *pasynOctet;
void *pasynOctetPvt;
...
pasynInterface = pasynManager-&gt;findInterface(
        pasynUser,asynOctetType,1);
if(!pasynInterface) { /*error do something*/}
pasynOctet = (asynOctet *)pasynInterface-&gt;pinterface;
pasynOctetPvt = pasynInterface-&gt;pdrvPvt;
...
/* The following call must be made from a callback */
pasynOctet-&gt;read(pasynOctetPvt,pasynUser,...
        </pre>
        </td>
      </tr>
      <tr>
        <td>
          queueRequest</td>
        <td>
          <p>
            When registerPort is called, the caller must specify if it can block, i.e. attribute
            bit ASYN_CANBLOCK is set or cleared. If the port has been registered with ASYN_CANBLOCK
            true then the request is put on a queue for the thread associated with the queue.
            If the port has been registered with ASYN_CANBLOCK false then queueRequest locks
            the port and calls the process callback. In either case the process callback specified
            in the call to createAsynUser is called.</p>
          <p>
            If the asynUser is already on a queue, asynError is returned. The timeout starts
            when the request is queued. A value less than or equal to 0.0 means no timeout.
            The request is removed from the queue before the callback is called. Callbacks are
            allowed to make requests to asynManager such as queueRequest, blockProcessCallback,
            etc. It is even permissible to call freeAsynUser from a callback but the request
            will be delayed until after the callback completes.</p>
          <p>
            The priority asynQueuePriorityConnect must be used for asynCommon:connect and asynCommon:disconnect
            calls, and must NOT be used for any other calls.</p>
          <p>
            If a timeout callback was not passed to createAsynUser and a queueRequest with a
            non-zero timeout is requested, the request fails.</p>
          <p>
            Attempts to queue a request other than a connection request to a disconnected port
            will fail unless the reason is ASYN_REASON_QUEUE_EVEN_IF_NOT_CONNECTED.</p>
        </td>
      </tr>
      <tr>
        <td>
          cancelRequest</td>
        <td>
          If a asynUser is queued, remove it from the queue. If either the process or timeout
          callback is active when cancelRequest is called than cancelRequest will not return
          until the callback completes.</td>
      </tr>
      <tr>
        <td>
          blockProcessCallback
          <p>
            unblockProcessCallback</p>
        </td>
        <td>
          blockProcessCallback is a request to prevent acccess to a device or port by other
          asynUsers between queueRequests. blockProcessCallback can be called from a processCallback
          or when the asynUser has no request queued. When called from processCallback blocking
          starts immediately, otherwise blocking starts the next time processCallback is called.
          Blocking means that no other asynUser's processCallback will be called until unblockProcessCallback
          is called. Note the following restrictions for blockProcessCallback:
          <ul>
            <li>blockProcessCallback only works with drivers that can block and an error is returned
              if it is called for non-blocking drivers.</li>
            <li>queueRequests that specify a priority of asynQueuePriorityConnect are not blocked.</li>
          </ul>
          It is permissible to simultaneously block allDevices and also the device to which
          the asynUser is connected.</td>
      </tr>
      <tr>
        <td>
          lockPort/unlockPort</td>
        <td>
          Lock access to a port driver. This is used by code that is willing to block while
          making calls to a port driver. The code can call lockPort, make an arbitrary number
          of calls to the port driver, and than call unlockPort. Other code that calls queueRequest
          and/or lockPort will be delayed between the calls to lockPort and unlockPort.</td>
      </tr>
      <tr>
        <td>
          queueLockPort/queueUnlockPort</td>
        <td>
          Lock access to a port driver. This is used by code that is willing to block while
          making calls to a port driver. The code can call lockPort, make an arbitrary number
          of calls to the port driver, and than call unlockPort. Other code that calls queueRequest
          and/or lockPort will be delayed between the calls to lockPort and unlockPort. The
          difference between lockPort and queueLockPort is that queueLockPort queues a request
          to lock the port, using the same queues as queueRequest. This means that a thread
          that repeatedly calls queueLockPort without sleeping between calls will still allow
          other threads to access the port. This is not true with lockPort, which will take
          a mutex as soon as the port is free, and can prevent other threads from accessing
          the port at all.</td>
      </tr>
      <tr>
        <td>
          canBlock</td>
        <td>
          yesNo is set to (0,1), i.e. (false,true) if calls to the low level driver can block.
          The value is determined by the attributes passed to registerPort.</td>
      </tr>
      <tr>
        <td>
          getAddr</td>
        <td>
          *addr is set equal to the address which the user specified in the call to connectDevice
          or -1 if the port does not support multiple devices.
          <p>
            See the Theory of Operation section for a description of the difference between
            single and multi-device port drivers.</p>
        </td>
      </tr>
      <tr>
        <td>
          getPortName</td>
        <td>
          *pportName is set equal to the name of the port to which the user is connected.
        </td>
      </tr>
      <tr>
        <td>
          registerPort</td>
        <td>
          This method is called by drivers. A call is made for each port instance. Attributes
          is a set of bits. Currently two bits are defined: ASYN_MULTIDEVICE and ASYN_CANBLOCK.
          The driver must specify these properly. autoConnect, which is (0,1) for (no,yes),
          provides the initial value for the port and all devices connected to the port. priority
          and stacksize are only relevant if ASYN_CANBLOCK=1, in which case asynManager uses
          these values when it creates the port thread with epicsThreadCreate(). If priority
          is 0, then the default value epicsThreadPriorityMedium will be assigned. If stackSize
          is 0, the default value of epicsThreadGetStackSize(epicsThreadStackMedium) will
          be assigned. The portName argument specifies the name by which the upper levels
          of the asyn code will refer to this communication interface instance. The registerPort
          method makes an internal copy of the string to which the name argument points.
        </td>
      </tr>
      <tr>
        <td>
          registerInterface</td>
        <td>
          This is called by port drivers for each supported interface. This method <em>does
            not</em> make a copy of the asynInterface to which the pasynInterface argument
          points. Callers must store the asynInteface in a location which is retained for
          the lifetime of the port. This is commonly done by placing the asynInterface structure
          in the 'driver private' structure.</td>
      </tr>
      <tr>
        <td>
          exceptionConnect</td>
        <td>
          This method must be called by the driver when and only when it connects to a port
          or device.</td>
      </tr>
      <tr>
        <td>
          exceptionDisconnect</td>
        <td>
          This method must be called by the driver when and only when it disconnects from
          a port or device.</td>
      </tr>
      <tr>
        <td>
          interposeInterface</td>
        <td>
          This is called by a software layer between client code and the port driver. For
          example, if a device echos writes then a software module that issues a read after
          each write could be created and call interposeInterface for interface asynOctet.
          <p>
            Multiple interposeInterface calls for a port/addr/interface can be issued. *ppPrev
            is set to the address of the previous asynInterface. Thus the software module that
            last called interposeInterface is called by user code. It in turn can call the software
            module that was the second to last to call interposeInterface. This continues until
            the actual port driver is called.</p>
          <p>
            interposeInterface can also be called with an asynInterface that has not been previously
            registered or replaced. In this case *ppPrev will be null. Thus, new interfaces
            that are unknown to the low level driver can be implemented.</p>
        </td>
      </tr>
      <tr>
        <td>
          enable</td>
        <td>
          If enable is set yes, then queueRequests are not dequeued unless their queue timeout
          occurs.</td>
      </tr>
      <tr>
        <td>
          autoConnect</td>
        <td>
          If autoConnect is true and the port or device is not connected when a user callback
          is scheduled to be called, asynManager calls pasynCommon-&gt;connect. See the discussion
          of Flow of Control below for details.</td>
      </tr>
      <tr>
        <td>
          isConnected</td>
        <td>
          *yesNo is set to (0,1) if the port or device (is not, is) connected.</td>
      </tr>
      <tr>
        <td>
          isEnabled</td>
        <td>
          *yesNo is set to (0,1) if the port or device (is not, is) enabled.</td>
      </tr>
      <tr>
        <td>
          isAutoConnect</td>
        <td>
          *yesNo is set to (0,1) if the portThread (will not, will) autoConnect for the port
          or device.</td>
      </tr>
      <tr>
        <td>
          setAutoConnectTimeout</td>
        <td>
          Changes the timeout when waiting for the initial connection callback from port drivers.
          This callback occurs in response to asynManager queueing a connection request, which
          happens when the port driver registers its asynCommon interface. The default timeout
          is 0.5 seconds.</td>
      </tr>
      <tr>
        <td>
          waitConnect</td>
        <td>
          Wait for up to timeout seconds for the port/device to connect.</td>
      </tr>
      <tr>
        <td>
          registerInterruptSource</td>
        <td>
          If a low level driver supports interrupts it must call this for each interface that
          supports interrupts. pasynPvt must be the address of a void * that will be given
          a value by registerInterruptSource. This argument is passed interruptStart and interruptEnd.
        </td>
      </tr>
      <tr>
        <td>
          getInterruptPvt</td>
        <td>
          Any code that wants to call createInterruptNode but does not know the adresss of
          pasynPvt can find it via this method. The caller must be connected to a device,
          i.e. must have called connectDevice. If the caller is not connected, getInterruptPvt
          returns asynError.</td>
      </tr>
      <tr>
        <td>
          createInterruptNode
          <p>
            freeInterruptNode</p>
        </td>
        <td>
          These methods are the only way a user can allocate and free an interruptNode. pasynPvt
          is the value obtained from getInterruptPvt. createInterruptNode/freeInterruptNode
          are separate methods rather than being done automatically by addInterruptUser/removeInterruptUser
          so that addInterruptUser/removeInterruptUser can be efficient.</td>
      </tr>
      <tr>
        <td>
          addInterruptUser
          <p>
            removeInterruptUser</p>
        </td>
        <td>
          Code that implements registerInterruptUser/cancelInterruptUser must call addInterruptUser/removeInterruptUser
          to add and remove users from the list or else calls to interruptStart/interruptEnd
          will not work. This is an efficient operation so that a user can repeatedly call
          registerInterruptUser/cancelInterruptUser. If either of these is called while a
          interrupt is being processed, i.e. between calls to interruptStart/interruptEnd,
          the call will block until interruptEnd is called. The process callback for the asynUser
          specified in the call to addInterruptUser must not call removeInterruptUser or it
          will block forever.</td>
      </tr>
      <tr>
        <td>
          interruptStart
          <p>
            interruptEnd</p>
        </td>
        <td>
          The code that implements interrupts is interface dependent. The only service asynManager
          provides is a thread-safe implemention of the user list. When the code wants to
          call the callback specified in the calls to registerInterruptUser, it calls interruptStart
          to obtain the list of callbacks. When it is done it calls interruptEnd. If any requests
          are made to addInterruptUser/removeInterruptUser between the calls to interruptStart
          and interruptEnd, asynManager delays the requests until interruptEnd is called.
        </td>
      </tr>
      <tr>
        <td>
          registerTimeStampSource</td>
        <td>
          Registers a user-defined time stamp callback function.</td>
      </tr>
      <tr>
        <td>
          unregisterTimeStampSource</td>
        <td>
          Unregisters any user-defined timestamp callback function and reverts to the default
          timestamp source function in asynManager, which simply calls epicsTimeGetCurrent().
        </td>
      </tr>
      <tr>
        <td>
          updateTimeStamp</td>
        <td>
          Set the current time stamp for this port by calling either the default timestamp
          source, or a user-defined timestamp source that was registered with registerTimeStampSource.
        </td>
      </tr>
      <tr>
        <td>
          getTimeStamp</td>
        <td>
          Get the current time stamp for this port that was returned by the most recent call
          to updateTimeStamp. </td>
      </tr>
      <tr>
        <td>
          setTimeStamp</td>
        <td>
          Set the current time stamp for this port directly from the timestamp value passed
          to this function. </td>
      </tr>
      <tr>
        <td>
          strStatus</td>
        <td>
          Returns a descriptive string corresponding to the asynStatus value.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynCommon</h3>
  <p>
    asynCommon describes the methods that must be implemented by drivers.</p>
  <pre>/* Device Interface supported by ALL asyn drivers*/
#define asynCommonType "asynCommon"
typedef struct  asynCommon {
    void       (*report)(void *drvPvt,FILE *fp,int details);
    /*following are to connect/disconnect to/from hardware*/
    asynStatus (*connect)(void *drvPvt,asynUser *pasynUser);
    asynStatus (*disconnect)(void *drvPvt,asynUser *pasynUser);
}asynCommon;</pre>
  <table border="1">
    <caption>
      asynCommon</caption>
    <tbody>
      <tr>
        <td>
          report</td>
        <td>
          Generates a report about the hardware device. This is the only asynCommon method
          that does not have to be called by the queueRequest callback or between calls to
          lockPort/unlockPort.</td>
      </tr>
      <tr>
        <td>
          connect</td>
        <td>
          Connect to the hardware device or communication path. The queueRequest must specify
          priority asynQueuePriorityConnect.</td>
      </tr>
      <tr>
        <td>
          disconnect</td>
        <td>
          Disconnect from the hardware device or communication path. The queueRequest must
          specify priority asynQueuePriorityConnect.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynCommonSyncIO</h3>
  <p>
    asynCommonSyncIO provides a convenient interface for software that needs to perform
    "synchronous" operations to an asyn device, i.e. that blocks while waiting for the
    port to be available and for the operation to complete. The code does not need to
    handle callbacks or understand the details of the asynManager and asynCommon interfaces.</p>
  <pre>typedef struct asynCommonSyncIO {
    asynStatus (*connect)(const char *port, int addr, 
                          asynUser **ppasynUser, const char *drvInfo);
    asynStatus (*disconnect)(asynUser *pasynUser);
    asynStatus (*connectDevice)(asynUser *pasynUser);
    asynStatus (*disconnectDevice)(asynUser *pasynUser);
    asynStatus (*report)(asynUser *pasynUser, FILE *fd, int details);
} asynCommonSyncIO;
epicsShareExtern asynCommonSyncIO *pasynCommonSyncIO;</pre>
  <p>
    Note that there is a potential for confusion in the connect* and disconnect* function
    names of this interface. For consistency with the other SyncIO interfaces, connect
    calls pasynManager-&gt;connectDevice, disconnect calls pasynManager-&gt;disconnect,
    connectDevice calls asynCommon-&gt;connect, and disconnectDevice calls asynCommon-&gt;disconnect.</p>
  <h3>
    asynDrvUser</h3>
  <p>
    asynDrvUser provides methods that allow an asynUser to communicate user specific
    information to/from a port driver</p>
  <pre>#define asynDrvUserType "asynDrvUser"
typedef struct  asynDrvUser {
    /*The following do not have to be called via queueRequest callback*/
    asynStatus (*create)(void *drvPvt,asynUser *pasynUser,
        const char *drvInfo, const char **pptypeName,size_t *psize);
    asynStatus (*getType)(void *drvPvt,asynUser *pasynUser,
        const char **pptypeName,size_t *psize);
    asynStatus (*destroy)(void *drvPvt,asynUser *pasynUser);
}asynDrvUser;</pre>
  <table border="1">
    <caption>
      asynDrvUser</caption>
    <tbody>
      <tr>
        <td>
          create</td>
        <td>
          The user, i.e. device support calls create. The driver can create any resources
          it needs. It can use pasynUser-&gt;drvUser to provide access to the resources. If
          the asynUser and the driver both know how to access the resources they must agree
          about the name for the resource and a size. If pptypeName is not null the driver
          can give a value to *pptypeName. If psize is not null the driver can give a value
          to *psize. Unless asynUser receives a typeName and size that it recognizes it must
          not access asynUser.drvUser.</td>
      </tr>
      <tr>
        <td>
          getType</td>
        <td>
          If other code, e.g. an interposeInterface wants to access asynUser.drvUser it must
          call this and verify that typeName and size are what it expects.</td>
      </tr>
      <tr>
        <td>
          destroy</td>
        <td>
          Destroy the resources created by create and set asynUser.drvUser null.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynLockPortNotify</h3>
  <p>
    This is provided for port drivers that are an asynUser of another port driver. For
    example a serial bus driver can be implemented by connecting to a standard serial
    port to perform the actual I/O. When the serial bus port is locked, either by the
    requester calling lockPort or because a queueRequest was dequeued, then the serial
    bus driver needs to lock the associated serial port.</p>
  <p>
    The serial bus driver registers interface asynLockPortNotify. Whenever the serial
    bus port is locked, asynManager calls pasynLockPortNotify.lock. The serial bus driver
    calls asynManager.lockPort for the serial port to which it is connected. Similarly
    for unlockPort. Thus while the serial bus port is locked, the serial bus is also
    locked.</p>
  <p>
    asynLockPortNotify is used only by asynManager itself. It is not put in the list
    of interfaces for the port.</p>
  <p>
    asynLockPortNotify is:</p>
  <pre>#define asynLockPortNotifyType "asynLockPortNotify"
typedef struct  asynLockPortNotify {
    asynStatus (*lock)(void *drvPvt,asynUser *pasynUser);
    asynStatus (*unlock)(void *drvPvt,asynUser *pasynUser);
}asynLockPortNotify;</pre>
  <table border="1">
    <caption>
      asynLockPortNotify</caption>
    <tbody>
      <tr>
        <td>
          lock</td>
        <td>
          Called when asynManager.lockPort is called. The driver normally calls asynManager.lockPort
          for the port to which it is connected.</td>
      </tr>
      <tr>
        <td>
          unlock</td>
        <td>
          Called when asynManager.unlockPort is called. The driver normally calls asynManager.unlockPort
          for the port to which it is connected.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynOption</h3>
  <p>
    asynOption provides a generic way of setting driver specific options. For example
    the serial port driver uses this to specify baud rate, stop bits, etc.</p>
  <pre>#define asynOptionType "asynOption"
/*The following are generic methods to set/get device options*/
typedef struct asynOption {
    asynStatus (*setOption)(void *drvPvt, asynUser *pasynUser,
                                const char *key, const char *val);
    asynStatus (*getOption)(void *drvPvt, asynUser *pasynUser,
                                const char *key, char *val, int sizeval);
}asynOption;</pre>
  <table border="1">
    <caption>
      asynOption</caption>
    <tbody>
      <tr>
        <td>
          setOption</td>
        <td>
          Set value associated with key.</td>
      </tr>
      <tr>
        <td>
          getOption</td>
        <td>
          Get value associated with key.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    Trace Interface</h3>
  <pre>/*asynTrace is implemented by asynManager*/
/*All asynTrace methods can be called from any thread*/
/* traceMask definitions*/
#define ASYN_TRACE_ERROR     0x0001
#define ASYN_TRACEIO_DEVICE  0x0002
#define ASYN_TRACEIO_FILTER  0x0004
#define ASYN_TRACEIO_DRIVER  0x0008
#define ASYN_TRACE_FLOW      0x0010
#define ASYN_TRACE_WARNING   0x0020

/* traceIO mask definitions*/
#define ASYN_TRACEIO_NODATA 0x0000
#define ASYN_TRACEIO_ASCII  0x0001
#define ASYN_TRACEIO_ESCAPE 0x0002
#define ASYN_TRACEIO_HEX    0x0004

/* traceInfo mask definitions*/
#define ASYN_TRACEINFO_TIME 0x0001
#define ASYN_TRACEINFO_PORT 0x0002
#define ASYN_TRACEINFO_SOURCE 0x0004
#define ASYN_TRACEINFO_THREAD 0x0008

/* asynPrint and asynPrintIO are macros that act like
   int asynPrintSource(asynUser *pasynUser,int reason, __FILE__, __LINE__, const char *format, ... );
   int asynPrintIOSource(asynUser *pasynUser,int reason,
        const char *buffer, size_t len, __FILE__, __LINE__, const char *format, ... );
*/
typedef struct asynTrace {
    /* lock/unlock are only necessary if caller performs I/O other than */
    /* by calling asynTrace methods                                     */
    asynStatus (*lock)(asynUser *pasynUser);
    asynStatus (*unlock)(asynUser *pasynUser);
    asynStatus (*setTraceMask)(asynUser *pasynUser,int mask);
    int        (*getTraceMask)(asynUser *pasynUser);
    asynStatus (*setTraceIOMask)(asynUser *pasynUser,int mask);
    int        (*getTraceIOMask)(asynUser *pasynUser);
    asynStatus (*setTraceInfoMask)(asynUser *pasynUser,int mask);
    int        (*getTraceInfoMask)(asynUser *pasynUser);
    asynStatus (*setTraceFile)(asynUser *pasynUser,FILE *fp);
    FILE       *(*getTraceFile)(asynUser *pasynUser);
    asynStatus (*setTraceIOTruncateSize)(asynUser *pasynUser,size_t size);
    size_t     (*getTraceIOTruncateSize)(asynUser *pasynUser);
#if defined(__GNUC__) &amp;&amp; (__GNUC__ &lt; 3)
    /* GCC 2.95 does not allow EPICS_PRINTF_STYLE on function pointers */
    int        (*print)(asynUser *pasynUser,int reason, const char *pformat, ...);
    int        (*printSource)(asynUser *pasynUser,int reason, const char *fileName, int line, const char *pformat, ...);
    int        (*vprint)(asynUser *pasynUser,int reason, const char *pformat, va_list pvar);
    int        (*vprintSource)(asynUser *pasynUser,int reason, const char *file, int line, const char *pformat, va_list pvar);
    int        (*printIO)(asynUser *pasynUser,int reason,
                    const char *buffer, size_t len,const char *pformat, ...);
    int        (*printIOSource)(asynUser *pasynUser,int reason,
                    const char *buffer, size_t len,const char *file, int line, const char *pformat, ...);
    int        (*vprintIO)(asynUser *pasynUser,int reason,
                    const char *buffer, size_t len,const char *pformat, va_list pvar);
    int        (*vprintIOSource)(asynUser *pasynUser,int reason,
                    const char *buffer, size_t len,const char *file, int line, const char *pformat, va_list pvar);
#else
    int        (*print)(asynUser *pasynUser,int reason, const char *pformat, ...) EPICS_PRINTF_STYLE(3,4);
    int        (*printSource)(asynUser *pasynUser,int reason, const char *fileName, int line, const char *pformat, ...) EPICS_PRINTF_STYLE(5,6);
    int        (*vprint)(asynUser *pasynUser,int reason, const char *pformat, va_list pvar) EPICS_PRINTF_STYLE(3,0);
    int        (*vprintSource)(asynUser *pasynUser,int reason, const char *file, int line, const char *pformat, va_list pvar) EPICS_PRINTF_STYLE(5,0);
    int        (*printIO)(asynUser *pasynUser,int reason,
                    const char *buffer, size_t len,const char *pformat, ...) EPICS_PRINTF_STYLE(5,6);
    int        (*printIOSource)(asynUser *pasynUser,int reason,
                    const char *buffer, size_t len,const char *file, int line, const char *pformat, ...) EPICS_PRINTF_STYLE(7,8);
    int        (*vprintIO)(asynUser *pasynUser,int reason,
                    const char *buffer, size_t len,const char *pformat, va_list pvar) EPICS_PRINTF_STYLE(5,0);
    int        (*vprintIOSource)(asynUser *pasynUser,int reason,
                    const char *buffer, size_t len,const char *file, int line, const char *pformat, va_list pvar) EPICS_PRINTF_STYLE(7,0);
#endif
}asynTrace;
epicsShareExtern asynTrace *pasynTrace;
</pre>
  <h3>
    asynTrace</h3>
  <p>
    asynDriver provides a trace facility with the following attributes:</p>
  <ul>
    <li>Tracing is turned on/off for individual devices, i.e. a portName, addr.</li>
    <li>Trace has a global trace mask for asynUsers not connected to a port or port, addr.</li>
    <li>The output is sent to a file or to stdout or to errlog.</li>
    <li>A mask determines the type of information that can be displayed. The various choices
      can be ORed together. The default value of this mask when a port is created is ASYN_TRACE_ERROR.
      <ul>
        <li>ASYN_TRACE_ERROR Run time errors are reported, e.g. timeouts.</li>
        <li>ASYN_TRACEIO_DEVICE Device support reports I/O activity.</li>
        <li>ASYN_TRACEIO_FILTER Any layer between device support and the low level driver
          reports any filtering it does on I/O.</li>
        <li>ASYN_TRACEIO_DRIVER Low level driver reports I/O activity.</li>
        <li>ASYN_TRACE_FLOW Report logic flow. Device support should report all queue requests,
          callbacks entered, and all calls to drivers. Layers between device support and low
          level drivers should report all calls they make to lower level drivers. Low level
          drivers report calls they make to other support.</li>
        <li>ASYN_TRACE_WARNING Report warnings, i.e. conditions that are between ASYN_TRACE_ERROR
          and ASYN_TRACE_FLOW.</li>
      </ul>
    </li>
    <li>Another mask determines how message buffers are printed. The various choices can
      be ORed together. The default value of this mask when a port is created is ASYN_TRACEIO_NODATA.
      <ul>
        <li>ASYN_TRACEIO_NODATA Don't print any data from the message buffers.</li>
        <li>ASYN_TRACEIO_ASCII Print with a "%s" style format.</li>
        <li>ASYN_TRACEIO_ESCAPE Call epicsStrPrintEscaped.</li>
        <li>ASYN_TRACEIO_HEX Print each byte with " %2.2x".</li>
      </ul>
    </li>
    <li>Another mask determines what information is printed at the beginning of each message.
      The various choices can be ORed together. The default value of this mask when a
      port is created is ASYN_TRACEINFO_TIME.
      <ul>
        <li>ASYN_TRACEINFO_TIME prints the date and time of the message.</li>
        <li>ASYN_TRACEINFO_PORT prints [port,addr,reason], where port is the port name, addr
          is the asyn address, and reason is pasynUser-&gt;reason. These are the 3 pieces
          of "addressing" information in asyn.</li>
        <li>ASYN_TRACEINFO_SOURCE prints the file name and line number, i.e. [__FILE__,__LINE__]
          where the asynPrint or asynPrintIO statement occurs.</li>
        <li>ASYN_TRACEINFO_THREAD prints the thread name, thread ID and thread priority, i.e.
          [epicsThreadGetNameSelf(), epicsThreadGetIdSelf(), epicsThreadGetPrioritySelf()].</li>
      </ul>
    </li>
  </ul>
  <p>
    In order for the trace facility to perform properly; device support and all drivers
    must use the trace facility. Device and driver support can directly call the asynTrace
    methods. The asynPrint and asynPrintIO macros are provided so that it is easier
    for device/driver support. Support can have calls like:</p>
  <pre>    asynPrint(pasynUser,ASYN_TRACE_FLOW,"%s Calling queueRequest\n",
        someName);</pre>
  <p>
    The asynPrintIO call is designed for device support or drivers that issue read or
    write requests. They make calls like:</p>
  <pre>    asynPrintIO(pasynUser,ASYN_TRACEIO_DRIVER,data,nchars,"%s nchars %d",</pre>
  <pre>                someName,nchars);</pre>
  <p>
    The asynTrace methods are implemented by asynManager. These methods can be used
    by any code that has created an asynUser and is connected to a device. All methods
    can be called by any thread. That is, an application thread and/or a portThread.
    If a thread performs all I/O via calls to print or printIO, then it does not have
    to call lock or unlock. If it does want to do its own I/O, it must lock before any
    I/O and unlock after. For example:</p>
  <pre>    pasynTrace-&gt;lock(pasynUser);
    fd = pasynTrace-&gt;getTraceFile(pasynUser);
    /*perform I/O to fd */
    pasynTrace-&gt;unlock(pasynUser);</pre>
  <p>
    If the asynUser is not connected to a port, i.e. pasynManager-&gt;connectDevice
    has not been called, then a "global" device is assumed. This is useful when asynPrint
    is called before connectDevice.</p>
  <table border="1">
    <caption>
      asynTrace</caption>
    <tbody>
      <tr>
        <td>
          lock/unlock</td>
        <td>
          These are only needed for code that call asynTrace.print or asynTrace.printIO instead
          of asynPrint and asynPrintIO.
          <p>
            print, and printIO both lock while performing their operations. The get methods
            do not lock (except for getTraceFile) and they are safe. Except for setTraceFile
            the set methods do not block, since worst that can happen is that the user gets
            a little more or a little less output.</p>
        </td>
      </tr>
      <tr>
        <td>
          setTraceMask</td>
        <td>
          Set the trace mask. Normally set by the user requesting it via a shell command or
          the devTrace device support. Setting the trace mask for a port also sets the trace
          mask for all devices connected to that port</td>
      </tr>
      <tr>
        <td>
          getTraceMask</td>
        <td>
          Get the trace mask. Device support that wants to issue trace messages calls this
          to see what trace options have been requested.</td>
      </tr>
      <tr>
        <td>
          setTraceIOMask</td>
        <td>
          Set the traceIO mask. Normally set by the user requesting it via a shell command
          or the devTrace device support. Setting the traceIO mask for a port also sets the
          traceIO mask for all devices connected to that port</td>
      </tr>
      <tr>
        <td>
          getTraceIOMask</td>
        <td>
          Get the traceIO mask. Support that wants to issue its own IO messages instead of
          calling asynPrintIO should call this and honor the mask settings. Most code will
          not need it.</td>
      </tr>
      <tr>
        <td>
          setTraceInfoMask</td>
        <td>
          Set the traceInfo mask. Normally set by the user requesting it via a shell command
          or the devTrace device support. Setting the traceInfo mask for a port also sets
          the traceInfo mask for all devices connected to that port</td>
      </tr>
      <tr>
        <td>
          getTraceInfoMask</td>
        <td>
          Get the traceInfo mask. Support that wants to issue its own IO messages instead
          of calling asynPrint should call this and honor the mask settings. Most code will
          not need it.</td>
      </tr>
      <tr>
        <td>
          setTraceFile</td>
        <td>
          Set the stream to use for output. A NULL argument means use errlog. Normally set
          by the user requesting it via a shell command or by the devTrace device support.
          If the current output stream is none of (NULL, stdout, stderr) then the current
          output stream is closed before the new stream is used.</td>
      </tr>
      <tr>
        <td>
          getTraceFile</td>
        <td>
          Get the file descriptor to use for output. Device support that wants to issue its
          own IO messages instead of calling asynPrintIO should call this and honor the mask
          settings. In this case, lock must have been called first. Most code will not need
          it. If the return value is 0, then ouput should be directed to errlog.</td>
      </tr>
      <tr>
        <td>
          setTraceIOTruncateSize</td>
        <td>
          Determines how much data is printed by printIO. In all cases it determines how many
          bytes of the buffer are displayed. The actual number of characters printed depends
          on the traceIO mask. For example ASYN_TRACEIO_HEX results in 3 characters being
          printed for each byte. Normally set by the user requesting it via a shell command
          or the devTrace device support.</td>
      </tr>
      <tr>
        <td>
          getTraceIOTruncateSize</td>
        <td>
          Get the current truncate size. Called by asynPrintIO. Code that does its own I/O
          should also support the traceIO mask.</td>
      </tr>
      <tr>
        <td>
          print</td>
        <td>
          If reason ORed with the current traceMask is not zero, then the message is printed.
          This method is provided for backwards compatibility. The asynPrint macro now calls
          printSource().</td>
      </tr>
      <tr>
        <td>
          printSource</td>
        <td>
          If reason ORed with the current traceMask is not zero, then the message is printed.
          Most code should call asynPrint instead of calling this method. This method is the
          same as print() but with the additional <b>file</b> and <b>line</b> arguments.
        </td>
      </tr>
      <tr>
        <td>
          vprint</td>
        <td>
          This is the same as print, but using a va_list as its final argument.</td>
      </tr>
      <tr>
        <td>
          vprintSource</td>
        <td>
          This is the same as printSource, but using a va_list as its final argument.</td>
      </tr>
      <tr>
        <td>
          printIO</td>
        <td>
          If reason ORed with the current traceMask is not zero then the message is printed.
          If len is &gt;0, then the buffer is printed using the traceIO mask and getTraceIOTruncateSize.
          This method is provided for backwards compatibility. The asynPrintIO macro now calls
          printIOSource().</td>
      </tr>
      <tr>
        <td>
          printIOSource</td>
        <td>
          If reason ORed with the current traceMask is not zero then the message is printed.
          If len is &gt;0, then the buffer is printed using the traceIO mask and getTraceIOTruncateSize.
          Most code should call asynPrintIO instead of calling this method. This method is
          the same as printIO() but with the additional <b>file</b> and <b>line</b> arguments.
        </td>
      </tr>
      <tr>
        <td>
          vprintIO</td>
        <td>
          This is the same as printIO, but using a va_list as its final argument.</td>
      </tr>
      <tr>
        <td>
          vprintIOSource</td>
        <td>
          This is the same as printIOSource, but using a va_list as its final argument.</td>
      </tr>
    </tbody>
  </table>
  <hr />
  <div style="text-align: center">
    <h2 id="standardMessageInterfaces">
      Standard Message Based Interfaces</h2>
  </div>
  <p>
    These are interfaces for communicating with message based devices, where message
    based means that the device communicates via octet strings, i.e. arrays of 8 bit
    bytes. Three interfaces are provided: asynOctet, asynOctetBase, and asynOctetSyncIO.
    asynOctet is generic message based interface. asynOctetBase is an interface used
    by port drivers that implement asynOctet. It's primary purpose is to help with interrupt
    support. asynOctetSyncIO provides a synchronous inteface to asynOctet and can be
    used by code that is willing to block.</p>
  <h3>
    asynOctet</h3>
  <p>
    asynOctet describes the methods implemented by drivers that use octet strings for
    sending commands and receiving responses from a device.</p>
  <p>
    NOTE: The name octet is used instead of ASCII because it implies that communication
    is done via 8-bit bytes.</p>
  <pre>#define ASYN_EOM_CNT 0x0001 /*Request count reached*/
#define ASYN_EOM_EOS 0x0002 /*End of String detected*/
#define ASYN_EOM_END 0x0004 /*End indicator detected*/

typedef void (*interruptCallbackOctet)(void *userPvt, asynUser *pasynUser,
              char *data,size_t numchars, int eomReason);

typedef struct asynOctetInterrupt {
    asynUser *pasynUser;
    int      addr;
    interruptCallbackOctet callback;
    void *userPvt;
}asynOctetInterrupt;


#define asynOctetType "asynOctet"
typedef struct asynOctet{
    asynStatus (*write)(void *drvPvt,asynUser *pasynUser,
                    const char *data,size_t numchars,size_t *nbytesTransfered);
    asynStatus (*read)(void *drvPvt,asynUser *pasynUser,
                    char *data,size_t maxchars,size_t *nbytesTransfered,
                    int *eomReason);
    asynStatus (*flush)(void *drvPvt,asynUser *pasynUser);
    asynStatus (*registerInterruptUser)(void *drvPvt,asynUser *pasynUser,
                    interruptCallbackOctet callback, void *userPvt,
                    void **registrarPvt);
    asynStatus (*cancelInterruptUser)(void *drvPvt, asynUser *pasynUser,
                    void *registrarPvt);
    asynStatus (*setInputEos)(void *drvPvt,asynUser *pasynUser,
                    const char *eos,int eoslen);
    asynStatus (*getInputEos)(void *drvPvt,asynUser *pasynUser,
                    char *eos, int eossize, int *eoslen);
    asynStatus (*setOutputEos)(void *drvPvt,asynUser *pasynUser,
                    const char *eos,int eoslen);
    asynStatus (*getOutputEos)(void *drvPvt,asynUser *pasynUser,
                    char *eos, int eossize, int *eoslen);
}asynOctet;
/* asynOctetBase does the following:
   calls  registerInterface for asynOctet.
   Implements registerInterruptUser and cancelInterruptUser
   Provides default implementations of all methods.
   registerInterruptUser and cancelInterruptUser can be called
   directly rather than via queueRequest.
*/

#define asynOctetBaseType "asynOctetBase"
typedef struct asynOctetBase {
    asynStatus (*initialize)(const char *portName,
        asynDriverasynInterface *pasynOctetInterface,
        int processEosIn,int processEosOut,int interruptProcess);
    void       (*callInterruptUsers)(asynUser *pasynUser,void *pasynPvt,
        char *data,size_t *nbytesTransfered,int *eomReason);
} asynOctetBase;
epicsShareExtern asynOctetBase *pasynOctetBase;</pre>
  <p>
  </p>
  <table border="1">
    <caption>
      asynOctet</caption>
    <tbody>
      <tr>
        <td>
          write</td>
        <td>
          Send a message to the device. *nbytesTransfered is the number of 8-bit bytes sent
          to the device. Interpose or driver code may add end of string terminators to the
          message but the extra characters are not included in *nbytesTransfered.</td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Read a message from the device. *nbytesTransfered is the number of 8-bit bytes read
          from the device. If read returns asynSuccess than eomReason ( some combination of
          ASYN_EOM_CNT, ASYN_EOM_EOS, and ASYN_EOM_END)tells why the read completed. Interpose
          or driver code may strip end of string terminators from the message. If it does
          the first eos character will be replaced by null and the eos characters will not
          be included in nbytesTransfered.</td>
      </tr>
      <tr>
        <td>
          flush</td>
        <td>
          Flush the input buffer.</td>
      </tr>
      <tr>
        <td>
          registerInterruptUser</td>
        <td>
          Register a user that will be called whenever a new message is received. NOTE: The
          callback must not block and must not call registerInterruptUser or cancelInterruptUser.
        </td>
      </tr>
      <tr>
        <td>
          cancelInterruptUser</td>
        <td>
          Cancel a registered user.</td>
      </tr>
      <tr>
        <td>
          setInputEos</td>
        <td>
          Set End Of String for input. For example "\n". Note that gpib drivers usually accept
          at most a one character terminator.</td>
      </tr>
      <tr>
        <td>
          getInputEos</td>
        <td>
          Get the current End of String.</td>
      </tr>
      <tr>
        <td>
          setOutputEos</td>
        <td>
          Set End Of String for output.</td>
      </tr>
      <tr>
        <td>
          getOutputEos</td>
        <td>
          Get the current End of String.</td>
      </tr>
    </tbody>
  </table>
  <p>
    asynOctetBase is an interface and implementation for drivers that implement interface
    asynOctet. asynOctetBase implements registerInterruptUser and cancelInterruptUser.</p>
  <p>
    For single device support, it can optionally implement interrupt support. A driver
    that implements interrupts must call registerInterruptSource. If it asks asynOctetBase
    to handle interrupts it calls asynOctetBase:callInterruptUsers when it has new data.</p>
  <p>
    For single device support asynOctetBase can optionally call asynInterposeEosConfig
    to handle end of string processing for input and/or output.</p>
  <p>
    Any null method in the interface passed to initialize are replaced by a method supplied
    by asynOctetBase.</p>
  <p>
    For an example of how to use asynOctetBase look at <span style="font-family: courier">
      asyn/testApp/src/echoDriver.c</span></p>
  <table border="1">
    <caption>
      asynOctetBase</caption>
    <tbody>
      <tr>
        <td>
          initialize</td>
        <td>
          After a driver calls registerPort it can call:
          <pre>pasynOctetBase-&gt;initialize(...</pre>
          Any null methods in the asynInterface are replaced by default implementations. If
          the port is not multi-device and either processEosIn or processEosOut is specified,
          asynInterposeEosConfig is called. If the port is not multi-device and interruptProcess
          is specified, then whenever read is called, asynBase calls all the registered interrupt
          users. asynOctetBase can not implement processEosIn, processEosOut, and interruptProcess
          if the port is a multi-device port. Since this method is called only during initialization
          it can be called directly rather than via queueRequest.</td>
      </tr>
      <tr>
        <td>
          callInterruptUsers</td>
        <td>
          Calls the callbacks registered via registerInterruptUser.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynOctetSyncIO</h3>
  <p>
    asynOctetSyncIO provides a convenient interface for software that needs to perform
    "synchronous" I/O to an asyn device, i.e. that starts an I/O operation and then
    blocks while waiting for the response. The code does not need to handle callbacks
    or understand the details of the asynManager and asynOctet interfaces. Examples
    include motor drivers running in their own threads, SNL programs, and the shell
    commands described later in this document.</p>
  <pre>typedef struct asynOctetSyncIO {
   asynStatus (*connect)(const char *port, int addr,
                         asynUser **ppasynUser, const char *drvInfo);
   asynStatus (*disconnect)(asynUser *pasynUser);
   asynStatus (*write)(asynUser *pasynUser,
                  char const *buffer, size_t buffer_len,
                  double timeout,size_t *nbytesTransfered);
   asynStatus (*read)(asynUser *pasynUser, char *buffer, size_t buffer_len,
                  double timeout, size_t *nbytesTransfered,int *eomReason);
   asynStatus (*writeRead)(asynUser *pasynUser,
                  const char *write_buffer, size_t write_buffer_len,
                  char *read_buffer, size_t read_buffer_len,
                  double timeout,
                  size_t *nbytesOut, size_t *nbytesIn, int *eomReason);
   asynStatus (*flush)(asynUser *pasynUser);
   asynStatus (*setInputEos)(asynUser *pasynUser,
                  const char *eos,int eoslen);
   asynStatus (*getInputEos)(asynUser *pasynUser,
                  char *eos, int eossize, int *eoslen);
   asynStatus (*setOutputEos)(asynUser *pasynUser,
                  const char *eos,int eoslen);
   asynStatus (*getOutputEos)(asynUser *pasynUser,
                  char *eos, int eossize, int *eoslen);
   asynStatus (*writeOnce)(const char *port, int addr,
                  char const *buffer, size_t buffer_len, double timeout,
                  size_t *nbytesTransfered, const char *drvInfo);
   asynStatus (*readOnce)(const char *port, int addr,
                  char *buffer, size_t buffer_len, double timeout,
                  size_t *nbytesTransfered,int *eomReason, const char *drvInfo);
   asynStatus (*writeReadOnce)(const char *port, int addr,
                  const char *write_buffer, size_t write_buffer_len,
                  char *read_buffer, size_t read_buffer_len,
                  double timeout,
                  size_t *nbytesOut, size_t *nbytesIn, int *eomReason,
                  const char *drvInfo);
   asynStatus (*flushOnce)(const char *port, int addr,const char *drvInfo);
   asynStatus (*setInputEosOnce)(const char *port, int addr,
                  const char *eos,int eoslen,const char *drvInfo);
   asynStatus (*getInputEosOnce)(const char *port, int addr,
                  char *eos, int eossize, int *eoslen,const char *drvInfo);
   asynStatus (*setOutputEosOnce)(const char *port, int addr,
                  const char *eos,int eoslen,const char *drvInfo);
   asynStatus (*getOutputEosOnce)(const char *port, int addr,
                  char *eos, int eossize, int *eoslen,const char *drvInfo);
} asynOctetSyncIO;
epicsShareExtern asynOctetSyncIO *pasynOctetSyncIO;</pre>
  <table border="1">
    <caption>
      asynOctetSyncIO</caption>
    <tbody>
      <tr>
        <td>
          connect</td>
        <td>
          Connects to an asyn port and address, returns a pointer to an asynUser structure.
        </td>
      </tr>
      <tr>
        <td>
          disconnect</td>
        <td>
          Disconnect. This frees all resources allocated by connect.</td>
      </tr>
      <tr>
        <td>
          write</td>
        <td>
          Calls asynOctet-&gt;write and waits for the operation to complete or time out.
        </td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Calls asynOctet-&gt;read. Waits for the operation to complete or time out.</td>
      </tr>
      <tr>
        <td>
          writeRead</td>
        <td>
          Calls pasynOctet-&gt;flush, pasynOctet-&gt;write, and asynOctet-&gt;read. Waits
          for the operations to complete or time out.</td>
      </tr>
      <tr>
        <td>
          flush</td>
        <td>
          Calls pasynOctet-&gt;flush</td>
      </tr>
      <tr>
        <td>
          setInputEos</td>
        <td>
          Calls pasynOctet-&gt;setInputEos</td>
      </tr>
      <tr>
        <td>
          getInputEos</td>
        <td>
          Calls pasynOctet-&gt;getInputEos</td>
      </tr>
      <tr>
        <td>
          setOutputEos</td>
        <td>
          Calls pasynOctet-&gt;setOutputEos</td>
      </tr>
      <tr>
        <td>
          getOutputEos</td>
        <td>
          Calls pasynOctet-&gt;getOutputEos</td>
      </tr>
      <tr>
        <td>
          writeOnce</td>
        <td>
          This does a connect, write, and disconnect.</td>
      </tr>
      <tr>
        <td>
          readOnce</td>
        <td>
          This does a connect, read, and disconnect.</td>
      </tr>
      <tr>
        <td>
          readOnce</td>
        <td>
          This does a connect, read, and disconnect.</td>
      </tr>
      <tr>
        <td>
          writeReadOnce</td>
        <td>
          This does a connect, writeRead, and disconnect.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    End of String Support</h3>
  <p>
    asynOctet provides methods for handling end of string (message) processing. It does
    not specify policy. Device support code, interpose layers, or low level drivers
    can all handle EOS processing. An application developer must decide what policy
    will be followed for individual devices. The policy will be determined by the device,
    the device support, and the driver.</p>
  <hr />
  <div style="text-align: center">
    <h2 id="standardRegisterInterfaces">
      Standard Register Based Interfaces</h2>
  </div>
  <h3>
    Introduction</h3>
  <p>
    This section descibes interfaces for register based devices. Support is provided
    for:</p>
  <ul>
    <li>Int32 - registers appear as 32 integers</li>
    <li>UInt32Digital - registers appear a 32 bit unsigned integers and masks can be used
      to address specific bits.</li>
    <li>Float64 - registers appear as double precision floats.</li>
    <li>Int8Array - Arrays of 8 bit integers.</li>
    <li>Int16Array - Arrays of 16 bit integers.</li>
    <li>Int32Array - Arrays of 32 bit integers.</li>
    <li>Float32Array - Arrays of single precision floats.</li>
    <li>Float64Array - Arrays of double precision floats.</li>
    <li>Enum - Arrays of strings, integer values and integer severities.</li>
    <li>GenericPointer - void* pointer.</li>
  </ul>
  <p>
    Note that hardware may have registers with smaller sizes, e.g. 16 bit registers.
    The standard interfaces can still be used by setting the unused bits to 0.</p>
  <p>
    For all of these interfaces a default implementation and a synchronous inplementation
    are provided. Lets use Int32 as an example.</p>
  <ul>
    <li>asynInt32 - An interface with methods: read, write, getBounds, registerInterruptUser,
      and cancelInterruptUser.</li>
    <li>asynInt32Base - An interface used by drivers that implement asynInt32. It also
      has an implementation that:
      <ul>
        <li>registers the asynInt32 interface</li>
        <li>has default methods for read, write, and getBounds. A null method in the interface
          passed to initialize is replaced by a method implemented by asynInt32Base.</li>
        <li>implements registerInterruptUser and cancelInterruptUser. The caller should leave
          these methods null because asynInt32Base always replaces them by it's implementation.</li>
      </ul>
      Drivers that implement asynInt32 normally call asynInt32Base:initialize. It implements
      registerInterruptUser and cancelInterruptUser. If the driver provides interrupt
      support it must:
      <ul>
        <li>Call <span style="font-family: courier">pasynInt32Base-&gt;initialize</span></li>
        <li>Call <span style="font-family: courier">pasynManager-&gt;registerInterruptSource</span></li>
        <li>Interact with asynManager to call the users that have registered with asynInt32Base:registerInterruptUser.
          The driver calls users when there is new data available.</li>
      </ul>
      <span style="font-family: courier">asyn/testEpicsApp/src/int32Driver.c</span> provides
      an example of how to provide support for interrupts.</li>
    <li>asynInt32SyncIO - A synchronous interface to asynInt32</li>
  </ul>
  <h3>
    addr - What does it mean for register based interfaces?</h3>
  <p>
    Low level register based drivers are normally multi-device. The meaning of addr
    is:</p>
  <ul>
    <li>Int32 - The driver supports an array of Int32 values. addr selects an array element.
      For example a 16 channel ADC would support addr 0 through 15.</li>
    <li>Int8Array - Each addr is an array of Int8 values.</li>
    <li>Int16Array - Each addr is an array of Int16 values.</li>
    <li>Int32Array - Each addr is an array of Int32 values.</li>
    <li>Float64 - The driver supports an array of Float64 values. addr selects an array
      element.</li>
    <li>Float32Array - Each addr is an array of Float32 values.</li>
    <li>Float64Array - Each addr is an array of Float64 values.</li>
    <li>UInt32Digital - The driver supports an array of UInt32 values. addr selects an
      array element. For example a 128 bit digital I/O module appears as an array of four
      UInt32 registers.</li>
  </ul>
  <h3>
    Example Drivers</h3>
  <p>
    Two examples of drivers that might implement and use the interfaces are:</p>
  <ul>
    <li>Analog to Digital Convertor.
      <p>
        An example is a 16 channel ADC. The driver implements interfaces asynCommon and
        asynInt32. It uses interface asynInt32Base. It can call asynManager:interruptStart
        and asynManager:interruptEnd to support interrupts. It can use pasynUser-&gt;reason
        and addr to decide which callbacks to call. <span style="font-family: courier">asyn/testEpicsApp/int32Driver.c</span>
        is a soft example of how to implement a driver that implements asynInt32 and also
        asynFloat64.</p>
    </li>
    <li>Digital I/O module
      <p>
        An example is a 64 bit combination digital input and digital output module. The
        driver implements interfaces asynCommon and asynUInt32Digital. It uses interface
        asynUInt32DigitalBase. It can call asynManager:interruptStart and asynManager:interruptEnd
        to support interrupts. It can use reason, mask, and addr to decide which callbacks
        to call. <span style="font-family: courier">asyn/testEpicsApp/uint32DigitalDriver.c</span>
        is a soft example of a driver that implements asynUInt32Digital.</p>
    </li>
  </ul>
  <h3>
    asynInt32</h3>
  <p>
    asynInt32 describes the methods implemented by drivers that use integers for communicating
    with a device.</p>
  <pre>typedef void (*interruptCallbackInt32)(void *userPvt, asynUser *pasynUser, 
                                       epicsInt32 data);
typedef struct asynInt32Interrupt {
    int addr;
    asynUser *pasynUser;
    interruptCallbackInt32 callback;
    void *userPvt;
} asynInt32Interrupt;
#define asynInt32Type "asynInt32"
typedef struct asynInt32 {
    asynStatus (*write)(void *drvPvt, asynUser *pasynUser, epicsInt32 value);
    asynStatus (*read)(void *drvPvt, asynUser *pasynUser, epicsInt32 *value);
    asynStatus (*getBounds)(void *drvPvt, asynUser *pasynUser,
                           epicsInt32 *low, epicsInt32 *high);
    asynStatus (*registerInterruptUser)(void *drvPvt,asynUser *pasynUser,
                           interruptCallbackInt32 callback, void *userPvt,
                           void **registrarPvt);
    asynStatus (*cancelInterruptUser)(void *drvPvt, asynUser *pasynUser,
                    void *registrarPvt);
} asynInt32;

/* asynInt32Base does the following:
   calls  registerInterface for asynInt32.
   Implements registerInterruptUser and cancelInterruptUser
   Provides default implementations of all methods.
   registerInterruptUser and cancelInterruptUser can be called
   directly rather than via queueRequest.
*/

#define asynInt32BaseType "asynInt32Base"
typedef struct asynInt32Base {
    asynStatus (*initialize)(const char *portName,
                            asynInterface *pint32Interface);
} asynInt32Base;
epicsShareExtern asynInt32Base *pasynInt32Base;</pre>
  <table border="1">
    <caption>
      asynInt32</caption>
    <tbody>
      <tr>
        <td>
          write</td>
        <td>
          Write an integer value to the device.</td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Read an integer value from the device.</td>
      </tr>
      <tr>
        <td>
          getBounds</td>
        <td>
          Get the bounds. For example a 16 bit ADC might set low=-32768 and high = 32767.
        </td>
      </tr>
      <tr>
        <td>
          registerInterruptUser</td>
        <td>
          Registers a callback that will be called whenever new data is available. Since it
          can be called directly rather than via a queueRequest this method must not block.
        </td>
      </tr>
      <tr>
        <td>
          cancelInterruptUser</td>
        <td>
          Cancels the callback. Since it can be called directly rather than via a queueRequest
          this method must not block.</td>
      </tr>
    </tbody>
  </table>
  <p>
  </p>
  <p>
    asynInt32Base is an interface and associated code that is used by drivers that implement
    interface asynInt32. asynInt32Base provides code to handle registerInterruptUser/cancelInterruptUser.
    The driver must itself call the callbacks via calls to asynManager:interruptStart
    and asynManager:interruptEnd.</p>
  <table border="1">
    <caption>
      asynInt32Base</caption>
    <tbody>
      <tr>
        <td>
          initialize</td>
        <td>
          After a driver calls registerPort it can call:
          <pre>pasynInt32Base-&gt;initialize(...</pre>
          Any null methods in the asynInterface are replaced by default implementations.
        </td>
      </tr>
    </tbody>
  </table>
  <p>
  </p>
  <p>
    The default implementation of each method does the following:</p>
  <table border="1">
    <caption>
      asynInt32</caption>
    <tbody>
      <tr>
        <td>
          write</td>
        <td>
          Reports an error "write is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Reports an error "read is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          getBounds</td>
        <td>
          Reports an error "getBounds is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          registerInterruptUser</td>
        <td>
          registers an interrupt callback.</td>
      </tr>
      <tr>
        <td>
          cancelInterruptUser</td>
        <td>
          Cancels the callback</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynInt32SyncIO</h3>
  <p>
    asynInt32SyncIO describes a synchronous interface to asynInt32. The code that calls
    it must be willing to block.</p>
  <pre>#define asynInt32SyncIOType "asynInt32SyncIO"
typedef struct asynInt32SyncIO {
    asynStatus (*connect)(const char *port, int addr,
                          asynUser **ppasynUser, const char *drvInfo);
    asynStatus (*disconnect)(asynUser *pasynUser);
    asynStatus (*write)(asynUser *pasynUser, epicsInt32 value,double timeout);
    asynStatus (*read)(asynUser *pasynUser, epicsInt32 *pvalue,double timeout);
    asynStatus (*getBounds)(asynUser *pasynUser,
                    epicsInt32 *plow, epicsInt32 *phigh);
    asynStatus (*writeOnce)(const char *port, int addr,
                    epicsInt32 value,double timeout, const char *drvInfo);
    asynStatus (*readOnce)(const char *port, int addr,
                    epicsInt32 *pvalue,double timeout, const char *drvInfo);
    asynStatus (*getBoundsOnce)(const char *port, int addr,
                    epicsInt32 *plow, epicsInt32 *phigh,const char *drvInfo);
} asynInt32SyncIO;
epicsShareExtern asynInt32SyncIO *pasynInt32SyncIO;</pre>
  <table border="1">
    <caption>
      asynInt32SyncIO</caption>
    <tbody>
      <tr>
        <td>
          connect</td>
        <td>
          Connects to a port and address, returns a pointer to an asynUser.</td>
      </tr>
      <tr>
        <td>
          disconnect</td>
        <td>
          Disconnect. This frees all resources allocated by connect.</td>
      </tr>
      <tr>
        <td>
          write</td>
        <td>
          Calls pasynInt32-&gt;write and waits for the operation to complete or time out.
        </td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Calls pasynInt32-&gt;read and waits for the operation to complete or time out.
        </td>
      </tr>
      <tr>
        <td>
          getBounds</td>
        <td>
          Calls pasynInt32-&gt;getBounds and waits for the operation to complete or time out.
        </td>
      </tr>
      <tr>
        <td>
          writeOnce</td>
        <td>
          This does a connect, write, and disconnect.</td>
      </tr>
      <tr>
        <td>
          readOnce</td>
        <td>
          This does a connect, read, and disconnect.</td>
      </tr>
      <tr>
        <td>
          getBoundsOnce</td>
        <td>
          This does a connect, getBounds, and disconnect.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynUInt32Digital</h3>
  <p>
    asynUInt32Digital describes the methods for communicating via bits of an Int32 register.</p>
  <pre>typedef enum {
    interruptOnZeroToOne, interruptOnOneToZero, interruptOnBoth
} interruptReason;

typedef void (*interruptCallbackUInt32Digital)(void *userPvt, 
                 asynUser *pasynUser, epicsUInt32 data);
typedef struct asynUInt32DigitalInterrupt {
    epicsUInt32 mask;
    int addr;
    asynUser *pasynUser;
    interruptCallbackUInt32Digital callback;
    void *userPvt;
} asynUInt32DigitalInterrupt;
#define asynUInt32DigitalType "asynUInt32Digital"
typedef struct asynUInt32Digital {
    asynStatus (*write)(void *drvPvt, asynUser *pasynUser,
         epicsUInt32 value, epicsUInt32 mask);
    asynStatus (*read)(void *drvPvt, asynUser *pasynUser,
        epicsUInt32 *value, epicsUInt32 mask);
    asynStatus (*setInterrupt)(void *drvPvt, asynUser *pasynUser,
        epicsUInt32 mask, interruptReason reason);
    asynStatus (*clearInterrupt)(void *drvPvt, asynUser *pasynUser,
        epicsUInt32 mask);
    asynStatus (*getInterrupt)(void *drvPvt, asynUser *pasynUser,
        epicsUInt32 *mask, interruptReason reason);
    asynStatus (*registerInterruptUser)(void *drvPvt, asynUser *pasynUser,
        interruptCallbackUInt32Digital callback,void *userPvt,epicsUInt32 mask,
        void **registrarPvt);
    asynStatus (*cancelInterruptUser)(void *drvPvt, asynUser *pasynUser,
                    void *registrarPvt);
} asynUInt32Digital;

/* asynUInt32DigitalBase does the following:
   calls  registerInterface for asynUInt32Digital.
   Implements registerInterruptUser and cancelInterruptUser
   Provides default implementations of all methods.
   registerInterruptUser and cancelInterruptUser can be called
   directly rather than via queueRequest.
*/

#define asynUInt32DigitalBaseType "asynUInt32DigitalBase"
typedef struct asynUInt32DigitalBase {
    asynStatus (*initialize)(const char *portName,
                            asynInterface *pasynUInt32DigitalInterface);
} asynUInt32DigitalBase;
epicsShareExtern asynUInt32DigitalBase *pasynUInt32DigitalBase;</pre>
  <table border="1">
    <caption>
      asynUInt32Digital</caption>
    <tbody>
      <tr>
        <td>
          write</td>
        <td>
          Modify the bits specified by mask with the corresponding bits in value.</td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Read the bits specified by mask into value. The other bits of value will be set
          to 0.</td>
      </tr>
      <tr>
        <td>
          setInterrupt</td>
        <td>
          Set the bits specified by mask to interrupt for reason.</td>
      </tr>
      <tr>
        <td>
          clearInterrupt</td>
        <td>
          Clear the interrupt bits specified by mask.</td>
      </tr>
      <tr>
        <td>
          getInterrupt</td>
        <td>
          Set each bit of mask that is enabled for reason.</td>
      </tr>
      <tr>
        <td>
          registerInterruptUser</td>
        <td>
          Register a callback that will be called whenever the driver detects a change in
          any of the bits specified by mask. Since it can be called directly rather than via
          a queueRequest this method must not block.</td>
      </tr>
      <tr>
        <td>
          cancelInterruptUser</td>
        <td>
          Cancels the registered callback. Since it can be called directly rather than via
          a queueRequest this method must not block.</td>
      </tr>
    </tbody>
  </table>
  <p>
  </p>
  <p>
    asynUInt32DigitalBase is an interface and associated code that is used by drivers
    that implement interface asynUInt32Digital. asynUInt32DigitalBase provides code
    to implement registerInterruptUser and cancelInterruptUser.</p>
  <table border="1">
    <caption>
      asynUInt32DigitalBase</caption>
    <tbody>
      <tr>
        <td>
          initialize</td>
        <td>
          After a driver calls registerPort it can call:
          <pre>pasynUInt32DigitalBase-&gt;initialize(...</pre>
          Any null methods in the asynInterface are replaced by default implementations.
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    The default implementation of each method does the following:</p>
  <table border="1">
    <caption>
      asynUInt32Digital</caption>
    <tbody>
      <tr>
        <td>
          write</td>
        <td>
          Reports an error "write is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Reports an error "read is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          setInterrupt</td>
        <td>
          Reports an error "setInterrupt is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          clearInterrupt</td>
        <td>
          Reports an error "clearInterrupt is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          getInterrupt</td>
        <td>
          Reports an error "getInterrupt is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          registerInterruptUser</td>
        <td>
          registers the interrupt user. The low level driver must call the registered callbacks
          via calls to asynManager:interruptStart and asynManager:interruptEnd.</td>
      </tr>
      <tr>
        <td>
          cancelInterruptUser</td>
        <td>
          Cancels the callback</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynUInt32DigitalSyncIO</h3>
  <p>
    asynUInt32DigitalSyncIO describes a synchronous interrace to asynUInt32Digital.
    The code that calls it must be willing to block.</p>
  <pre>#define asynUInt32DigitalSyncIOType "asynUInt32DigitalSyncIO"
typedef struct asynUInt32DigitalSyncIO {
    asynStatus (*connect)(const char *port, int addr,
                       asynUser **ppasynUser, const char *drvInfo);
    asynStatus (*disconnect)(asynUser *pasynUser);
    asynStatus (*write)(asynUser *pasynUser,
                       epicsUInt32 value,epicsUInt32 mask,double timeout);
    asynStatus (*read)(asynUser *pasynUser,
                       epicsUInt32 *pvalue,epicsUInt32 mask,double timeout);
    asynStatus (*setInterrupt)(asynUser *pasynUser,
                       epicsUInt32 mask, interruptReason reason,double timeout);
    asynStatus (*clearInterrupt)(asynUser *pasynUser,
                       epicsUInt32 mask,double timeout);
    asynStatus (*getInterrupt)(asynUser *pasynUser,
                       epicsUInt32 *mask, interruptReason reason,double timeout);
    asynStatus (*writeOnce)(const char *port, int addr,
                       epicsUInt32 value,epicsUInt32 mask,double timeout,
                       const char *drvInfo);
    asynStatus (*readOnce)(const char *port, int addr,
                       epicsUInt32 *pvalue,epicsUInt32 mask,double timeout,
                       const char *drvInfo);
    asynStatus (*setInterruptOnce)(const char *port, int addr,
                       epicsUInt32 mask, interruptReason reason,double timeout,
                       const char *drvInfo);
    asynStatus (*clearInterruptOnce)(const char *port, int addr,
                       epicsUInt32 mask,double timeout,const char *drvInfo);
    asynStatus (*getInterruptOnce)(const char *port, int addr,
                       epicsUInt32 *mask, interruptReason reason,double timeout,
                       const char *drvInfo);
} asynUInt32DigitalSyncIO;
epicsShareExtern asynUInt32DigitalSyncIO *pasynUInt32DigitalSyncIO;</pre>
  <table border="1">
    <caption>
      asynUInt32DigitalSyncIO</caption>
    <tbody>
      <tr>
        <td>
          connect</td>
        <td>
          Connects to a port and address, returns a pointer to an asynUser structure.</td>
      </tr>
      <tr>
        <td>
          disconnect</td>
        <td>
          Disconnect. This frees all resources allocated by connect.</td>
      </tr>
      <tr>
        <td>
          write</td>
        <td>
          Calls pasynUInt32Digital-&gt;write and waits for the operation to complete or time
          out.</td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Calls pasynUInt32Digital-&gt;read and waits for the operation to complete or time
          out.</td>
      </tr>
      <tr>
        <td>
          setInterrupt</td>
        <td>
          Calls pasynUInt32Digital-&gt;setInterrupt and waits for the operation to complete
          or time out.</td>
      </tr>
      <tr>
        <td>
          clearInterrupt</td>
        <td>
          Calls pasynUInt32Digital-&gt;clearInterrupt and waits for the operation to complete
          or time out.</td>
      </tr>
      <tr>
        <td>
          getInterrupt</td>
        <td>
          Calls pasynUInt32Digital-&gt;getInterrupt and waits for the operation to complete
          or time out.</td>
      </tr>
      <tr>
        <td>
          writeOnce,...,getInterruptOnce</td>
        <td>
          Does a connect, (write,...,getInterrupt), and disconnect.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynFloat64</h3>
  <p>
    asynFloat64 describes the methods for communicating via IEEE double precision float
    values.</p>
  <pre>typedef void (*interruptCallbackFloat64)(void *userPvt, asynUser *pasynUser,
            epicsFloat64 data);
typedef struct asynFloat64Interrupt {
    asynUser *pasynUser;
    int addr;
    interruptCallbackFloat64 callback;
    void *userPvt;
} asynFloat64Interrupt;
#define asynFloat64Type "asynFloat64"
typedef struct asynFloat64 {
    asynStatus (*write)(void *drvPvt, asynUser *pasynUser, epicsFloat64 value);
    asynStatus (*read)(void *drvPvt, asynUser *pasynUser, epicsFloat64 *value);
    asynStatus (*registerInterruptUser)(void *drvPvt, asynUser *pasynUser,
        interruptCallbackFloat64 callback, void *userPvt,void **registrarPvt);
    asynStatus (*cancelInterruptUser)(void *drvPvt, asynUser *pasynUser,
                    void *registrarPvt);
} asynFloat64;

/* asynFloat64Base does the following:
   calls  registerInterface for asynFloat64.
   Implements registerInterruptUser and cancelInterruptUser
   Provides default implementations of all methods.
   registerInterruptUser and cancelInterruptUser can be called
   directly rather than via queueRequest.
*/

#define asynFloat64BaseType "asynFloat64Base"
typedef struct asynFloat64Base {
    asynStatus (*initialize)(const char *portName,
                            asynInterface *pasynFloat64Interface);
} asynFloat64Base;
epicsShareExtern asynFloat64Base *pasynFloat64Base;</pre>
  <table border="1">
    <caption>
      asynFloat64</caption>
    <tbody>
      <tr>
        <td>
          write</td>
        <td>
          Write a value.</td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Read a value.</td>
      </tr>
      <tr>
        <td>
          registerInterruptUser</td>
        <td>
          Register a callback that is called whenever new data is available. Since it can
          be called directly rather than via a queueRequest this method must not block.</td>
      </tr>
      <tr>
        <td>
          cancelInterruptUser</td>
        <td>
          Cancel the callback. Since it can be called directly rather than via a queueRequest
          this method must not block.</td>
      </tr>
    </tbody>
  </table>
  <table border="1">
    <caption>
      asynFloat64Base</caption>
    <tbody>
      <tr>
        <td>
          initialize</td>
        <td>
          After a driver calls registerPort it can call:
          <pre>pasynFloat64Base-&gt;initialize(...</pre>
          Any null methods in the asynInterface are replaced by default implementations.
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    The default implementation of each method does the following:</p>
  <table border="1">
    <caption>
      asynFloat64</caption>
    <tbody>
      <tr>
        <td>
          write</td>
        <td>
          Reports an error "write is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Reports an error "read is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          registerInterruptUser</td>
        <td>
          registers the interrupt user. The low level driver must call the registered callbacks
          via calls to asynManager:interruptStart and asynManager:interruptEnd.</td>
      </tr>
      <tr>
        <td>
          cancelInterruptUser</td>
        <td>
          Cancels the callback</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynFloat64SyncIO</h3>
  <p>
    asynFloat64SyncIO describes a synchronous interrace to asynFloat64. The code that
    calls it must be willing to block.</p>
  <pre>#define asynFloat64SyncIOType "asynFloat64SyncIO"
typedef struct asynFloat64SyncIO {
    asynStatus (*connect)(const char *port, int addr,
                       asynUser **ppasynUser, const char *drvInfo);
    asynStatus (*disconnect)(asynUser *pasynUser);
    asynStatus (*write)(asynUser *pasynUser,epicsFloat64 value,double timeout);
    asynStatus (*read)(asynUser *pasynUser,epicsFloat64 *pvalue,double timeout);
    asynStatus (*writeOnce)(const char *port, int addr,
                       epicsFloat64 value,double timeout,const char *drvInfo);
    asynStatus (*readOnce)(const char *port, int addr,
                       epicsFloat64 *pvalue,double timeout,const char *drvInfo);
} asynFloat64SyncIO;
epicsShareExtern asynFloat64SyncIO *pasynFloat64SyncIO;</pre>
  <table border="1">
    <caption>
      asynFloat64SyncIO</caption>
    <tbody>
      <tr>
        <td>
          connect</td>
        <td>
          Connects to a port and address, returns a pointer to an asynUser structure.</td>
      </tr>
      <tr>
        <td>
          disconnect</td>
        <td>
          Disconnect. This frees all resources allocated by connect.</td>
      </tr>
      <tr>
        <td>
          write</td>
        <td>
          Calls pasynFloat64-&gt;write and waits for the operation to complete or time out.
        </td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Calls pasynFloat64-&gt;read and waits for the operation to complete or time out.
        </td>
      </tr>
      <tr>
        <td>
          writeOnce</td>
        <td>
          This does a connect, write, and disconnect.</td>
      </tr>
      <tr>
        <td>
          readOnce</td>
        <td>
          This does a connect, read, and disconnect.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynXXXArray (where XXX is Int8, Int16, Int32, Float32 or Float64)</h3>
  <p>
    asynXXXArray describes the methods for communicating via 8, 16, or 32-bit integers,
    or 32 or 64-bit IEEE float values.</p>
  <pre>typedef void (*interruptCallbackXXXArray)(
              void *userPvt, asynUser *pasynUser,
              epicsXXX *data, size_t nelements);
typedef struct asynXXXArrayInterrupt {
    asynUser *pasynUser;
    int addr;
    interruptCallbackXXXArray callback;
    void *userPvt;
} asynXXXArrayInterrupt;
#define asynXXXArrayType "asynXXXArray"
typedef struct asynXXXArray {
    asynStatus (*write)(void *drvPvt, asynUser *pasynUser,
                       epicsXXX *value, size_t nelements);
    asynStatus (*read)(void *drvPvt, asynUser *pasynUser,
                       epicsXXX *value, size_t nelements, size_t *nIn);
    asynStatus (*registerInterruptUser)(void *drvPvt, asynUser *pasynUser,
         interruptCallbackXXXArray callback,
         void *userPvt,void **registrarPvt);
    asynStatus (*cancelInterruptUser)(void *drvPvt, asynUser *pasynUser,
                    void *registrarPvt);
} asynXXXArray;

/* asynXXXArrayBase does the following:
   calls  registerInterface for asynXXXArray.
   Implements registerInterruptUser and cancelInterruptUser
   Provides default implementations of all methods.
   registerInterruptUser and cancelInterruptUser can be called
   directly rather than via queueRequest.
*/

#define asynXXXArrayBaseType "asynXXXArrayBase"
typedef struct asynXXXArrayBase {
    asynStatus (*initialize)(const char *portName,
                            asynInterface *pXXXArrayInterface);
} asynXXXArrayBase;
epicsShareExtern asynXXXArrayBase *pasynXXXArrayBase;</pre>
  <table border="1">
    <caption>
      asynXXXArray</caption>
    <tbody>
      <tr>
        <td>
          write</td>
        <td>
          Write an array of values.</td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Read an array of values.</td>
      </tr>
      <tr>
        <td>
          registerInterruptUser</td>
        <td>
          Register a callback that is called whenever new data is available.</td>
      </tr>
      <tr>
        <td>
          cancelInterruptUser</td>
        <td>
          Cancel the callback</td>
      </tr>
    </tbody>
  </table>
  <p>
  </p>
  <table border="1">
    <caption>
      asynXXXArrayBase</caption>
    <tbody>
      <tr>
        <td>
          initialize</td>
        <td>
          After a driver calls registerPort it can call:
          <pre>pasynXXXArrayBase-&gt;initialize(...</pre>
          Any null methods in the asynInterface are replaced by default implementations.
        </td>
      </tr>
    </tbody>
  </table>
  <hr />
  <p>
  </p>
  <p>
    The default implementation of each method does the following:</p>
  <table border="1">
    <caption>
      asynXXXArrayBase</caption>
    <tbody>
      <tr>
        <td>
          write</td>
        <td>
          Reports an error "write is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Reports an error "read is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          registerInterruptUser</td>
        <td>
          Registers an interrupt callback.</td>
      </tr>
      <tr>
        <td>
          cancelInterruptUser</td>
        <td>
          Cancels the callback</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynXXXArraySyncIO</h3>
  <p>
    asynXXXArraySyncIO describes a synchronous interface to asynXXXArray. The code that
    calls it must be willing to block.</p>
  <pre>#define asynXXXArraySyncIOType "asynXXXArraySyncIO"
typedef struct asynXXXArraySyncIO {
    asynStatus (*connect)(const char *port, int addr,
                          asynUser **ppasynUser, const char *drvInfo);
    asynStatus (*disconnect)(asynUser *pasynUser);
    asynStatus (*write)(asynUser *pasynUser, epicsXXX *pvalue,size_t nelem,double timeout);
    asynStatus (*read)(asynUser *pasynUser, epicsXXX *pvalue,size_t nelem,size_t *nIn,double timeout);
    asynStatus (*writeOnce)(const char *port, int addr,
                    epicsXXX *pvalue,size_t nelem,double timeout, const char *drvInfo);
    asynStatus (*readOnce)(const char *port, int addr,
                    epicsXXX *pvalue,size_t nelem,size_t *nIn,double timeout, const char *drvInfo);
} asynXXXArraySyncIO;
epicsShareExtern asynXXXArraySyncIO *pasynXXXArraySyncIO;</pre>
  <table border="1">
    <caption>
      asynXXXArraySyncIO</caption>
    <tbody>
      <tr>
        <td>
          connect</td>
        <td>
          Connects to a port and address, returns a pointer to an asynUser.</td>
      </tr>
      <tr>
        <td>
          disconnect</td>
        <td>
          Disconnect. This frees all resources allocated by connect.</td>
      </tr>
      <tr>
        <td>
          write</td>
        <td>
          Calls pasynXXXArray-&gt;write and waits for the operation to complete or time out.
        </td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Calls pasynXXXArray-&gt;read and waits for the operation to complete or time out.
        </td>
      </tr>
      <tr>
        <td>
          writeOnce</td>
        <td>
          This does a connect, write, and disconnect.</td>
      </tr>
      <tr>
        <td>
          readOnce</td>
        <td>
          This does a connect, read, and disconnect.</td>
      </tr>
      <tr>
        <td>
          getBoundsOnce</td>
        <td>
          This does a connect, getBounds, and disconnect.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynEnum</h3>
  <p>
    asynEnum describes the methods implemented by drivers to define the enum strings,
    values, and severities for a device.
  </p>
  <p>
    This interface is typically used by drivers to set the enum strings and values for
    EPICS bi, bo, mbbi, and mbbo records. The strings[] are used to define the ZNAM
    and ONAM fields in bi and bo records, and the ZRST, ONST, ...FFST fields in mbbi
    and mbbo records. The integer values[] are ignored for bi and bo records, since
    these always have the values of 0 and 1 corresponding to the ZNAM and ONAM states.
    The integer values[] are used to assign the ZRVL, ONVL, ... FFVL fields for mbbi
    and mbbo records. The integer severities[] are used to set the ZSV and OSV fields
    of bi and bo records, and the ZRSV, ONSV, ... FFSV fields of mbbi and mbbo records.
    The nelements parameter in the write() and read() functions is used by the client
    to specify the dimensions of the strings[], values[], and severities[] arrays. The
    driver must not access these arrays beyond element nElements-1. The nIn parameter
    in the read() is used by the driver to set the actual number of value enum strings,
    values, and severities. There is no size limitation on nElements imposed by the
    asynEnum interface. However, the bi and bo records limit nElements to 2, and mbbi
    and mbbo records limit nElements to 16. There is no size limitation on the strings
    imposed by the asynEnum interface. However, the string fields in the bi, bo, mbbo,
    and mbbi records are currently limited to 26 characters.</p>
  <p>
    Clients must ensure that the char* pointers passed in strings[] in the read() function
    are either set to NULL or have been allocated by malloc(). The driver read() function
    must first call free() if a string pointer contains a non-NULL value. The driver
    must then allocate the strings using malloc() before copying the current enum string
    values to them.</p>
  <pre>typedef void (*interruptCallbackEnum)
              void *userPvt, asynUser *pasynUser,
              char *strings[], int values[], int severities[], size_t nelements);
typedef struct asynEnumInterrupt {
    asynUser *pasynUser;
    int addr;
    interruptCallbackEnum callback;
    void *userPvt;
} asynEnumInterrupt;
#define asynEnumType "asynEnum"
typedef struct asynEnum {
    asynStatus (*write)(void *drvPvt, asynUser *pasynUser,
                       char *strings[], int values[], int severities[], size_t nelements);
    asynStatus (*read)(void *drvPvt, asynUser *pasynUser,
                       char *strings[], int values[], int severities[], size_t nelements, size_t *nIn);
    asynStatus (*registerInterruptUser)(void *drvPvt, asynUser *pasynUser,
             interruptCallbackEnum callback, void *userPvt,
             void **registrarPvt);
    asynStatus (*cancelInterruptUser)(void *drvPvt, asynUser *pasynUser,
             void *registrarPvt);
} asynEnum;

/* asynEnumBase does the following:
   calls registerInterface for asynEnum.
   Implements registerInterruptUser and cancelInterruptUser
   Provides default implementations of all methods.
   registerInterruptUser and cancelInterruptUser can be called
   directly rather than via queueRequest.
*/

#define asynEnumBaseType "asynEnumBase"
typedef struct asynEnumBase {
    asynStatus (*initialize)(const char *portName,
                            asynInterface *pEnumInterface);
} asynEnumBase;
epicsShareExtern asynEnumBase *pasynEnumBase;
</pre>
  <table border="1">
    <caption>
      asynEnum</caption>
    <tbody>
      <tr>
        <td>
          write</td>
        <td>
          Writes the enum strings, enum values and enum severities to the driver.</td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Reads the enum strings, enum values and enum severities to the driver.</td>
      </tr>
      <tr>
        <td>
          registerInterruptUser</td>
        <td>
          Registers a callback that will be called whenever there are new enum strings, values
          and severities. Since it can be called directly rather than via a queueRequest this
          method must not block. </td>
      </tr>
      <tr>
        <td>
          cancelInterruptUser</td>
        <td>
          Cancels the callback. Since it can be called directly rather than via a queueRequest
          this method must not block.</td>
      </tr>
    </tbody>
  </table>
  <p>
  </p>
  <p>
    asynEnumBase is an interface and associated code that is used by drivers that implement
    interface asynEnum. asynEnumBase provides code to handle registerInterruptUser/cancelInterruptUser.
    The driver must itself call the callbacks via calls to asynManager:interruptStart
    and asynManager:interruptEnd.</p>
  <table border="1">
    <caption>
      asynEnumBase</caption>
    <tbody>
      <tr>
        <td>
          initialize</td>
        <td>
          After a driver calls registerPort it can call:
          <pre>pasynEnumBase-&gt;initialize(...</pre>
          Any null methods in the asynInterface are replaced by default implementations.
        </td>
      </tr>
    </tbody>
  </table>
  <p>
  </p>
  <p>
    The default implementation of each method does the following:</p>
  <table border="1">
    <caption>
      asynEnum</caption>
    <tbody>
      <tr>
        <td>
          write</td>
        <td>
          Reports an error "write is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Reports an error "read is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          registerInterruptUser</td>
        <td>
          registers an interrupt callback.</td>
      </tr>
      <tr>
        <td>
          cancelInterruptUser</td>
        <td>
          Cancels the callback</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynEnumSyncIO</h3>
  <p>
    asynEnumSyncIO describes a synchronous interface to asynEnum. The code that calls
    it must be willing to block.</p>
  <pre>#define asynEnumSyncIOType "asynEnumSyncIO"
typedef struct asynEnumSyncIO {
    asynStatus (*connect)(const char *port, int addr, 
                          asynUser **ppasynUser, const char *drvInfo);
    asynStatus (*disconnect)(asynUser *pasynUser);
    asynStatus (*write)(asynUser *pasynUser, char *strings[], int values[], int severities[], 
                       size_t nElements, double timeout);
    asynStatus (*read)(asynUser *pasynUser, char *string[], int values[],  int severities[], 
                       size_t nElements, size_t *nIn, double timeout);
    asynStatus (*writeOnce)(const char *port, int addr, char *strings[], int values[],  int severities[], 
                           size_t nElements, double timeout, const char *drvInfo);
    asynStatus (*readOnce)(const char *port, int addr, char *strings[], int values[],  int severities[], 
                           size_t nElements, size_t *nIn, double timeout, const char *drvInfo);
} asynEnumSyncIO;
epicsShareExtern asynEnumSyncIO *pasynEnumSyncIO;
</pre>
  <table border="1">
    <caption>
      asynEnumSyncIO</caption>
    <tbody>
      <tr>
        <td>
          connect</td>
        <td>
          Connects to a port and address, returns a pointer to an asynUser.</td>
      </tr>
      <tr>
        <td>
          disconnect</td>
        <td>
          Disconnect. This frees all resources allocated by connect.</td>
      </tr>
      <tr>
        <td>
          write</td>
        <td>
          Calls pasynEnum-&gt;write and waits for the operation to complete or time out.
        </td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Calls pasynEnum-&gt;read and waits for the operation to complete or time out.
        </td>
      </tr>
      <tr>
        <td>
          writeOnce</td>
        <td>
          This does a connect, write, and disconnect.</td>
      </tr>
      <tr>
        <td>
          readOnce</td>
        <td>
          This does a connect, read, and disconnect.</td>
      </tr>
      <tr>
        <td>
          getBoundsOnce</td>
        <td>
          This does a connect, getBounds, and disconnect.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynGenericPointer</h3>
  <p>
    asynGenericPointer describes the methods for communicating via void* pointers. asyn
    clients and port drivers must agree on the type of object that is being pointed
    to!</p>
  <pre>typedef void (*interruptCallbackGenericPointer)(void *userPvt, asynUser *pasynUser,
            void *pdata);
typedef struct asynGenericPointerInterrupt {
    asynUser *pasynUser;
    int addr;
    interruptCallbackGenericPointer callback;
    void *userPvt;
} asynGenericPointerInterrupt;
#define asynGenericPointerType "asynGenericPointer"
typedef struct asynGenericPointer {
    asynStatus (*write)(void *drvPvt, asynUser *pasynUser, void *pvalue);
    asynStatus (*read)(void *drvPvt, asynUser *pasynUser, void *pvalue);
    asynStatus (*registerInterruptUser)(void *drvPvt, asynUser *pasynUser,
        interruptCallbackGenericPointer callback, void *userPvt,void **registrarPvt);
    asynStatus (*cancelInterruptUser)(void *drvPvt, asynUser *pasynUser,
                    void *registrarPvt);
} asynGenericPointer;

/* asynGenericPointerBase does the following:
   calls  registerInterface for asynGenericPointer.
   Implements registerInterruptUser and cancelInterruptUser
   Provides default implementations of all methods.
   registerInterruptUser and cancelInterruptUser can be called
   directly rather than via queueRequest.
*/

#define asynGenericPointerBaseType "asynGenericPointerBase"
typedef struct asynGenericPointerBase {
    asynStatus (*initialize)(const char *portName,
                            asynInterface *pasynGenericPointerInterface);
} asynGenericPointerBase;
epicsShareExtern asynGenericPointerBase *pasynGenericPointerBase;</pre>
  <table border="1">
    <caption>
      asynGenericPointer</caption>
    <tbody>
      <tr>
        <td>
          write</td>
        <td>
          Write a value.</td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Read a value.</td>
      </tr>
      <tr>
        <td>
          registerInterruptUser</td>
        <td>
          Register a callback that is called whenever new data is available. Since it can
          be called directly rather than via a queueRequest this method must not block.</td>
      </tr>
      <tr>
        <td>
          cancelInterruptUser</td>
        <td>
          Cancel the callback. Since it can be called directly rather than via a queueRequest
          this method must not block.</td>
      </tr>
    </tbody>
  </table>
  <p>
  </p>
  <table border="1">
    <caption>
      asynGenericPointerBase</caption>
    <tbody>
      <tr>
        <td>
          initialize</td>
        <td>
          After a driver calls registerPort it can call:
          <pre>pasynGenericPointerBase-&gt;initialize(...</pre>
          Any null methods in the asynInterface are replaced by default implementations.
        </td>
      </tr>
    </tbody>
  </table>
  <p>
    The default implementation of each method does the following:</p>
  <table border="1">
    <caption>
      asynGenericPointer</caption>
    <tbody>
      <tr>
        <td>
          write</td>
        <td>
          Reports an error "write is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Reports an error "read is not supported" and returns asynError</td>
      </tr>
      <tr>
        <td>
          registerInterruptUser</td>
        <td>
          registers the interrupt user. The low level driver must call the registered callbacks
          via calls to asynManager:interruptStart and asynManager:interruptEnd.</td>
      </tr>
      <tr>
        <td>
          cancelInterruptUser</td>
        <td>
          Cancels the callback</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynGenericPointerSyncIO</h3>
  <p>
    asynGenericPointerSyncIO describes a synchronous interrace to asynGenericPointer.
    The code that calls it must be willing to block.</p>
  <pre>#define asynGenericPointerSyncIOType "asynGenericPointerSyncIO"
typedef struct asynGenericPointerSyncIO {
    asynStatus (*connect)(const char *port, int addr,
                       asynUser **ppasynUser, const char *drvInfo);
    asynStatus (*disconnect)(asynUser *pasynUser);
    asynStatus (*write)(asynUser *pasynUser,void *pvalue,double timeout);
    asynStatus (*read)(asynUser *pasynUser,void *pvalue,double timeout);
    asynStatus (*writeRead)(asynUser *pasynUser,void *pwrite_buffer,void *pread_buffer,double timeout);
    asynStatus (*writeOnce)(const char *port, int addr,
                       void *pvalue,double timeout,const char *drvInfo);
    asynStatus (*readOnce)(const char *port, int addr,
                       void *pvalue,double timeout,const char *drvInfo);
    asynStatus (*writeReadOnce)(const char *port, int addr,
                       void *pwrite_buffer,void *pread_buffer,double timeout,const char *drvInfo);
} asynGenericPointerSyncIO;
epicsShareExtern asynGenericPointerSyncIO *pasynGenericPointerSyncIO;</pre>
  <table border="1">
    <caption>
      asynGenericPointerSyncIO</caption>
    <tbody>
      <tr>
        <td>
          connect</td>
        <td>
          Connects to a port and address, returns a pointer to an asynUser structure.</td>
      </tr>
      <tr>
        <td>
          disconnect</td>
        <td>
          Disconnect. This frees all resources allocated by connect.</td>
      </tr>
      <tr>
        <td>
          write</td>
        <td>
          Calls pasynGenericPointer-&gt;write and waits for the operation to complete or time
          out.</td>
      </tr>
      <tr>
        <td>
          read</td>
        <td>
          Calls pasynGenericPointer-&gt;read and waits for the operation to complete or time
          out.</td>
      </tr>
      <tr>
        <td>
          writeRead</td>
        <td>
          Calls pasynGenericPointer-&gt;write, then pasynGenericPointer-&gt;read. Waits for
          the operations to complete or time out.</td>
      </tr>
      <tr>
        <td>
          writeOnce</td>
        <td>
          This does a connect, write, and disconnect.</td>
      </tr>
      <tr>
        <td>
          readOnce</td>
        <td>
          This does a connect, read, and disconnect.</td>
      </tr>
      <tr>
        <td>
          writeReadOnce</td>
        <td>
          This does a connect, writeRead, and disconnect.</td>
      </tr>
    </tbody>
  </table>
  <div style="text-align: center">
    <h2 id="asynStandardInterfacesBase">
      asynStandardInterfacesBase</h2>
  </div>
  <p>
    asynStandardInterfacesBase is an interface designed as a convenience to minimize
    the amount of code that must be written in the initialization routine of a port
    driver that uses the standard asyn message-based or register-based interfaces that
    are described above. Without asynStandardInterfacesBase a port driver needs to call
    asynRegisterInterface(), and possibly asynRegisterInterruptSource() for each interface
    that it supports, and handle any errors that may occur in these calls. It also needs
    to explicitly include several fields in its drvPvt structure for each interface.
    asynStandardInterfacesBase provides an interface that allows port drivers to include
    a single structure in its drvPvt structure, and define values in this structure.
    It then calls a single function to register all interfaces that it supports, and
    to register itself as an interrupt source on one or more of those interfaces. This
    can reduce the number of lines of code in the driver initialization routine by a
    factor of four or more.</p>
  <h2>
    asynStandardInterfaces structure</h2>
  <p>
    The following is the definition of the asynStandardInterfaces structure. Drivers
    will normally have a structure of this type contained in their drvPvt structure.
    If this structure is initialized to all zeros when drvPvt is created, then all that
    is necessary is to fill in the addresses of each of each of the supported interfaces
    (in that interface's .pinterface field), and to set the CanInterrupt flag to 1 for
    those interfaces that are interrupt sources.</p>
  <pre>typedef struct asynStandardInterfaces {
    asynInterface common;

    asynInterface drvUser;

    asynInterface option;

    asynInterface octet;
    int octetProcessEosIn;
    int octetProcessEosOut;
    int octetInterruptProcess;
    int octetCanInterrupt;
    void *octetInterruptPvt;

    asynInterface uInt32Digital;
    int uInt32DigitalCanInterrupt;
    void *uInt32DigitalInterruptPvt;

    asynInterface int32;
    int int32CanInterrupt;
    void *int32InterruptPvt;

    asynInterface float64;
    int float64CanInterrupt;
    void *float64InterruptPvt;

    asynInterface int8Array;
    int int8ArrayCanInterrupt;
    void *int8ArrayInterruptPvt;

    asynInterface int16Array;
    int int16ArrayCanInterrupt;
    void *int16ArrayInterruptPvt;

    asynInterface int32Array;
    int int32ArrayCanInterrupt;
    void *int32ArrayInterruptPvt;

    asynInterface float32Array;
    int float32ArrayCanInterrupt;
    void *float32ArrayInterruptPvt;

    asynInterface float64Array;
    int float64ArrayCanInterrupt;
    void *float64ArrayInterruptPvt;

    asynInterface genericPointer;
    int genericPointerCanInterrupt;
    void *genericPointerInterruptPvt;

    asynInterface Enum;
    int enumCanInterrupt;
    void *enumInterruptPvt;

} asynStandardInterfaces;</pre>
  <h2>
    asynStandardInterfacesBase interface</h2>
  <p>
    The following is the definition of the asynStandardInterfacesBase interface.</p>
  <pre>typedef struct asynStandardInterfacesBase {
    asynStatus (*initialize)(const char *portName, asynStandardInterfaces *pInterfaces, 
                             asynUser *pasynUser, void *pPvt);
} asynStandardInterfacesBase;

epicsShareExtern asynStandardInterfacesBase *pasynStandardInterfacesBase;</pre>
  <p>
    asynStandardInterfacesBase has a single method, initialize(), which calls registerInterface
    or Base-&gt;initialize for each interface which has a non-NULL value in its .pinterface
    field. It also calls registerInterruptSource for interfaces that are defined and
    that have the CanInterrupt flag set to 1. The pasynUser argument to the initialize()
    method is used only to provide a place for the method to return an error message
    (in pasynUser-&gt;errorMessage) so the invoking routine may reuse or free the asynUser
    structure when the method has returned.</p>
  <p>
    The following is an example of the code required in a port driver that uses the
    asynStandardInterfacesBase interface.</p>
  <pre>#include &lt;asynStandardInterfaces.h&gt;
...
typedef struct drvADPvt {
...
    /* The asyn interfaces this driver implements */
    asynStandardInterfaces asynStdInterfaces;

    /* asynUser connected to ourselves for asynTrace */
    asynUser *pasynUser;
...
} drvADPvt;
...
/* Structures with function pointers for each of the asyn interfaces */
static asynCommon ifaceCommon = {
    report,
    connect,
    disconnect
};

static asynInt32 ifaceInt32 = {
    writeInt32,
    readInt32,
    getBounds
};

static asynFloat64 ifaceFloat64 = {
    writeFloat64,
    readFloat64
};

static asynOctet ifaceOctet = {
    writeOctet,
    NULL,
    readOctet,
};

static asynDrvUser ifaceDrvUser = {
    drvUserCreate,
    drvUserGetType,
    drvUserDestroy
};

static asynGenericPointer ifaceGenericPointer = {
    writeADImage,
    readADImage
};
...

int simDetectorConfig(const char *portName, int maxSizeX, int maxSizeY, int dataType)

{
    drvADPvt *pPvt;
    int status = asynSuccess;
    char *functionName = "simDetectorConfig";
    asynStandardInterfaces *pInterfaces;

    pPvt = callocMustSucceed(1, sizeof(*pPvt), functionName);
    pPvt-&gt;portName = epicsStrDup(portName);

    status = pasynManager-&gt;registerPort(portName,
                                        ASYN_MULTIDEVICE | ASYN_CANBLOCK,
                                        1,  /*  autoconnect */
                                        0,  /* medium priority */
                                        0); /* default stack size */
    if (status != asynSuccess) {
        printf("%s ERROR: Can't register port\n", functionName);
        return(asynError);
    }

    /* Create asynUser for debugging */
    pPvt-&gt;pasynUser = pasynManager-&gt;createAsynUser(0, 0);

    pInterfaces = &amp;pPvt-&gt;asynStdInterfaces;
    
    /* Initialize interface pointers */
    pInterfaces-&gt;common.pinterface         = (void *)&amp;ifaceCommon;
    pInterfaces-&gt;drvUser.pinterface        = (void *)&amp;ifaceDrvUser;
    pInterfaces-&gt;octet.pinterface          = (void *)&amp;ifaceOctet;
    pInterfaces-&gt;int32.pinterface          = (void *)&amp;ifaceInt32;
    pInterfaces-&gt;float64.pinterface        = (void *)&amp;ifaceFloat64;
    pInterfaces-&gt;genericPointer.pinterface = (void *)&amp;ifaceGenericPointer;

    /* Define which interfaces can generate interrupts */
    pInterfaces-&gt;octetCanInterrupt          = 1;
    pInterfaces-&gt;int32CanInterrupt          = 1;
    pInterfaces-&gt;float64CanInterrupt        = 1;
    pInterfaces-&gt;genericPointerCanInterrupt = 1;

    status = pasynStandardInterfacesBase-&gt;initialize(portName, pInterfaces,
                                                     pPvt-&gt;pasynUser, pPvt);
    if (status != asynSuccess) {
        printf("%s ERROR: Can't register interfaces: %s.\n",
               functionName, pPvt-&gt;pasynUser-&gt;errorMessage);
        return(asynError);
    }
...
}</pre>
  <div style="text-align: center">
    <h2 id="interposeInterfaces">
      Standard Interpose Interfaces</h2>
  </div>
  <h2>
    asynInterposeEos</h2>
  <p>
    This can be used to simulate EOS processing for asynOctet if the port driver doesn't
    provide EOS support. If an EOS is specified it looks for the eos on each read. It
    is started by the shell command:</p>
  <pre>    asynInterposeEosConfig port addr processEosIn processEosOut</pre>
  <p>
    where</p>
  <ul>
    <li>port is the name of the port.</li>
    <li>addr is the address</li>
    <li>processEosIn (0,1) means (do not, do) implement eosIn commands.</li>
    <li>processEosOut (0,1) means (do not, do) implement eosOut commands.</li>
  </ul>
  <p>
    This command should appear immediately after the command that initializes a port
    Some drivers provide configuration options to call this automatically.</p>
  <h2>
    asynInterposeFlush</h2>
  <p>
    This can be used to simulate flush processing for asynOctet if the port driver doesn't
    provide support for flush. It just reads and discards characters until no more characters
    arive before timeout seconds have occured. It is started by the shell command:</p>
  <pre>    asynInterposeFlushConfig port addr timeout</pre>
  <p>
    where</p>
  <ul>
    <li>port is the name of the port.</li>
    <li>addr is the address</li>
    <li>timeout is the time to wait for more characters</li>
  </ul>
  <p>
    this command should appear immediately after the command that initializes a port</p>
  <hr />
  <div style="text-align: center">
    <h2 id="genericEpicsSupport">
      Generic Device Support for EPICS records</h2>
  </div>
  <p>
    Generic device support is provided for standard EPICS records. This support should
    be usable for a large class of low level register based drivers. For complicated
    devices other support is required. This release provides the following:</p>
  <ul>
    <li>devAsynInt32 - support for drivers that implement interface asynInt32</li>
    <li>devAsynInt32TimeSeries - waveform record support for drivers that implement callbacks
      on interface asynInt32</li>
    <li>devAsynInt8Array - support for drivers that implement interface asynInt8Array</li>
    <li>devAsynInt16Array - support for drivers that implement interface asynInt16Array</li>
    <li>devAsynInt32Array - support for drivers that implement interface asynInt32Array</li>
    <li>devAsynUInt32Digital - support for drivers that implement interface asynUInt32Digital</li>
    <li>devAsynFloat64 - support for drivers that implement interface asynFloat64</li>
    <li>devAsynFloat64TimeSeries - waveform record support for drivers that implement
      callbacks on interface asynFloat64</li>
    <li>devAsynFloat32Array - support for drivers that implement interface asynFloat32Array</li>
    <li>devAsynFloat64Array - support for drivers that implement interface asynFloat64Array</li>
    <li>devAsynOctet - support for drivers that implement interface asynOctet</li>
    <li>devEpics - This is just a single file devEpics.dbd that includes the dbd files
      for the above support.</li>
    <li>asynEpicsUtils.c - This provides utility functions. parseLink(), parseLinkMask()
      and parseLinkFree() parse record the record INP and OUT links described below. asynStatusToEpicsAlarm()
      converts asynStatus enum values to EPICS record STAT and SEVR values setting record
      alarms.</li>
  </ul>
  <p>
    The support uses the following conventions for DTYP and INP. OUT fields are the
    same as INP.</p>
  <pre>    field(DTYP,"asynXXX")
    field(INP,"@asyn(portName,addr,timeout)drvParams")
     or
    field(INP,"@asynMask(portName,addr,mask,timeout)drvParams")</pre>
  <pre>where</pre>
  <ul>
    <li>XXX - The name of the type of interface supported.</li>
    <li>portName - The name of the port.</li>
    <li>addr - The address. If addr is not specified the default is 0.</li>
    <li>mask - This is for devAsynUInt32Digital. It is also used by devAsynInt32 to specify
      the number of bits of the hardware device for drivers that do not support getBounds().</li>
    <li>timeout - The timeout value for asynUser.timeout. If not specified the default
      is 1.0.</li>
    <li>drvParams - This is passed to the low level driver via the asynDrvUser interface.
      It is optional.</li>
  </ul>
  <p>
    For example:</p>
  <pre>    field(DTYP,"asynInt32")
    field(INP,"@asyn(portA,0,.1)thisIsForDriver")</pre>
  <h2>
    asynManager interrupts and EPICS device support</h2>
  <p>
    All of the device support files can call registerInterruptUser for input records.
    The callback is used in one of two ways:</p>
  <ul>
    <li>Input Records except Average and TimeSeries
      <p>
        It is used to support SCAN = "I/O Intr".</p>
    </li>
    <li>Input records that are averaged, i.e. asynInt32Average or asynFloat64Average.
      <p>
        These records are normally scanned periodically. The registerInterruptUser callback
        is used to calculate an average value between record processes. If the record is
        processed before new data have arrived (numAverage==0) the record is set to UDF/INVALID,
        UDF is set to TRUE, and the value is left unchanged.</p>
    </li>
    <li>Input records that are waveform time series, i.e. asynInt32TimeSeries or asynFloat64TimeSeries.
      <p>
        These records are normally scanned periodically. The registerInterruptUser callback
        is used to append values to the time series.</p>
    </li>
  </ul>
  <h2>
    Initial values of output records</h2>
  <p>
    The device support for output records on register based interfaces (bo, mbbo, ao,
    longout) does an initial read() of the value from the driver in init_record. If
    this read() returns asynSuccess then the record value is set to the value returned
    from read(). If read() returns anything other than asynSuccess then the record value
    is not modified. This mechanism supports "bumpless reboots" where the initial value
    of output records will match the current value of the hardware when the IOC starts.
    Drivers should only return asynSuccess from the read() function if the value is
    known to be valid. Note that this value read from the device will replace the value
    in the database when iocInit begins. However, the value read from the device may
    in turn be replaced by any value from save/restore, because the auto restore happens
    later in iocInit.</p>
  <p>
    Beginning in R4-30 devAsynOctet was changed to also support the initial readback
    for stringout and waveform output records. The initial readback is only done if
    the record in the database contains the following line:<br />
    <code>info(asyn:INITIAL_READBACK, "1")</code><br />
    .</p>
  <h2>
    Enum values for bi, bo, mbbi, and mbbo records</h2>
  <p>
    Beginning in asyn R4-19 support was added for asyn port drivers to control the values
    of the enum strings, enum values and enum severities in bi, bo, mbbi, and mbbo records.
    This is implemented in the asynInt32 and asynUInt32Digital device support as follows:</p>
  <ul>
    <li>In the device support init_record function the device support attempts to find
      the asynEnum interface in the driver. If it is found then the driver calls pasynEnumSyncIO-&gt;read()
      to read the current values of the enums from the driver. If the read() returns asynSuccess
      then the enum fields are set to the values returned by the driver. If the asynEnum
      interface is not supported, or if read() returns anything except asynSuccess then
      the enum fields are not modified.</li>
    <li>Device support registers for callbacks on the asynEnum interface. Drivers can
      make callbacks to dynamically change the values of enums at run-time. For example,
      changing the gain of an ADC might change the allowed choices for the speed, etc.
      Device support calls db_post_events(pr, &amp;pr-&gt;val, DBE_PROPERTY) when the
      enum fields change. This notifies clients that the enum values have changed. Older
      clients like medm and edm will not change the enum widgets until the window is closed
      and reopened, but newer clients like CSS should dynamically change the enum widgets.</li>
  </ul>
  <h2>
    Callback updates for output records</h2>
  <p>
    Beginning in asyn R4-26 support was added for updating output records from driver
    interrupt callbacks. This feature allows output records to reflect changes in the
    underlying hardware that are caused by manual front-panel operation, changes caused
    by another output record, etc.
  </p>
  <p>
    By default output records do not update when a driver does interrupt callbacks.
    However, if the following info tag is added for a record in the database file then
    callbacks will be enabled and the output record will be updated whenever the driver
    does a callback for that value.<br />
    <code>info(asyn:READBACK, "1")</code><br />
    If the value of the info tag is 0 or if the info tag is not present then updates
    of output records on interrupt callbacks are disabled.
  </p>
  <h2>
    Buffering of driver callbacks</h2>
  <p>
    It is possible for the time between driver callbacks to be less than the time for
    record processing. asyn device support provides a ring-buffer (FIFO) mechanism to
    buffer values so that the record will process all callback values from a short burst
    of callbacks. For all records except stringin, stringout, and waveform records the
    default buffer size is 10 values. For stringin, stringout, and waveform records
    the default buffer size is 0, i.e. there is no buffering. For all record types the
    size of the buffer can be controlled by the following info tag for a record in the
    database file:
    <br />
    <code>info(asyn:FIFO, "20")</code><br />
    In this example the buffer size was set to 20. Ring buffer support was added in
    asyn R4-10 for all records except stringin, stringout, and waveform. Waveform record
    support for numeric arrays was added in asyn R4-25. asynOctet support for stringin,
    stringout, and waveform records was added in asyn R4-26.
  </p>
  <h2>
    Time stamps
  </h2>
  <p>
    Beginning in asyn R4-20 support was added for asyn port drivers to set the TIME
    field of input records. This is done by setting the TSE field of the record to "-2"
    and setting the desired value into the timestamp field of the pasynUser structure
    referred to in the device read method or interrupt callback.
  </p>
  <p>
    Beginning in asyn R4-22 the timestamp support functions were added to asynManager
    to update, get and set the most recent timestamp for the port in asynManager. Support
    was also added for user-supplied timestamp source functions. Timestamp support was
    also added to asynPortDriver for the base-class read functions and callback functions.
  </p>
  <h2>
    asynInt32 device support</h2>
  <p>
    The following support is available:</p>
  <pre>device(ai,INST_IO,asynAiInt32,"asynInt32")
device(ai,INST_IO,asynAiInt32Average,"asynInt32Average")
device(ao,INST_IO,asynAoInt32,"asynInt32")
device(bi,INST_IO,asynBiInt32,"asynInt32")
device(bo,INST_IO,asynBoInt32,"asynInt32")
device(mbbi,INST_IO,asynMbbiInt32,"asynInt32")
device(mbbo,INST_IO,asynMbboInt32,"asynInt32")
device(longin,INST_IO,asynLiInt32,"asynInt32")
device(longout,INST_IO,asynLoInt32,"asynInt32")</pre>
  <p>
    devAsynInt32.c provides EPICS device support for drivers that implement interface
    asynInt32.</p>
  <p>
    For ai and ao records either of the following specifications for the INP and OUT
    fields can be used:</p>
  <pre>    
    field(INP,"@asyn(portName,addr,timeout) drvParams")
     or
    field(INP,"@asynMask(portName,addr,nbits,timeout) drvParams")</pre>
  <p>
    The asynMask format allows device support to work with drivers that cannot return
    meaningful values from getBounds() because they do not know the range of the device.
    This is true, for example, of Modbus ADCs. The nbits parameter is defined as follows:</p>
  <pre>nbits &gt; 0  Device is unipolar with a range from 0 to 2^nbits-1.  Values will be masked to the specified number of bits.
<br />
nbits &lt; 0  Device is bipolar with a range from -2^(abs(nbits)-1) to 2^((abs(nbits)-1)-1
           Values read with the asynInt32 interface will be sign extended
           using the sign bit (e.g. bit abs(nbits)-1 starting at bit 0).</pre>
  <ul>
    <li>aiRecord
      <p>
        A value is given to rval. Linear conversions are supported if the driver implements
        getBounds, or if nbits is specified as explained above.</p>
      <ul>
        <li>asynInt32 - SCAN "I/O Intr" is supported. If the record is "I/O Intr" scanned
          then when the registerInterruptUser callback is called, it saves the value and calls
          scanIoRequest. When the record is processed the saved value is put into rval. If
          the record is not "I/O Intr" scanned then each time the record is processed, a new
          value is read via a call to pasynInt32-&gt;read.</li>
        <li>asynInt32Average - The registerInterruptUser callback adds the new value to a
          sum and also increments the number of samples. When the record is processed the
          average is computed and the sum and number of samples is set to zero.</li>
      </ul>
    </li>
    <li>aoRecord
      <p>
        rval is written. Linear conversions are supported if the driver properly implements
        getBounds, or if nbits is specified as explained above.</p>
    </li>
    <li>longinRecord
      <p>
        A value is given to val. Each time the record is processed a new value is read.
        SCAN "I/O Intr" is supported similar to aiRecord.</p>
    </li>
    <li>longoutRecord
      <p>
        val is written.</p>
    </li>
    <li>biRecord
      <p>
        A value is given to rval. The mask field in the record is not used. Each time the
        record is processed a new value is read. SCAN "I/O Intr" is supported similar to
        aiRecord.</p>
    </li>
    <li>boRecord
      <p>
        rval is written. The mask field in the record is not used.</p>
    </li>
    <li>mbbiRecord
      <p>
        A value is given to rval. mask is computed from nobt and shft. Each time the record
        is processed a new value is read. SCAN "I/O Intr" is supported similar to aiRecord.</p>
    </li>
    <li>mbboRecord
      <p>
        rval is written. mask is computed from nobt and shft.</p>
    </li>
  </ul>
  <p>
    Analog Input Example Records</p>
  <pre>   record(ai,"aiInt32") {
        field(SCAN,"I/O Intr")
        field(DTYP,"asynInt32")
        field(INP,"@asyn($(port),$(addr))")
        field(EGUF,"10.0")
        field(EGUL,"-10.0")
        field(PREC,"3")
   }
   # This record is for a 12-bit bipolar ADC for a driver that does not
   # support getBounds()
   record(ai,"aiInt32") {
        field(SCAN,"I/O Intr")
        field(DTYP,"asynInt32")
        field(INP,"@asynMask($(port),$(addr),-12)")
        field(EGUF,"10.0")
        field(EGUL,"-10.0")
        field(PREC,"3")
   }
   record(ai,"aiInt32Average") {
        field(SCAN,"10 second")
        field(DTYP,"asynInt32Average")
        field(INP,"@asyn($(port),$(addr))")
        field(EGUF,"10.0")
        field(EGUL,"-10.0")
        field(PREC,"3")
   }</pre>
  <p>
    Analog Output Example Record</p>
  <pre>   record(ao,"aoInt32") {
        field(DTYP,"asynInt32")
        field(OUT,"@asyn($(port),$(addr))")
        field(EGUF,"10.0")
        field(EGUL,"-10.0")
        field(PREC,"3")
   }</pre>
  <p>
    Long Input Example Records</p>
  <pre>   record(longin,"liInt32") {
        field(SCAN,"I/O Intr")
        field(DTYP,"asynInt32")
        field(INP,"@asyn($(port),$(addr))")
   }</pre>
  <p>
    Long Output Example Record</p>
  <pre>   record(longout,"loInt32") {
        field(DTYP,"asynInt32")
        field(OUT,"@asyn($(port),$(addr))")
   }</pre>
  <p>
    Multibit Binary Input Example Records</p>
  <pre>   record(mbbi,"mbbiInt32") {
        field(SCAN,"I/O Intr")
        field(DTYP,"asynInt32")
        field(INP,"@asyn($(port),$(addr))")
        field(NOBT,"2")
        field(SHFT,"2")
        field(ZRST,"zeroVal")
        field(ONST,"oneVal")
        field(TWST,"twoVal")
        field(THST,"threeVal")
   }</pre>
  <p>
    Multibit Binary Output Example Record</p>
  <pre>   record(mbbo,"mbboInt32") {
        field(DTYP,"asynInt32")
        field(OUT,"@asyn($(port),$(addr))")
        field(NOBT,"2")
        field(SHFT,"16")
        field(ZRST,"zeroVal")
        field(ONST,"oneVal")
        field(TWST,"twoVal")
        field(THST,"threeVal")
   }</pre>
  <h2>
    asynIntXXXArray device support (XXX=8, 16 or 32)</h2>
  <p>
    The following support is available:</p>
  <pre>device(waveform,INST_IO,asynIntXXXArrayWfIn,"asynIntXXXArrayIn")
device(waveform,INST_IO,asynIntXXXArrayWfOut,"asynIntXXXArrayOut")</pre>
  <p>
    devAsynIntXXXArray.c provides EPICS device support for drivers that implement interface
    asynIntXXXArray. It has support for both reading and writing a waveform. SCAN "I/O
    Intr" is supported similar to the aiRecord in devAsynInt32 device support.</p>
  <h2>
    asynXXXTimeSeries device support (XXX=Int32 or Float64)</h2>
  <p>
    The following support is available:</p>
  <pre>device(waveform,INST_IO,asynInt32TimeSeries,"asynInt32TimeSeries")
device(waveform,INST_IO,asynFloat64TimeSeries,"asynFloat64TimSeries")</pre>
  <p>
    devAsynXXXTimeSeries.c provides EPICS device support to collect a time series of
    values into a waveform record. It works with drivers that implement callbacks on
    the asynInt32 or asynFloat64 interfaces. This permits more rapid and efficient acquisition
    of values from a driver than can be obtained using record support and database operations.
    The waveform record RARM field is used to control acquisition as follows:</p>
  <ul>
    <li>RARM=1 Erase and start acquisition, i.e. clear the waveform record to 0, set NORD=0,
      BUSY=1 and enable callbacks.</li>
    <li>RARM=2 Stop acquisition, set BUSY=0.</li>
    <li>RARM=3 Start acquisition (set BUSY=1) without clearing the waveform or setting
      NORD=0.</li>
  </ul>
  <h2>
    devAsynUInt32Digital</h2>
  <p>
    The following support is available:</p>
  <pre>device(bi,INST_IO,asynBiUInt32Digital,"asynUInt32Digital")
device(bo,INST_IO,asynBoUInt32Digital,"asynUInt32Digital")
device(longin,INST_IO,asynLiUInt32Digital,"asynUInt32Digital")
device(longout,INST_IO,asynLoUInt32Digital,"asynUInt32Digital")
device(mbbi,INST_IO,asynMbbiUInt32Digital,"asynUInt32Digital")
device(mbbo,INST_IO,asynMbboUInt32Digital,"asynUInt32Digital")
device(mbbiDirect,INST_IO,asynMbbiDirectUInt32Digital,"asynUInt32Digital")
device(mbboDirect,INST_IO,asynMbboDirectUInt32Digital,"asynUInt32Digital")</pre>
  <p>
    devAsynUInt32Digital.c provides EPICS device support for drivers that implement
    interface asynUInt32Digital. The INP or OUT field must define asynMask. The mask
    specified in the argument to asynMask is used in the calls to asynUInt32Digital
    methods. In addition it is used to set the mask fields in bi and bo records and
    the mask and shft fields in mbbi, mbbo, mbbiDirect, and mbboDirect records.</p>
  <ul>
    <li>biRecord
      <p>
        A value is given to rval. asynInt32 - SCAN "I/O Intr" is supported. If the record
        is "I/O Intr" scanned then when the registerInterruptUser callback is called, it
        saves the value and calls scanIoRequest. When the record is processed the saved
        value is put into rval. If the record is not "I/O Intr" scanned then each time the
        record is processed, a new value is read via a call to pasynUInt32Digital-&gt;read.</p>
    </li>
  </ul>
  <ul>
    <li>boRecord
      <p>
        rval is written.</p>
    </li>
    <li>longinRecord
      <p>
        A value is given to val. Each time the record is processed a new value is read.
        SCAN "I/O Intr" is supported similar to aiRecord.</p>
    </li>
  </ul>
  <ul>
    <li>longoutRecord
      <p>
        val is written.</p>
    </li>
    <li>mbbiRecord
      <p>
        A value is given to rval. Each time the record is processed a new value is read.
        SCAN "I/O Intr" is supported similar to aiRecord.</p>
    </li>
    <li>mbboRecord
      <p>
        rval is written.</p>
    </li>
    <li>mbbiDirectRecord
      <p>
        A value is given to rval. Each time the record is processed a new value is read.
        SCAN "I/O Intr" is supported similar to aiRecord.</p>
    </li>
    <li>mbboDirectRecord
      <p>
        rval is written.</p>
    </li>
  </ul>
  <p>
    Binary Input Example Record</p>
  <pre>record(bi,"biUInt32Bit0") {
    field(SCAN,"I/O Intr")
    field(DTYP,"asynUInt32Digital")
    field(INP,"@asynMask( $(port) , 0, 0x1 , 1.0) ")
    field(ZNAM,"zero")
    field(ONAM,"one")
}</pre>
  <p>
    Binary Output Example Record</p>
  <pre>record(bo,"boUInt32Bit2") {
    field(DTYP,"asynUInt32Digital")
    field(OUT,"@asynMask( $(port) , 0, 0x4 , 1.0) ")
    field(ZNAM,"zero")
    field(ONAM,"one")
}</pre>
  <p>
    Long Input Example Record</p>
  <pre>record(longin,"liUInt32") {
    field(SCAN,"I/O Intr")
    field(DTYP,"asynUInt32Digital")
    field(INP,"@asynMask( $(port) , 0, 0xffffffff , 1.0) ")
}</pre>
  <p>
    Long Output Example Record</p>
  <pre>record(longout,"loUInt32") {
    field(DTYP,"asynUInt32Digital")
    field(INP,"@asynMask( $(port) , 0, 0xffffffff , 1.0) ")
}</pre>
  <p>
    Multibit Input Example Record</p>
  <pre>record(mbbi,"mbbiUInt32") {
    field(SCAN,"I/O Intr")
    field(DTYP,"asynUInt32Digital")
    field(INP,"@asynMask( digital , 0, 0x3 , 1.0) ")
    field(ZRST,"zero")
    field(ONST,"one")
    field(TWST,"two")
    field(THST,"three")
    field(ZRVL,"0x0")
    field(ONVL,"0x1")
    field(TWVL,"0x2")
    field(THVL,"0x3")
}</pre>
  <p>
    Multibit Output Example Record</p>
  <pre>record(mbbo,"mbboUInt32") {
    field(DTYP,"asynUInt32Digital")
    field(OUT,"@asynMask( digital , 0, 0x7 , 1.0) ")
    field(ZRST,"zero")
    field(ONST,"one")
    field(TWST,"two")
    field(THST,"three")
    field(FRST,"four")
    field(FVST,"five")
    field(SXST,"six")
    field(SVST,"seven")
    field(ZRVL,"0x0")
    field(ONVL,"0x1")
    field(TWVL,"0x2")
    field(THVL,"0x3")
    field(FRVL,"0x4")
    field(FVVL,"0x5")
    field(SXVL,"0x6")
    field(SVVL,"0x7")
}</pre>
  <h2>
    devAsynFloat64 device support</h2>
  <p>
    The following support is available:</p>
  <pre>device(ai,INST_IO,asynAiFloat64,"asynFloat64")
device(ai,INST_IO,asynAiFloat64Average,"asynFloat64Average")
device(ao,INST_IO,asynAoFloat64,"asynFloat64")</pre>
  <p>
    devAsynFloat64.c provides EPICS device support for drivers that implement interface
    asynFloat64.</p>
  <ul>
    <li>aiRecord
      <p>
        A value is given to val.</p>
      <ul>
        <li>asynFloat64 - SCAN "I/O Intr" is supported. If the record is "I/O Intr" scanned
          then when the registerInterruptUser callback is called, it saves the value and calls
          scanIoRequest. When the record is processed the saved value is put into val. If
          the record is not "I/O Intr" scanned then each time the record is processed, a new
          value is read via a call to pasynFloat64-&gt;read.</li>
        <li>asynFloat64Average - The registerInterruptUser callback adds the new value to
          a sum and also increments the number of samples. When the record is processed the
          average is computed and the sum and number of samples is set to zero.</li>
      </ul>
    </li>
    <li>aoRecord
      <p>
        val is written.</p>
    </li>
  </ul>
  <h2>
    asynFloatXXXArray device support (where XXX=32 or 64)</h2>
  <p>
    The following support is available:</p>
  <pre>device(waveform,INST_IO,asynFloatXXXArrayWfIn,"asynFloatXXXArrayIn")
device(waveform,INST_IO,asynFloatXXXArrayWfOut,"asynFloatXXXArrayOut")</pre>
  <p>
    devAsynFloatXXXArray.c provides EPICS device support for drivers that implement
    interface asynFloatXXXArray. It has support for both reading and writing a waveform.
    SCAN "I/O Intr" is supported similar to the aiRecord in devAsynInt32 device support.</p>
  <h2>
    octet device support</h2>
  <p>
    The following support is available:</p>
  <pre>device(stringin,INST_IO,asynSiOctetCmdResponse,"asynOctetCmdResponse")
device(stringin,INST_IO,asynSiOctetWriteRead,"asynOctetWriteRead")
device(stringin,INST_IO,asynSiOctetRead,"asynOctetRead")
device(stringout,INST_IO,asynSoOctetWrite,"asynOctetWrite")
device(waveform,INST_IO,asynWfOctetCmdResponse,"asynOctetCmdResponse")
device(waveform,INST_IO,asynWfOctetWriteRead,"asynOctetWriteRead")
device(waveform,INST_IO,asynWfOctetRead,"asynOctetRead")
device(waveform,INST_IO,asynWfOctetWrite,"asynOctetWrite")
device(waveform,INST_IO,asynWfOctetWriteBinary,"asynOctetWriteBinary")</pre>
  <p>
    Support for drivers that implement interface asynOctet. The support is for stringin/stringout
    and waveform records. The waveform support is similar to the string support. The
    waveform records must define FTVL to be CHAR or UCHAR, i.e. it must be an array
    of octets. The waveform provides the following features not provided by the string
    support:</p>
  <ul>
    <li>unlimited size - string records hold a maximum of 40 characters.</li>
    <li>both string and binary data. Beginning in R4-30 asynWfWriteOctet calls strnlen()
      to determine the length of the string, and passes this length to the driver, i.e.
      does not include the trailing nil. This is consistent with the behavior of the devAsynOctet
      for the stringout record. The asynOctetWriteBinary support added in R4-30 always
      uses NORD as the length that it passes to the driver, and does not call strnlen().</li>
  </ul>
  <p>
    Four types of support are provided:</p>
  <ul>
    <li>CmdResponse The INP field is of the form:
      <pre>    field(INP,"@asyn(portName,addr,timeout) cmd")</pre>
      During record initialization, cmd is converted by dbTranslateEscape. The resultant
      string is the command to send to the device. When the record is processed the command
      is sent to the device and the response read into the record.</li>
    <li>WriteRead The INP field is of the form:
      <pre>    field(INP,"@asyn(portName,addr,timeout) pvname")</pre>
      pvname must refer to a field in a record in the same IOC. During record initialization
      the pvname is located. When the record is processed dbGet is called to read the
      current value of pvname. This value is sent to the device. A read is then issued
      and the result stored in the record. For asynSiOctetWriteRead, the value obtained
      from pvname is passed through dbTranslateEscape before sending it. For asynWfOctetWriteRead
      it is not passed through dbTranslateEscape.</li>
    <li>Write The INP(OUT) field is of the form:
      <pre>    field(INP,"@asyn(portName,addr,timeout) drvUser")</pre>
      drvUser is information that is passed to the portDriver if it implements interface
      asynDrvUser. When the record is processed the value stored in the record is sent
      to the device.</li>
    <li>Read The INP field is of the form:
      <pre>    field(INP,"@asyn(portName,addr,timeout) drvUser")</pre>
      drvUser is information that is passed to the portDriver if it implements interface
      asynDrvUser. When the record is processed a read request is made. The result is
      read into the record.</li>
  </ul>
  <h2>
    Record alarms</h2>
  <p>
    The generic EPICS device support sets the record alarm status and severity when
    errors occur. Beginning in R4-30 the alarmStatus and alarmSeverity fields were added
    to the asynUser structure. Drivers can use these fields to explicitly control the
    record STAT and SEVERITY fields, independent of the function return status or the
    asynUser.auxStatus field.</p>
  <p>
    If the pasynUser-&gt;alarmStatus or pasynUser-&gt;alarmSeverity field is zero then
    the record alarm status or severity is controlled by the function return status
    or the asynUser.auxStatus field. For records that do not use callbacks (not SCAN=I/O
    Intr or asynXXXAverage or asynXXXTimeSeries) the status information is passed from
    the driver to device support in the asynStatus return of the interface function
    call, e.g. pasynInt32-&gt;read(). The driver maps the asynStatus values to the record
    STAT and SEVR values using the function pasynEpicsUtils-&gt;asynUserToEpicsAlarm().
    The SEVR field is currently always set to INVALID_ALARM for any error. The STAT
    field is set using following mapping:</p>
  <pre>  asynSuccess = epicsAlarmNone
  asynTimeout = epicsAlarmTimeout
  asynOverflow = epicsAlarmHWLimit
  asynError = epicsAlarmRead or epicsAlarmWrite
  asynDisconnected = epicsAlarmComm
  asynDisabled = epicsAlarmDisable
  </pre>
  <p>
    For records that use callbacks, the status information is passed from the driver
    to device support using the pasynUser-&gt;auxStatus field in the pasynUser that
    is passed in the callback. This feature was added in asyn R4-19. Prior to that release
    it was not possible for drivers to control the alarm state of records that used
    callbacks. Drivers should set pasynUser-&gt;auxStatus to asynSuccess for normal
    operation and to another value to indicate a problem. The same mapping described
    above is used to control the values of STAT and SEVR. If the pasynUser-&gt;alarmStatus
    or pasynUser-&gt;alarmSeverity fields are non-zero then these values are used to
    set the record STAT and SEVR fields, regardless of the value of asynUser.auxStatus.
  </p>
  <hr />
  <div style="text-align: center">
    <h2 id="asynRecord">
      asynRecord: Generic EPICS Record Support</h2>
  </div>
  <p>
    A special record type asynRecord is provided. Details are described in <a href="asynRecord.html">
      asynRecord</a>. This section provides a brief description of how to use it.</p>
  <p>
  </p>
  <p>
    Each IOC can load one or more instances of asynRecord. An example is:</p>
  <pre>cd $(ASYN)
dbLoadRecords("db/asynRecord.db","P=asyn,R=Test,PORT=L0,ADDR=15,IMAX=0,OMAX=0")</pre>
  <p>
    The example creates a record with name "asynTest" (formed from the concatenation
    of the P and R macros) that will connect to port "L0" and addr 15. After the ioc
    is started, it is possible to change PORT and/or ADDR. Thus, a single record can
    be used to access all asyn devices connected to the IOC. Multiple records are only
    needed if one or more devices need a dedicated record.</p>
  <p>
    An medm display is available for accessing an asynRecord. It is started as follows:</p>
  <pre>cd &lt;asyn&gt;/medm
medm -x -macro "P=asyn,R=Test" asynRecord.adl</pre>
  <p>
    The following medm display appears.</p>
  <div style="text-align: center">
    <p>
      <img alt="asynRecord.png" src="./asynRecord.png" /></p>
  </div>
  <div style="text-align: center">
    <hr />
    <h2 id="Example">
      Example</h2>
  </div>
  <p>
    The following reads from a device via octet messages:</p>
  <pre>#include &lt;asynDriver.h&gt;
...
#define BUFFER_SIZE 80
typedef struct myData {
    epicsEventId done;
    asynOctet    *pasynOctet;
    void         *drvPvt;
    char         buffer[BUFFER_SIZE];
}myData;

static void queueCallback(asynUser *pasynUser) {
    myData     *pmydata = (myData *)pasynUser-&gt;userPvt;
    asynOctet  *pasynOctet = pmydata-&gt;pasynOctet;
    void       *drvPvt = pmydata-&gt;drvPvt;
    asynStatus status;
    int        writeBytes,readBytes;
    int        eomReason;

    asynPrint(pasynUser,ASYN_TRACE_FLOW,"queueCallback entered\n");
    status = pasynOctet-&gt;write(drvPvt,pasynUser,pmydata-&gt;buffer,
              strlen(pmydata-&gt;buffer),&amp;writeBytes);
    if(status!=asynSuccess) {
        asynPrint(pasynUser,ASYN_TRACE_ERROR,
            "queueCallback write failed %s\n",pasynUser-&gt;errorMessage);
    } else {
        asynPrintIO(pasynUser,ASYN_TRACEIO_DEVICE,
            pmydata-&gt;buffer,strlen(pmydata-&gt;buffer),
            "queueCallback write sent %d bytes\n",writeBytes);
    }
    status = pasynOctet-&gt;read(drvPvt,pasynUser,pmydata-&gt;buffer,
         BUFFER_SIZE,&amp;readBytes,&amp;eomReason);
    if(status!=asynSuccess) {
        asynPrint(pasynUser,ASYN_TRACE_ERROR,
            "queueCallback read failed %s\n",pasynUser-&gt;errorMessage);
    } else {
        asynPrintIO(pasynUser,ASYN_TRACEIO_DEVICE,
            pmydata-&gt;buffer,BUFFER_SIZE,
            "queueCallback read returned: retlen %d eomReason 0x%x data %s\n",
            readBytes,eomReason,pmydata-&gt;buffer);
    }
    epicsEventSignal(pmydata-&gt;done);
}

static void asynExample(const char *port,int addr,const char *message)
{
    myData        *pmyData;
    asynUser      *pasynUser;
    asynStatus    status;
    asynInterface *pasynInterface;

    pmyData = (myData *)pasynManager-&gt;memMalloc(sizeof(myData));
    memset(pmyData,0,sizeof(myData));
    strcpy(pmyData-&gt;buffer,message);
    pasynUser = pasynManager-&gt;createAsynUser(queueCallback,0);
    pasynUser-&gt;userPvt = pmyData;
    status = pasynManager-&gt;connectDevice(pasynUser,port,addr);
    if(status!=asynSuccess) {
        printf("can't connect to serialPort1 %s\n",pasynUser-&gt;errorMessage);
        exit(1);
    }
    pasynInterface = pasynManager-&gt;findInterface(
        pasynUser,asynOctetType,1);
    if(!pasynInterface) {
        printf("%s driver not supported\n",asynOctetType);
        exit(-1);
    }
    pmyData-&gt;pasynOctet = (asynOctet *)pasynInterface-&gt;pinterface;
    pmyData-&gt;drvPvt = pasynInterface-&gt;drvPvt;
    pmyData-&gt;done = epicsEventCreate(epicsEventEmpty);
    status = pasynManager-&gt;queueRequest(pasynUser,asynQueuePriorityLow, 0.0);
    if(status) {
        asynPrint(pasynUser,ASYN_TRACE_ERROR,
            "queueRequest failed %s\n",pasynUser-&gt;errorMessage);
    }
    epicsEventWait(pmyData-&gt;done);
    status = pasynManager-&gt;freeAsynUser(pasynUser);
    if(status) {
        asynPrint(pasynUser,ASYN_TRACE_ERROR,
            "freeAsynUser failed %s\n",pasynUser-&gt;errorMessage);
    }
    epicsEventDestroy(pmyData-&gt;done);
    pasynManager-&gt;memFree(pasynUser-&gt;userPvt,sizeof(myData));
}</pre>
  <p>
    The flow of control is as follows:</p>
  <ol>
    <li>A port driver calls registerPort. This step is not shown in the above example.</li>
    <li>asynExample allocates myData and an asynUser.</li>
    <li>asynExample connects to a device and to the asynOctet interface for the port driver.</li>
    <li>When it is ready to communicate with the driver it calls queueRequest.</li>
    <li>queueCallback is called. It calls the port driver's write and read methods.</li>
  </ol>
  <hr />
  <div style="text-align: center">
    <h2 id="Test">
      Test Application</h2>
  </div>
  <p>
    The asynDriver distribution includes code to test asynDriver. It is also an example
    of how to interface to asynManager. The example resides in &lt;top&gt;/testApp and
    contains the following components:</p>
  <pre>Db/
   test.db
   testBlock.db
adl/
   test.adl
src/
   devTestBlock.dbd
   echoDriver.c
   addrChangeDriver.c
   devTestBlock.c
   interposeInterface.c</pre>
  <p>
    echoDriver is a port driver that echos messages it receives. It implements asynCommon
    and asynOctet. When asynOctet:write is called it saves the message. When asynOctet:read
    is called, the saved message is returned and the message is flushed. echoDriverInit
    has an argument that determines if it acts like a multiDevice or a single device
    port driver.</p>
  <p>
    An instance of echoDriver is started via the iocsh command:</p>
  <pre>echoDriverInit(portName,delay,noAutoConnect,multiDevice)</pre>
  <p>
    where</p>
  <ul>
    <li>portName - the port name for this instance.</li>
    <li>delay - The time to delay after a read or write. If delay is 0 then echoDriver
      registers as a synchronous port driver, i.e. bit ASYN_CANBLOCK of attributes is
      not set. If delay&gt;0 then ASYN_CANBLOCK is set.</li>
    <li>noAutoConnect - Determines initial setting for port.</li>
    <li>multiDevice - If true then it supports two devices with addresses 0 and 1. If
      false it does not set ASYN_MULTIDEVICE, i.e. it only supports a single device.</li>
  </ul>
  <p>
    addrChangeDriver is a multidevice driver that is an asynUser of another port driver.
    In the example application it connects to echoDriver. An example where this technique
    might be used is a port driver for mult-drop serial that connects to a standard
    serial port.</p>
  <p>
    An instance of addrChangeDriver is started via the iocsh commandL:</p>
  <pre>addrChangeDriverInit(portName,lowerPort,addr)</pre>
  <p>
    where</p>
  <ul>
    <li>portName - the port name for this instance.</li>
    <li>lowerPort - the port to which addrChangeDriver connects</li>
    <li>addr - The address to which addrChangeDriver connects</li>
  </ul>
  <p>
    devTestBlock is device support that tests blockProcessCallback. It has device support
    for stringin records. The INP field has the syntax:</p>
  <pre>    field(INP,"@asyn(port,addr,timeout) pvname)</pre>
  <p>
    where:</p>
  <ul>
    <li>asyn(port,addr,timeout) is same as for devEpics support.</li>
    <li>pvname - The name of a record in the same ioc.</li>
  </ul>
  <p>
    When the stringin record is processed the following occurs.</p>
  <ul>
    <li>When process is called and PACT is :
      <ul>
        <li>TRUE - then it just returns to record support.</li>
        <li>FALSE - It does what follows.</li>
      </ul>
    </li>
    <li>When processing starts the state is stateIdle.</li>
    <li>blockProcessCallback is called.</li>
    <li>callbackRequestDelayed is called (.1 second delay). The callback calls queueRequest.</li>
    <li>When processCallback is called it does the following:
      <ul>
        <li>calls unblockProcessCallback</li>
        <li>If state is stateIdle
          <ul>
            <li>Calls dbGet to get a string value from pvname</li>
            <li>calls pasynOctet-&gt;write to send the string</li>
            <li>sets state to stateWrite</li>
            <li>Calls blockProcessCallback</li>
            <li>callbackRequestDelayed is called The callback calls queueRequest.</li>
            <li>completes. processCallback will be called again</li>
          </ul>
        </li>
        <li>If state is stateWrite
          <ul>
            <li>calls pasynOctet-&gt;read and puts the value in VAL.</li>
            <li>Sets state = stateIdle</li>
            <li>requests the the record be processed. This time PACT will be TRUE</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
  <p>
    test.db is a template containing three records: a calc record, which forward links
    to a stringout record which forward links to a stringin record. The stringOut record
    attaches to the device support supplied by asynOctetWriteRead.c. When the calcRecord
    is processed the following happens:</p>
  <ul>
    <li>The calcRecord acts as a counter that overflows when the count reaches 10. After
      counting to forward links ti the stringIn record.</li>
    <li>The string in record gets the current value of the counter converted to s character
      string and forward links to the stringOut record.</li>
    <li>The stringOut record gets the value from the stringIn record an calls queueRequest.
      The record is left with PACT true.</li>
    <li>The processCallback calls pasynOctet-&gt;write passing the value obtained from
      the stringIn record. The then does does a pasynOctet-&gt;read. When this completes
      it asks for the record to complete processing.</li>
    <li>The stringOut record completes processing.
      <p>
      </p>
    </li>
  </ul>
  <p>
    testBlock.db is a template similar to test.db except that it attached to device
    support testBlock instead of asynOctetWriteRead.</p>
  <p>
    Executing "medm -x test.adl" produces the display:</p>
  <div style="text-align: center">
    <p>
      <img alt="asynTest.png" src="asynTest.png" /></p>
  </div>
  <p>
    It assumes that an ioc has been started via:</p>
  <pre>cd &lt;top&gt;/iocBoot/ioctest
../../bin/solaris-sparc/test st.cmd</pre>
  <p>
    This starts two versions of echoDriver as port "A" and "B". port A acts as single
    device port. port B acts as a multiDevice port that has two devices. For each of
    the three possible devices, the st.cmd file starts up two sets of records from test.db
    The st.cmd file also loads a set of records from asynTest.db for port A and for
    port B and for each of the two devices attached to port B. It also loads a set of
    records from asynRecord.db. It starts one version of addrChangeDriver which connects
    to port A.</p>
  <p>
    It loads six versions of test.db and four versions of testBlock.db The test.adl
    file attaches to these database records.</p>
  <hr />
  <div style="text-align: center">
    <h2 id="asynGpib">
      asynGpib</h2>
  </div>
  <p>
    GPIB has additional features that are not supported by asynCommon and asynOctet.
    asynGpib defines two interfaces.</p>
  <ul>
    <li>asynGpib - This is the interface that device support calls. It provides the following:
      <ul>
        <li>A set of GPIB specific methods that device support can call.</li>
        <li>Code that handles generic GPIB functions like SRQ polling.</li>
        <li>A registerPort method which is called by GPIB port drivers.
          <p>
          </p>
        </li>
      </ul>
    </li>
    <li>asynGpibPort - A set of methods implemented by GPIB drivers</li>
  </ul>
  <h3>
    asynGpibDriver.h</h3>
  <p>
    asynGpibDriver.h contains the following definitions:</p>
  <pre>/* GPIB Addressed Commands*/
#define IBGTL "\x01"    /* Go to local */
#define IBSDC "\x04"    /* Selective Device Clear */
#define IBGET "\x08"    /* Group Execute Trigger */
#define IBTCT "\x09"    /* Take Control */

/* GPIB Universal Commands*/
#define IBDCL 0x14      /* Device Clear */
#define IBLLO 0x11      /* Local Lockout */
#define IBSPE 0x18      /* Serial Poll Enable */
#define IBSPD 0x19      /* Serial Poll Disable */
#define IBUNT 0x5f      /* Untalk */
#define IBUNL 0x3f      /* Unlisten */

/* Talk, Listen, Secondary base addresses */
#define TADBASE    0x40   /* offset to GPIB listen address 0 */
#define LADBASE    0x20   /* offset to GPIB talk address 0 */
#define SADBASE    0x60   /* offset to GPIB secondary address 0 */

#define NUM_GPIB_ADDRESSES    32
#include "asynDriver.h"
#include "asynInt32.h"
#define asynGpibType "asynGpib"
/* GPIB drivers */
typedef struct asynGpib asynGpib;
typedef struct asynGpibPort asynGpibPort;
/*asynGpib defines methods called by gpib aware users*/
struct asynGpib{
    /*addressedCmd,...,ren are just passed to device handler*/
    asynStatus (*addressedCmd) (void *drvPvt,asynUser *pasynUser,
        const char *data, int length);
    asynStatus (*universalCmd) (void *drvPvt,asynUser *pasynUser,int cmd);
    asynStatus (*ifc) (void *drvPvt,asynUser *pasynUser);
    asynStatus (*ren) (void *drvPvt,asynUser *pasynUser, int onOff);
    /* The following are implemented by asynGpib */
    asynStatus (*pollAddr)(void *drvPvt,asynUser *pasynUser, int onOff);
    /* The following are called by low level gpib drivers */
    /*srqHappened is passed the pointer returned by registerPort*/
    void *(*registerPort)(
        const char *portName,
        int attributes,int autoConnect,
        asynGpibPort *pasynGpibPort, void *asynGpibPortPvt,
        unsigned int priority, unsigned int stackSize);
    void (*srqHappened)(void *asynGpibPvt);
};
epicsShareExtern asynGpib *pasynGpib;

struct asynGpibPort {
    /*asynCommon methods */
    void (*report)(void *drvPvt,FILE *fd,int details);
    asynStatus (*connect)(void *drvPvt,asynUser *pasynUser);
    asynStatus (*disconnect)(void *drvPvt,asynUser *pasynUser);
    /*asynOctet methods passed through from asynGpib*/
    asynStatus (*read)(void *drvPvt,asynUser *pasynUser,
                      char *data,int maxchars,int *nbytesTransfered,
                      int *eomReason);
    asynStatus (*write)(void *drvPvt,asynUser *pasynUser,
                      const char *data,int numchars,int *nbytesTransfered);
    asynStatus (*flush)(void *drvPvt,asynUser *pasynUser);
    asynStatus (*setEos)(void *drvPvt,asynUser *pasynUser,
                const char *eos,int eoslen);
    asynStatus (*getEos)(void *drvPvt,asynUser *pasynUser,
                char *eos, int eossize, int *eoslen);
    /*asynGpib methods passed thrtough from asynGpib*/
    asynStatus (*addressedCmd) (void *drvPvt,asynUser *pasynUser,
                const char *data, int length);
    asynStatus (*universalCmd) (void *drvPvt, asynUser *pasynUser, int cmd);
    asynStatus (*ifc) (void *drvPvt,asynUser *pasynUser);
    asynStatus (*ren) (void *drvPvt,asynUser *pasynUser, int onOff);
    /*asynGpibPort specific methods */
    asynStatus (*srqStatus) (void *drvPvt,int *isSet);
    asynStatus (*srqEnable) (void *drvPvt, int onOff);
    asynStatus (*serialPollBegin) (void *drvPvt);
    asynStatus (*serialPoll) (void *drvPvt, int addr, double timeout,int *status);
    asynStatus (*serialPollEnd) (void *drvPvt);
};</pre>
  <h3>
    asynGpib</h3>
  <p>
    asynGpib describes the interface for device support code. It provides gpib specific
    functions like SRQ handling. It makes calls to asynGpibPort. asynGpib.c implements
    asynCommon and asynOctet. It supports asynInt32 by using the methods from asynInt32Base.
    asynInt32 is the way asynGpib reports SRQs to asynUsers.</p>
  <p>
    An asynUser that wishes to receive SRQs calls pasynInt32-&gt;registerInterruptUser
    and must set asynUser.reason = ASYN_REASON_SIGNAL. Although most gpib controllers
    are multidevice drivers, the VXI11 standard allows for a controller (VXI-11.2) that
    attached to a single device, i.e. it is a single address port driver. For such controllers,
    the use must specify addr = 0 in order to use SRQs. Also see the vxi support below
    for more details.</p>
  <p>
  </p>
  <table border="1">
    <caption>
      asynGpib</caption>
    <tbody>
      <tr>
        <td>
          addressedCmd</td>
        <td>
          The request is passed to the low level driver.</td>
      </tr>
      <tr>
        <td>
          universalCmd</td>
        <td>
          The request is passed to the low level driver.</td>
      </tr>
      <tr>
        <td>
          ifc</td>
        <td>
          The request is passed to the low level driver.</td>
      </tr>
      <tr>
        <td>
          ren</td>
        <td>
          The request is passed to the low level driver.</td>
      </tr>
      <tr>
        <td>
          pollAddr</td>
        <td>
          Set SRQ polling on or off. onOff = (0,1) means (disable, enable) SRQ polling of
          specified address.</td>
      </tr>
      <tr>
        <td>
          registerPort</td>
        <td>
          Register a port. When asynGpib receives this request, it calls asynManager.registerPort.
        </td>
      </tr>
      <tr>
        <td>
          srqHappened</td>
        <td>
          Called by low level driver when it detects that a GPIB device issues an SRQ.</td>
      </tr>
    </tbody>
  </table>
  <h3>
    asynGpibPort</h3>
  <p>
    asynGpibPort is the interface that is implemented by gpib drivers, e.g. the VXI-11.
    It provides:</p>
  <table border="1">
    <caption>
      asynGpibPort</caption>
    <tbody>
      <tr>
        <td>
          asynCommon methods</td>
        <td>
          All the methods of asynCommon</td>
      </tr>
      <tr>
        <td>
          asynOctet methods</td>
        <td>
          All the methods of asynOctet</td>
      </tr>
      <tr>
        <td>
          addressedCmd</td>
        <td>
          Issue a GPIB addressed command.</td>
      </tr>
      <tr>
        <td>
          universalCmd</td>
        <td>
          Issue a GPIB universal command.</td>
      </tr>
      <tr>
        <td>
          ifc</td>
        <td>
          Issue a GPIB Interface Clear command.</td>
      </tr>
      <tr>
        <td>
          ren</td>
        <td>
          Issue a GPIB Remote Enable command</td>
      </tr>
      <tr>
        <td>
          srqStatus</td>
        <td>
          If return is asynSuccess then isSet is (0,1) if SRQ (is not, is) active. Normally
          only called by asynGpib.</td>
      </tr>
      <tr>
        <td>
          srqEnable</td>
        <td>
          Enable or disable SRQs. Normally only called by asynGpib.</td>
      </tr>
      <tr>
        <td>
          serialPollBegin</td>
        <td>
          Start of serial poll. Normally only called by asynGpib.</td>
      </tr>
      <tr>
        <td>
          serialPoll</td>
        <td>
          Poll the specified address and set status to the response. Normally only called
          by asynGpib.</td>
      </tr>
      <tr>
        <td>
          serialPollEnd</td>
        <td>
          End of serial poll. Normally only called by asynGpib.</td>
      </tr>
    </tbody>
  </table>
  <hr />
  <div style="text-align: center">
    <h2 id="PortDrivers">
      Port Drivers</h2>
  </div>
  <h3 id="drvAsynSerialPort">
    Local Serial Port</h3>
  <p>
    The drvAsynSerialPort driver supports devices connected to serial ports on the IOC.</p>
  <p>
    Serial ports are configured with the <tt>drvAsynSerialPortConfigure</tt> and <tt>asynSetOption</tt>
    commands:</p>
  <pre>   drvAsynSerialPortConfigure("portName","ttyName",priority,noAutoConnect,
        noProcessEosIn)
   asynSetOption("portName",addr,"key","value")</pre>
  <p>
    where the arguments are:</p>
  <ul>
    <li>portName - The portName that is registered with asynGpib.</li>
    <li>ttyName - The name of the local serial port (e.g. "/dev/ttyS0", "COM1").</li>
    <li>priority - Priority at which the asyn I/O thread will run. If this is zero or
      missing,then epicsThreadPriorityMedium is used.</li>
    <li>addr - This argument is ignored since serial devices are configured with multiDevice=0.</li>
    <li>noAutoConnect - Zero or missing indicates that portThread should automatically
      connect. Non-zero if explicit connect command must be issued.</li>
    <li>noProcessEos If 0 then asynInterposeEosConfig is called specifying both processEosIn
      and processEosOut.</li>
  </ul>
  <p>
    The setEos and getEos methods have no effect and return asynError. The read method
    blocks until at least one character has been received or until a timeout occurs.
    The read method transfers as many characters as possible, limited by the specified
    count. asynInterposeEos can be used to support EOS.</p>
  <p>
    The following table summarizes the drvAsynSerialPort driver asynSetOption keys and
    values. When a serial port connects the current values are fetched.</p>
  <table border="1">
    <tbody>
      <tr>
        <th>
          Key</th>
        <th>
          Value</th>
      </tr>
      <tr>
        <td>
          baud</td>
        <td>
          50 75 110 134 150 200 300 600 1200 2400 9600 ...</td>
      </tr>
      <tr>
        <td>
          bits</td>
        <td>
          8 7 6 5</td>
      </tr>
      <tr>
        <td>
          parity</td>
        <td>
          none even odd</td>
      </tr>
      <tr>
        <td>
          stop</td>
        <td>
          1 2</td>
      </tr>
      <tr>
        <td>
          clocal</td>
        <td>
          Y N</td>
      </tr>
      <tr>
        <td>
          crtscts</td>
        <td>
          N Y</td>
      </tr>
      <tr>
        <td>
          ixon</td>
        <td>
          N Y</td>
      </tr>
      <tr>
        <td>
          ixoff</td>
        <td>
          N Y</td>
      </tr>
      <tr>
        <td>
          ixany</td>
        <td>
          N Y</td>
      </tr>
      <tr>
        <td>
          rs485_enable</td>
        <td>
          N Y</td>
      </tr>
      <tr>
        <td>
          rs485_rts_on_send</td>
        <td>
          N Y</td>
      </tr>
      <tr>
        <td>
          rs485_rts_after_send</td>
        <td>
          N Y</td>
      </tr>
      <tr>
        <td>
          rs485_delay_rts_before_send</td>
        <td>
          msec_delay</td>
      </tr>
      <tr>
        <td>
          rs485_delay_rts_after_send</td>
        <td>
          msec_delay</td>
      </tr>
    </tbody>
  </table>
  <p>
    On some systems (e.g. Windows, Darwin) the driver accepts any numeric value for
    the baud rate, which must, of course be supported by the system hardware. On Linux
    the choices are limited to the values like B300, B9600, etc. which are defined in
    /usr/include/bits/termios.h.</p>
  <p>
    The clocal and crtscts parameter names are taken from the POSIX termios serial interface
    definition. The clocal parameter controls whether the modem control lines (Data
    Terminal Ready, Carrier Detect/Received Line Signal Detect) are used (clocal=N)
    or ignored (clocal=Y). The crtscts parameter controls whether the hardware handshaking
    lines (Request To Send, Clear To Send) are used (crtscts=Y) or ignored (crtscts=N).</p>
  <p>
    The vxWorks sioLib serial support does not provide support for modem control lines.
    It also uses clocal for what is actually crtscts. For vxWorks the standard serial
    support accepts both clocal and crtscts for getOption and setOption. clocal=Y implies
    crtscts=N and clocal=N implies crtscts=Y.</p>
  <p>
    ixon controls XON/OFF flow control on output. If the IOC receives an XOFF character,
    it suspends output until an XON character is received.</p>
  <p>
    ixoff controls XON/OFF flow control on input. The IOC sends XOFF and XON characters
    as necessary to prevent input from coming in faster than programs are reading it.
    The external device sending the input data must respond to an XOFF character by
    suspending transmission, and to an XON character by resuming transmission.</p>
  <p>
    The ixany flag allows any input character to restart output when output has been
    suspended with the XOFF character. Otherwise, only the XON character restarts output.
    This flag is not available on all systems, including WIN32.</p>
  <p>
    The rs485 options are only supported on Linux, only kernels &ge; 2.6.35, and only
    on hardware ports that support RS-485. The delay option units are integer milliseconds.</p>
  <p>
    vxWorks IOC serial ports may need to be set up using hardware-specific commands.
    Once this is done, the standard drvAsynSerialPortConfigure and asynSetOption commands
    can be issued. For example, the following example shows the configuration procedure
    for a port on a GreenSprings octal UART Industry-Pack module on a GreenSprings VIP616-01
    carrier.</p>
  <pre>
ipacAddVIPC616_01("0x6000,B0000000")
tyGSOctalDrv(1)
tyGSOctalModuleInit("Mod0","232", 0x80, 0, 0)
tyGSOctalDevCreate("/tyGS/0/0","Mod0",0,0,1000,1000)
drvAsynSerialPortConfigure("/tyGS/0/0","/tyGS/0/0",0,0,0)
asynSetOption("/tyGS/0/0",0,"baud","9600")

For the IP520:

IP520Drv(1)
IP520ModuleInit("UART_0", "232", 0xC2, 0, 0)
IP520DevCreate("A1", "UART_0", 0, 0, 1000, 1000)
drvAsynSerialPortConfigure("A1","A1",0,0,0)
asynSetOption("A1",0,"baud",9600)
asynOctetSetInputEos( "A1",0,"\r")
asynOctetSetOutputEos("A1",0,"\r")
</pre>
  <h3 id="drvAsynIPPort">
    TCP/IP or UDP/IP Port</h3>
  <p>
    The drvAsynIPPort driver supports devices which communicate over a TCP/IP or UDP/IP
    connection. A typical example is a device connected through an Ethernet/Serial converter
    box.</p>
  <p>
    TCP/IP or UDP/IP connections are configured with the <tt>drvAsynIPPortConfigure</tt>
    command:</p>
  <pre>   drvAsynIPPortConfigure("portName","hostInfo",priority,noAutoConnect,
        noProcessEos)</pre>
  <p>
    where the arguments are:</p>
  <ul>
    <li>portName - The portName that is registered with asynManager.</li>
    <li>hostInfo - The Internet host name, port number, optional local port number, and
      optional IP protocol of the device. The format is:<br />
      &lt;host&gt;:&lt;port&gt;[:localPort] [protocol]<br />
      (e.g. "164.54.9.90:4002", "164.54.9.90:4001:10101", "serials8n3:4002", "serials8n3:4002
      TCP" or "164.54.17.43:5186 udp"). If no protocol is specified, TCP will be used.
      Possible protocols are
      <ul>
        <li>TCP</li>
        <li>UDP</li>
        <li>UDP* -- UDP broadcasts. The address portion of the argument must be the network
          broadcast address (e.g. "192.168.1.255:1234 UDP*").</li>
        <li>HTTP -- Like TCP but for servers which close the connection after each transaction.</li>
        <li>COM -- For Ethernet/Serial adapters which use the TELNET RFC 2217 protocol. This
          allows port parameters (speed, parity, etc.) to be set with subsequent asynSetOption
          commands just as for local serial ports. The default parameters are 9600-8-N-1 with
          no flow control.</li>
      </ul>
      If the hostInfo argument begins wih the characters <span style="font-weight: bold">
        unix://</span> the remainder of the argument is taken to be the name of a UNIX-domain
      stream socket.
      <br />
      Note that the localPort should almost never be used because normally the local host
      choses an unused random local port that it binds to and passes to the server. However,
      there are some unusual servers that only accept a specific local port or range of
      local ports, in which case localPort must be specified.</li>
    <li>priority - Priority at which the asyn I/O thread will run. If this is zero or
      missing, then epicsThreadPriorityMedium is used.</li>
    <li>noAutoConnect - Zero or missing indicates that portThread should automatically
      connect. Non-zero if explicit connect command must be issued.</li>
    <li>noProcessEos If 0 then asynInterposeEosConfig is called specifying both processEosIn
      and processEosOut.</li>
  </ul>
  <p>
    Only asynOctet methods write, read, and flush are implemented. Calling the other
    methods will result in an error unless asynInterposeEos is used for the other asynOctet
    methods. read blocks until at least one character has been received or until a timeout
    occurs. read transfers as many characters as possible, limited by the specified
    count.</p>
  <p>
    The following table summarizes the drvAsynIPPort driver asynSetOption keys and values.</p>
  <table border="1">
    <tbody>
      <tr>
        <th>
          Key</th>
        <th>
          Value</th>
        <th>
          Description</th>
      </tr>
      <tr>
        <td>
          disconnectOnReadTimeout</td>
        <td>
          N Y</td>
        <td>
          Default=N. If Y then if a read operation times out the driver automatically disconnect
          the IP port.</td>
      </tr>
      <tr>
        <td>
          hostInfo</td>
        <td>
          &lt;host&gt;:&lt;port&gt;[:localPort] [protocol]</td>
        <td>
          The IP port hostInfo specification using the same syntax as drvAsynIPPortConfigure.
          This option allows changing at run time the Internet host and port to which this
          asyn port is connected. The only restriction is that the setting of the COM (TELNET
          RFC 2217) protocol cannot be changed from that specified with drvAsynIPPortConfigure.
          This is because if COM is specified in the drvAsynIPPortConfigure command then asynOctet
          and asynOption interpose interfaces are used, and asynManager does not support removing
          interpose interfaces.</td>
      </tr>
    </tbody>
  </table>
  <p>
    In addition to these key/value pairs if the COM protocol is used then the drvAsynIPPort
    driver uses the same key/value pairs as the drvAsynSerialPort driver for specifying
    the serial parameters, i.e. "baud", "bits", etc.</p>
  <p>
    asynInterposeEos and asynInterposeFlush can be used to provide additional functionality.</p>
  <h3 id="drvAsynIPServerPort">
    TCP/IP Server</h3>
  <p>
    The drvAsynIPServerPort driver supports asyn socket servers by listening for TCP/IP
    or UDP connections from remote clients. The listener thread then creates a new drvAsynIPPort
    port by calling drvAsynIPPortConfigure (or re-uses a disconnected port it previously
    created), and calls back any registered asyn clients with the name of the new port.
    These asyn clients will typically be socket servers.</p>
  <p>
    IP server listeners are configured with the <tt>drvAsynIPServerPortConfigure</tt>
    command:</p>
  <pre> drvAsynIPServerPortConfigure("portName", "serverInfo", maxClients, priority, 
      noAutoConnect, noProcessEos);</pre>
  <p>
    where the arguments are:</p>
  <ul>
    <li>portName - The portName that is registered with asynManager.</li>
    <li>serverInfo - The Internet host name and port number to listen for connections
      on (e.g. "localhost:4002" for TCP, "localhost:4002 UDP" for UDP).</li>
    <li>maxClients - the maximum number of IP clients that can be simultaneously connected
      on this port. Additional connect requests will fail.</li>
    <li>priority - Priority at which the listener thread and any asyn I/O ports it creates
      will run. If this is zero or missing, then epicsThreadPriorityMedium is used.</li>
    <li>noAutoConnect - Zero or missing indicates that the listener port should automatically
      connect. Non-zero if explicit connect command must be issued. Note that all asyn
      I/O ports that the listener thread creates will be created with noAutoConnect=1,
      but this is transparent to socket server applications, because the listener thread
      does the explicit connect for them.</li>
    <li>noProcessEos is passed to drvAsynIPPortConfigure when new asyn I/O ports are created.
      If 0 then asynInterposeEosConfig is called specifying both processEosIn and processEosOut.</li>
  </ul>
  <p>
    This driver implements the asynOctet interface. The only methods it supports are
    registerInterruptUser and cancelInterruptUser. Calling the other asynOctet methods
    will result in an error. The following happens when a new connection is received
    on the port specified in drvAsynIPServerPortConfigure:</p>
  <ul>
    <li>If there are no registered asyn clients (who have called registerInterruptUser
      on the asynOctet interface of the listener port) then the incoming connection is
      immediately closed, since there are no IP servers available to service it. If there
      is at least one registered client, then the following steps are executed.</li>
    <li>The list of drvAsynIPPort ports that this listener thread has created is searched
      to see if there is an existing port that is currently disconnected because the remote
      IP client disconnected.</li>
    <li>If there is an existing disconnected port, then it is reconnected with the file
      descriptor from the new IP connection.</li>
    <li>If there is no available existing port, then a new one is created by calling drvAsynIPPortConfigure.
      The name of the new port is of the form portName:1, portName:2, etc., where portName
      is the name of the listener port.</li>
    <li>The asynTraceMask and asynTraceIOMask of the newly connected port are set to the
      current values of the listener thread port. This makes it possible to trace the
      early stages of execution of the callbacks to the registered clients, before one
      could enable tracing at iocsh.</li>
    <li>All registered asyn clients (who have called registerInterruptUser on the asynOctet
      interface of the listener port) are called back with the name of the newly connected
      port.</li>
    <li>The clients then will connect to this new asyn port and perform I/O using the
      asynOctet methods.</li>
  </ul>
  <h3 id="vxi11">
    VXI-11</h3>
  <p>
    VXI-11 is a TCP/IP protocol for communicating with IEEE 488.2 devices. It is an
    RPC based protocol. In addition to the VXI-11 standard, three additional standards
    are defined.</p>
  <ul>
    <li>VXI-11.1 - A standard for communicating with VXIbus devices. These controllers
      have a vxiName that starts with "vxi" and can control multiple devices, i.e. the
      port driver will be a multiaddress driver.</li>
    <li>VXI-11.2 - A standard for communicating with a IEEE 488.1 device. This means that
      the TCP/IP connection is talking to a GPIB controller that is talking to a GPIB
      bus. These devices have an vxiName that starts with "gpib". Note that the Agilent
      E2050A does not follow the standard. For it the vxiName must be "hpib"</li>
    <li>VXI-11.3 - A standard for communicating with IEEE 488.2 devices. This means that
      the TCP/IP connection is talking directly with an device. These devices have an
      vxiName that starts with "inst". These controllers can control only a single device,
      i.e. the port driver will be a single address driver</li>
  </ul>
  <p>
    NOTES</p>
  <ul>
    <li>No VXI-11.1 controller has been tested.</li>
    <li>The following VXI-11.2 controllers have been tested: Agilent E2050 and E5810</li>
    <li>The following VXI-11.3 instruments have been tested:
      <ul>
        <li>Tektronic TDS3054B scope.
          <p>
            SRQs do not work. Do not know why</p>
        </li>
        <li>Tektronic TDS5054B scope.
          <p>
            SRQs do work. The asynUser MUST specify addr = 0. Also do NOT set bit 0x40 of Service
            Request Enable register, i.e. cause SRQ when device has output available. This did
            not work and can cause infinite set of SRQs</p>
        </li>
      </ul>
    </li>
  </ul>
  <p>
    Consult the following documents (available on-line) for details.</p>
  <pre>VMEbus Extensions for Instrumentation
    VXI-11   TCP/IP Instrument Protocol Specification
    VXI-11.1 TCP/IP-VXIbus Interface Specification
    VXI-11.2 TCP/IP-IEEE 488.1 Interface Specification
    VXI-11.3 TCP/IP-IEEE 488.2 Instrument Interface Specification</pre>
  <p>
    The following commands may be specified in the st.cmd file</p>
  <pre>    E2050Reboot("inet_addr")
    E5810Reboot("inet_addr","password")
    vxi11Configure("portName","inet_addr",flags,"timeout",
        "vxiName",priority,noAutoConnect)</pre>
  <p>
    where</p>
  <ul>
    <li>inet_addr - Internet Address</li>
    <li>password - password. If given as 0 the default E5810 is used.</li>
    <li>portName - The portName that is registered with asynGib.</li>
    <li>flags - Bitmap
      <ul>
        <li>Bit 0 (0x1) recoverWithIFC - (0,1) =&gt; (don't, do) issue IFC when error occurs.</li>
        <li>Bit 1 (0x2) lockDevices - (0,1 ) =&gt; (don't, do) lock devices when creating
          the link.</li>
        <li>Bit 2 (0x4) noSRQ - (0,1 ) =&gt; (do, don't) set up a VXI-11 SRQ channel.</li>
      </ul>
    </li>
    <li>timeout - I/O operation timeout in seconds as a string. Prior to release R4-16
      this was a double, but was changed to a string because it is not safe to pass doubles
      on the vxWorks shell. If "0.0", then a default is assigned.</li>
    <li>vxiName - Must be chosen as specified above. NOTE: For the Agilent E2050 vxiName
      must be "hpib". For the Agilent E5810 use the name "gpib0". For an instrument that
      supports VXI11 try "inst0".</li>
    <li>priority - Priority at which the asyn I/O thread will run. If this is zero or
      missing, then epicsThreadPriorityMedium is used.</li>
    <li>noAutoConnect - Zero or missing indicates that portThread should automatically
      connect. Non-zero if explicit connect command must be issued.</li>
  </ul>
  <p>
    The vxi11 driver implements two timeouts: ioTimeout and rpcTimeout (Remote Procedure
    Call timeout). The ioTimeout is taken from asynUser:timeout. The rpcTimeout is handled
    internally for each port. It has a default of 4 seconds but can be changed by calling
    setOptions. For example:</p>
  <pre>asynSetOption L0 -1 rpctimeout .1</pre>
  <p>
    Will change the rpcTimeout for port L0 to .1 seconds.</p>
  <h3 id="Linux-gpib">
    Linux-Gpib</h3>
  <p>
    The linux-gpib port driver was written to support <a href="http://sourceforge.net/project/showfiles.php?group_id=42378&amp;package_id=34482">
      The Linux GPIB Package library</a>.</p>
  <p>
    In order to build this support the Linux GPIB Package must be installed. Also in
    configure/RELEASE the statement:</p>
  <pre>    LINUX_GPIB=NO</pre>
  <p>
    must be changed to</p>
  <pre>    LINUX_GPIB=YES</pre>
  <p>
    Configuration command is:</p>
  <pre>    GpibBoardDriverConfig(portName,autoConnect,BoardIndex,timeout,priority)</pre>
  <p>
    where</p>
  <ul>
    <li>portName - An ascii string specifying the port name that will be registered with
      asynDriver.</li>
    <li>noAutoConnect - Non-zero indicates that portThread should automatically connect.
      Zero means explicit connect command must be issued.</li>
    <li>boardIndex -Integer containing index of board (0 means /dev/gpib0). Normally it
      is 0. This must be the same as in gpib.conf file (minor number - board index) of
      driver configuration.</li>
    <li>timeout - Time in seconds in which an i/o operation must complete. Zero means
      disabled. This is "general" timeout for every call to low level drivers. For actual
      read/write operations timeout must be defined in device support. Both timeouts are
      converted into integers 0-17 which represents disabled to 1000 seconds.</li>
    <li>priority - An integer specifying the priority of the port thread. A value of 0
      will result in a default value being assigned.</li>
  </ul>
  <p>
    An example is:</p>
  <pre>GpibBoardDriverConfig("L0",1,0,3,0)</pre>
  <p>
    NOTES:</p>
  <ul>
    <li>AsynOption Interface is supported. Key (hexadecimal) and val (integer) arguments
      to setPortOptions function must be appropriate values represented as character arrays.
      See GPIB library documentation for details.</li>
    <li>pgpibCmd type GPIBREADW and GPIBEFASTIW were not tested.</li>
    <li>The linux-port driver was tested with PC104-GPIB board from Measurement Computing.</li>
  </ul>
  <h3 id="gsIP488">
    Green Springs IP488</h3>
  <p>
    This is support for the Green Springs Industry Pack GPIB carrier. The configuration
    command is:</p>
  <pre>    gsIP488Configure(portName,carrier,module,intVec,priority,noAutoConnect)</pre>
  <p>
    where</p>
  <ul>
    <li>portName - An ascii string specifying the port name that will be registered with
      asynDriver.</li>
    <li>carrier - An integer identifying the Industry Pack Carrier</li>
    <li>module - An integer identifying the module on the carrier</li>
    <li>intVec - An integer specifying the interrupt vector</li>
    <li>priority - An integer specifying the priority of the portThread. A value of 0
      will result in a defalt value being assigned</li>
    <li>noAutoConnect - Zero or missing indicates that portThread should automatically
      connect. Non-zero if explicit connect command must be issued.</li>
  </ul>
  <p>
    An example is:</p>
  <pre>#The following is for the Greensprings IP488 on an MV162 
ipacAddMVME162("A:l=3,3 m=0xe0000000,64")
gsIP488Configure("L0",0,0,0x61,0,0)</pre>
  <p>
    WARNING:</p>
  <p>
    This module includes code that implement a 6 microsecond delay because the gpib
    interface chip requires it. The first time gsIP488Configure is executed code is
    run to determine a variable used by the delay routine. It assumes that there is
    no higher priority thread running that consumes lots of cpu cycles.</p>
  <h3 id="ni1014">
    National Instruments GPIB-1014D</h3>
  <p>
    This is support for a National Instruments VME GPIB interface. The configuration
    command is:</p>
  <pre>    ni1014Config(portNameA,portNameB,base,vector,level,priority,noAutoConnect)</pre>
  <p>
    where</p>
  <ul>
    <li>portNameA - An ascii string specifying the port name that will be registered with
      asynDriver for portA.</li>
    <li>portNameB - An ascii string specifying the port name that will be registered with
      asynDriver for portB. If only one port should be registered, then leave this as
      a null string. The support should also work for a single port NI1014 but has not
      been tested.</li>
    <li>base - VME A16 base address.</li>
    <li>vector - VME interrupt vector.</li>
    <li>level - An integer specifying the interrupt level.</li>
    <li>priority - In integer specifying the priority of the portThread. A value of 0
      will result in a defalt value being assigned</li>
    <li>noAutoConnect - Zero or missing indicates that portThread should automatically
      connect. Non-zero if explicit connect command must be issued.</li>
  </ul>
  <p>
    An example is:</p>
  <pre>ni1014Config("L0","L1",0x5000,0x64,5,0,0)</pre>
  <p>
    NOTES:</p>
  <ul>
    <li>Ports A and B are almost but not quite the same. Thus the code for connecting
      to port A is slightly different than the code for portB.</li>
    <li>In order to disconnect and reconnect either port, BOTH ports must be disconnected
      and reconnected.</li>
    <li>When the ports are connected, portA MUST be connected before port B.</li>
    <li>Programmed I/O, via interrupts, rather than DMA is implemented. Thus no A24 address
      space is required.</li>
  </ul>
  <p>
    WARNING:</p>
  <p>
    This module includes code that implement a 6 microsecond delay because the gpib
    interface chip requires it. The first time ni1014Config is executed code is run
    to determine a variable used by the delay routine. It assumes that there is no higher
    priority thread running that consumes lots of cpu cycles.</p>
  <h3 id="usbtmc">
    USB TMC (Test and Measurement Class) driver</h3>
  <p>
    Configure each instance of the driver in the application startup script:</p>
  <pre>usbtmcConfigure("asynPort", vendorId, productId, "serialNumber", priority, flags)</pre>
  <p>
    The <tt>asynPort</tt> and <tt>serialNumber</tt> arguments are strings and the other
    arguments are integers. A missing or 0 <tt>vendorId</tt> or <tt>productId</tt> matches
    any value and a missing or empty <tt>serialNumber</tt> string matches any value.
    Thus the command:</p>
  <pre>usbtmcConfigure("usbtmc1")</pre>
  <p>
    will associate ASYN port usbtmc1 with the first USB TMC device discovered. A missing
    or 0 priority will set the worker thread priority to its default value of 50 (<tt>epicsThreadPriorityMedium</tt>).</p>
  <p>
    A missing flags argument is taken to be 0. As of now only one bit is used: Bit 0
    (0x1) Disable/enable (1/0) automatic port connection.</p>
  <h4>
    Non-octet records</h4>
  <p>
    In addition to the asynOctet stream this support module provides some values for
    records with DTYP=asynInt32. Since the port is a single-address device the subaddress
    field of the INP or OUT '@asyn()' descriptor can not be used. Instead the 'drvUser'
    string at the end of the INP or OUT field is used to distinguish the parameter to
    be read or written.
  </p>
  <h5>
    Service Request (SRQ) handling</h5>
  <p>
    The presence of one or more records with INP="@asyn(port, 0, 0) SRQ") will cause
    the driver to create an extra thread to read from the device Interrupt-In endpoint.
    The SCAN field must be "I/O Intr". Record processing will occur when the device
    sends a service request message on the Interrupt-In endpoint and the value will
    be the device status byte sent as part of the service request message. Typically
    the record type will be longin or mbbiDirect.</p>
  <h5>
    Device Status Byte (STB)</h5>
  <p>
    The USBTMC/USB488 device status byte is read by a record with</p>
  <pre>INP="@asyn(port, 0, 0) STB").</pre>
  <p>
    Typically the record type will be longin or mbbiDirect.</p>
  <h5>
    Remote Enable (REN)</h5>
  <p>
    The device remote enable is written by a record with</p>
  <pre>OUT="@asyn(port, 0, 0) REN") </pre>
  <p>
    Typically the record type will be bo.</p>
  <h4>
    Linux udev configuration</h4>
  <p>
    If attempts to communicate with a device result in error messages of the form "Access
    denied (insufficient permissions)" you must add udev entries to allow access. In
    the /etc/udev/rules.d directory create a file, 55-usbtmc.rules for example, with
    a line for each device of interest.</p>
  <p>
    To allow everyone in the "usbtmc" group access to a device with vendor code 1BFA
    (hexadecimal) and product code 0498 (hexadecimal) the line would look like:</p>
  <pre>
SUBSYSTEM=="usb", ATTRS{idVendor}=="1BFA", ATTRS{idProduct}=="0498", GROUP="usbtmc", MODE="0660"</pre>
  <p>
    To allow everyone access the line would look like:</p>
  <pre>
SUBSYSTEM=="usb", ATTRS{idVendor}=="1BFA", ATTRS{idProduct}=="0498", MODE="0666"</pre>
  <p>
    The <tt>{idVendor}</tt> and <tt>{idProduct}</tt> values must match those of the
    device with which you wish to communicate.</p>
  <h4>
    StreamDevice Exception Handlers</h4>
  <p>
    The USBTMC driver attempts to take correct action when it detects that the device
    has been unplugged or become unresponsive. The effectiveness of this depends somewhat
    on the level of support provided by the underlying operating system so it is good
    practice to also specify the following StreamDevice global exception handlers:</p>
  <pre>
    @mismatch { disconnect; }
    @writetimeout { disconnect; }
    @readtimeout { disconnect; }
    @replyTimeout { disconnect; }
</pre>
  <h3 id="Additional_Drivers">
    Additional Drivers</h3>
  <p>
    The drivers noted above are included as part of the ASYN distribution.&nbsp; Additional
    drivers are available, including:<br />
  </p>
  <ul>
    <li><a href="http://www.aps.anl.gov/epics/download/modules/PrologixGPIB-1.1.tar.gz">
      Driver for Prologix LAN/GPIB adapter</a></li>
  </ul>
  <hr />
  <div style="text-align: center">
    <h2 id="asynPortDriver">
      asynPortDriver C++ base class</h2>
  </div>
  <p>
    A C++ base class called asynPortDriver is available. This is a base class from which
    real asyn port drivers can be derived. It greatly simplifies the job of writing
    an asyn port driver, because it takes care of all of the tasks like registering
    the port, registering the interfaces, and calling interrupt clients. It is documented
    separately in <a href="asynPortDriver.html">asynPortDriver.html</a>.</p>
  <hr />
  <div style="text-align: center">
    <h2 id="asynPortClient">
      asynPortClient C++ classes</h2>
  </div>
  <p>
    asynPortClient is a set of C++ classes that are designed to simplify the task of
    writing a client that directly communicates with an asyn port driver, without running
    an EPICS IOC. They handle the details of connecting to the driver, finding the required
    interfaces, etc. They only uses the synchronous interfaces, so all calls are blocking.
    If clients need asynchronous operation then they can use the normal C interface
    with pasynManager->queueRequest. It is documented separately in <a href="asynPortClient.html">
      asynPortClient.html</a>.</p>
  <hr />
  <div style="text-align: center">
    <h2 id="DiagnosticAids">
      Diagnostic Aids</h2>
  </div>
  <h3>
    iocsh Commands</h3>
  <pre>    asynReport(level,portName)
    asynInterposeFlushConfig(portName,addr,timeout)
    asynInterposeEosConfig(portName,addr,processIn,processOut)
    asynSetTraceMask(portName,addr,mask)
    asynSetTraceIOMask(portName,addr,mask)
    asynSetTraceInfoMask(portName,addr,mask)
    asynSetTraceFile(portName,addr,filename)
    asynSetTraceIOTruncateSize(portName,addr,size)
    asynSetOption(portName,addr,key,val)
    asynShowOption(portName,addr,key)
    asynAutoConnect(portName,addr,yesNo)
    asynSetAutoConnectTimeout(timeout)
    asynWaitConnect(portName, timeout)
    asynEnable(portName,addr,yesNo)
    asynOctetConnect(entry,portName,addr,timeout,buffer_len,drvInfo)
    asynOctetRead(entry,nread)
    asynOctetWrite(entry,output)
    asynOctetWriteRead(entry,output,nread)
    asynOctetFlush(entry)
    asynOctetSetInputEos(portName,addr,eos,drvInfo)
    asynOctetGetInputEos(portName,addr,drvInfo)
    asynOctetSetOutputEos(portName,addr,eos,drvInfo)
    asynOctetGetOutputEos(portName,addr,drvInfo)
    asynRegisterTimeStampSource(portName,functionName);
    asynUnregisterTimeStampSource(portName)    
    </pre>
  <p>
    <code>asynReport</code> calls <code>asynCommon:report</code> for a specific port
    if portName is specified, or for all registered drivers and interposeInterface if
    portName is not specified.</p>
  <p>
    <code>asynInterposeFlushConfig</code> is a generic interposeInterface that implements
    flush for low level drivers that don't implement flush. It just issues read requests
    until no bytes are left to read. The timeout is used for the read requests.</p>
  <p>
    <code>asynInterposeEosConfig</code> is a generic interposeInterface that implements
    End of String processing for low level drivers that don't.</p>
  <p>
    <code>asynSetTraceMask</code> calls <code>asynTrace:setTraceMask</code> for the
    specified port and address. If portName is zero length then the global trace mask
    is set.</p>
  <p>
    <code>asynSetTraceIOMask</code> calls <code>asynTrace:setTraceIOMask</code> for
    the specified port and address. If portName is zero length then the global traceIO
    mask is set.</p>
  <p>
    <code>asynSetTraceInfoMask</code> calls <code>asynTrace:setTraceInfoMask</code>
    for the specified port and address. If portName is zero length then the global traceInfo
    mask is set.</p>
  <p>
    <code>asynSetTraceFile</code> calls <code>asynTrace:setTraceFile</code>. The filename
    is handled as follows:</p>
  <ul>
    <li>Not specified - A NULL pointer is passed to setTraceFile. Subsequent messages
      are sent to errlog.</li>
    <li>An empty string ("") or "stderr" - stderr is passed to setTraceFile.</li>
    <li>"stdout" - stdout is passed to setTraceFile.</li>
    <li>Any other string - The specified file is opened with an option of "w" and the
      file pointer is passed to setTraceFile.</li>
  </ul>
  <p>
    <code>asynSetTraceIOTruncateSize</code> calls <code>asynTrace:setTraceIOTruncateSize</code></p>
  <p>
    <code>asynSetOption</code> calls <code>asynCommon:setOption</code>. <code>asynShowOption</code>
    calls <code>asynCommon:getOption</code>.</p>
  <p>
    Thw asynOctetXXX commands provide shell access to asynOctetSyncIO methods. The entry
    is a character string constant that identifies the port,addr.</p>
  <p>
    where</p>
  <ul>
    <li>filename - An ascii string naming a file. If null or a null string, then the output
      is sent to <code>stdout.</code></li>
    <li>level - The report level.</li>
    <li>portName - An ascii string specifying the portName of the driver.</li>
    <li>addr - In integer specifying the address of the device. For multiDevice ports
      a value of -1 means the port itself. For ports that support a single device, addr
      is ignored.</li>
    <li>mask - The mask value to set. See the mask bit definitions in asynDriver.h</li>
    <li>key - The key for the option desired.</li>
    <li>val - The value for the option.</li>
    <li>yesNo - The value (0,1) means (no,yes).</li>
    <li>entry - A character string that identifies the asynOctetConnect request.</li>
    <li>timeout - timeout as an integer in milliseconds. The default is 1.</li>
    <li>buffer_len - length of buffer for I/O. Default=160. NOTE: output strings passed
      to asynOctetWrite can have escape characters. The buffer_len must be large enough
      to handle escape characters. For example if \x02 appears in an output string it
      counts as four characters.</li>
    <li>drvInfo - A string to pass to the driver via interface asynDrvUser.</li>
    <li>nread - max number of bytes to read. Default=buffer_len.</li>
    <li>flush - (0,1) means (don't, do) flush before reading. Default=0.</li>
    <li>output - output string.</li>
  </ul>
  <p>
    The commands asynOctetConnect, asynOctetDisconnect, asynOctetRead, asynOctetWrite,
    asynOctetWriteRead, asynOctetFlush allow I/O to a device from the ioc shell. Examples
    are:</p>
  <pre>asynOctetConnect("myid","A",0,1,20)
asynOctetWrite("myid","testnew")
asynOctetRead("myid")
testnew\n
asynOctetWriteRead("myid","this is test")
this is test\n
asynOctetDisconnect("myid")</pre>
  <p>
    <code>asynRegisterTimeStampSource</code> calls <code>pasynManager-&gt;registerTimeStampSource</code>
    for the specified port. The time stamp source function must be defined as a "function"
    in the application dbd file.</p>
  <p>
    <code>asynUnregisterTimeStampSource</code> calls <code>pasynManager-&gt;runegisterTimeStampSource</code>
    for the specified port. This reverts to the default timestamp source function in
    asynManager.</p>
  <hr />
  <div style="text-align: center">
    <h2 id="InstallBuild">
      Install and Build</h2>
  </div>
  <h3>
    Install and Build asynDriver</h3>
  <p>
    After obtaining a copy of the distribution, it must be installed and built for use
    at your site. These steps only need to be performed once for the site (unless versions
    of the module running under different releases of EPICS and/or the other required
    modules are needed).</p>
  <ol>
    <li>Create an installation directory for the module, usually this will end with
      <pre><tt>.../support/asyn/</tt></pre>
    </li>
    <li>Place the distribution file in this directory. Then issue the commands (Unix style)
      <pre>gunzip &lt;file&gt;.tar.gz
tar xvf &lt;file&gt;.tar</pre>
    </li>
    <li>This creates a support &lt;top&gt;.
      <pre>.../support/asyn/X-Y</pre>
      where X-Y is the release number. For example:
      <pre>.../support/asyn/3-1</pre>
    </li>
    <li>Edit the <tt>config/RELEASE</tt> file and set the paths to your installation of
      EPICS_BASE and IPAC. IPAC is only needed if you are building for vxWorks.</li>
    <li>Run <tt>make</tt> in the top level directory and check for any compilation errors.</li>
  </ol>
  <h3>
    Using asynDriver Components with an EPICS iocCore Application</h3>
  <p>
    Since asynDriver does NOT provide support for specific devices an application must
    obtain device specific support elsewhere. This section only explains how to include
    asynDriver components.</p>
  <p>
    In the <code>configure/RELEASE</code> file add definitions for <code>IPAC</code>,
    <code>ASYN</code>, and <code>EPICS_BASE</code>.</p>
  <p>
    In the src directory where the application is built:</p>
  <ul>
    <li>Add the following to <code>Makefile</code>
      <pre>        &lt;app&gt;_LIBS += asyn
    </pre>
    </li>
    <li>The application database definition file must include the database definition
      files for the stream package and for any needed ASYN drivers. There are two ways
      that this can be done:<br />
      <ul>
        <li>If you are building your application database definition file from the application
          Makefile you specify the aditional database definitions there (uncomment the lines
          appropriate to your application):
          <pre>          include "asyn.dbd"
          #include "drvAsynSerialPort.dbd"
          #include "drvAsynIPPort.dbd"
          #include "drvVxi11.dbd"
          #include "drvGsIP488.dbd"
          #include "drvIpac.dbd"
          #include "drvUSBTMC.dbd"
          </pre>
        </li>
        <li>If you are building your application database definition file from the application
          Makefile you specify the aditional database definitions there (again, uncomment
          the lines appropriate to your application):
          <pre>          xxx_DBD += asyn.dbd
          #xxx_DBD += drvAsynSerialPort.dbd
          #xxx_DBD += drvAsynIPPort.dbd
          #xxx_DBD += drvVxi11.dbd
          #xxx_DBD += drvGsIP488.dbd
          #xxx_DBD += drvIpac.dbd
          #xxx_DBD += drvUSBTMC.dbd
          </pre>
        </li>
      </ul>
    </li>
  </ul>
  <p>
    In the <code>st.cmd</code> file add:</p>
  <p>
    dbLoadRecords("db/asynRecord.db", "P=&lt;ioc&gt;, R=&lt;record&gt;, PORT=&lt;port&gt;,
    ADDR=&lt;addr&gt;, OMAX=&lt;omax&gt;, IMAX=&lt;imax&gt;")</p>
  <p>
    You must provide values for &lt;ioc&gt;, &lt;record&gt;, &lt;port&gt;, &lt;addr&gt;,
    &lt;omax&gt;, and &lt;imax&gt;.</p>
  <p>
    Once the application is running, medm displays for an ioc can be started by: medm
    -x -macro "P=&lt;ioc&gt;,R=&lt;record&gt;" &lt;asyntop&gt;/medm/asynRecord.adl &amp;</p>
  <p>
    You must provide correct values for &lt;ioc&gt; and &lt;record&gt;. Once asynRecord
    is started, it can be connected to different devices.</p>
  <hr />
  <div style="text-align: center">
    <h2 id="LicenseAgreement">
      License Agreement</h2>
  </div>
  <pre>Copyright (c) 2002 University of Chicago All rights reserved.
asynDriver is distributed subject to the following license conditions:

SOFTWARE LICENSE AGREEMENT
Software: asynDriver

 1. The "Software", below, refers to asynDriver (in either source code, or
    binary form and accompanying documentation). Each licensee is
    addressed as "you" or "Licensee."

 2. The copyright holders shown above and their third-party licensors
    hereby grant Licensee a royalty-free nonexclusive license, subject to
    the limitations stated herein and U.S. Government license rights.

 3. You may modify and make a copy or copies of the Software for use
    within your organization, if you meet the following conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement.
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy.

 4. You may modify a copy or copies of the Software or any portion of it,
    thus forming a work based on the Software, and distribute copies of
    such work outside your organization, if you meet all of the following
    conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement;
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy;
      c. Modified copies and works based on the Software must carry
         prominent notices stating that you changed specified portions of
         the Software.

 5. Portions of the Software resulted from work developed under a U.S.
    Government contract and are subject to the following license: the
    Government is granted for itself and others acting on its behalf a
    paid-up, nonexclusive, irrevocable worldwide license in this computer
    software to reproduce, prepare derivative works, and perform publicly
    and display publicly.

 6. WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" WITHOUT WARRANTY
    OF ANY KIND. THE COPYRIGHT HOLDERS, THEIR THIRD PARTY LICENSORS, THE
    UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR
    EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE, TITLE OR NON-INFRINGEMENT, (2) DO NOT ASSUME
    ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
    OR USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE
    SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT
    THAT THE SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE
    OR THAT ANY ERRORS WILL BE CORRECTED.

 7. LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT HOLDERS, THEIR
    THIRD PARTY LICENSORS, THE UNITED STATES, THE UNITED STATES DEPARTMENT
    OF ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, INCIDENTAL,
    CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE,
    INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY
    REASON WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF
    CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR
    OTHERWISE, EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
    POSSIBILITY OF SUCH LOSS OR DAMAGES.</pre>
</body>
</html>
