<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>asynPortDriver</title>
</head>
<body>
  <div style="text-align: center">
    <h1>
      asynPortDriver</h1>
    <h1>
      C++ Base Class for Asyn Port Drivers</h1>
    <h2>
      February 6, 2009</h2>
    <h2>
      Mark Rivers</h2>
    <h2>
      University of Chicago</h2>
  </div>
  <p>
    asynPortDriver is a base C++ class that is designed to greatly simplify the task
    of writing an asyn port driver. It handles all of the details of registering the
    port driver, registering the supported interfaces, and registering the required
    interrupt sources.
  </p>
  <p>
    Drivers typically need to support a number of parameters that control their operation
    and provide status information. Most of these can be treated as 32-bit integers,
    64-bit floats, or strings. When the new value of a parameter is sent to a driver,
    (e.g. new D/A output value) from an asyn client (e.g. an EPICS record), then the
    driver will need to take some action. It may change some other parameters in response
    to this new value. The sequence of operations in the driver can be summarized as
  </p>
  <ol>
    <li>New parameter value arrives, or new data arrives from a device.</li>
    <li>Change values of one or more parameters.</li>
    <li>For each parameter whose value changes set a flag noting that it changed.</li>
    <li>When operation is complete, call the registered callbacks for each changed parameter.</li>
  </ol>
  <p>
    asynPortDriver provides methods to simplify the above sequence, which must be implemented
    for each of the often many parameters that the driver supports. Each parameter is
    assigned a number, which is the value in the pasynUser-&gt reason field that asyn
    clients pass to the driver when reading or writing that parameter. asynPortDriver
    maintains a table of parameter values, associating each parameter number with a
    data type (integer, double, or string), caching the current value, and maintaining
    a flag indicating if a value has changed. Drivers use asynPortDriver methods to
    read the current value from the table, and to set new values in the table. There
    is a method to call all registered callbacks for values that have changed since
    callbacks were last done.
  </p>
  <p>
    The following are the public definitions in the asynPortDriver class:
  </p>
  <pre>typedef struct {
    int param;
    const char *paramString;
} asynParamString_t;

#define asynCommonMask          0x00000001
#define asynDrvUserMask         0x00000002
#define asynOptionMask          0x00000004
#define asynInt32Mask           0x00000008
#define asyUInt32DigitalMask    0x00000010
#define asynFloat64Mask         0x00000020
#define asynOctetMask           0x00000040
#define asynInt8ArrayMask       0x00000080
#define asynInt16ArrayMask      0x00000100
#define asynInt32ArrayMask      0x00000200
#define asynFloat32ArrayMask    0x00000400
#define asynFloat64ArrayMask    0x00000800
#define asynGenericPointerMask  0x00001000

class asynPortDriver {
public:
    asynPortDriver(const char *portNameIn, int maxAddrIn, int paramTableSize, int interfaceMask, int interruptMask,
                   int asynFlags, int autoConnect, int priority, int stackSize);
    virtual ~asynPortDriver();
    virtual asynStatus getAddress(asynUser *pasynUser, const char *functionName, int *address); 
    virtual asynStatus findParam(asynParamString_t *paramTable, int numParams, const char *paramName, int *param);
    virtual asynStatus readInt32(asynUser *pasynUser, epicsInt32 *value);
    virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
    virtual asynStatus getBounds(asynUser *pasynUser, epicsInt32 *low, epicsInt32 *high);
    virtual asynStatus readFloat64(asynUser *pasynUser, epicsFloat64 *value);
    virtual asynStatus writeFloat64(asynUser *pasynUser, epicsFloat64 value);
    virtual asynStatus readOctet(asynUser *pasynUser, char *value, size_t maxChars,
                         size_t *nActual, int *eomReason);
    virtual asynStatus writeOctet(asynUser *pasynUser, const char *value, size_t maxChars,
                          size_t *nActual);
    virtual asynStatus readInt8Array(asynUser *pasynUser, epicsInt8 *value, 
                                        size_t nElements, size_t *nIn);
    virtual asynStatus writeInt8Array(asynUser *pasynUser, epicsInt8 *value,
                                        size_t nElements);
    virtual asynStatus doCallbacksInt8Array(epicsInt8 *value,
                                        size_t nElements, int reason, int addr);
    virtual asynStatus readInt16Array(asynUser *pasynUser, epicsInt16 *value,
                                        size_t nElements, size_t *nIn);
    virtual asynStatus writeInt16Array(asynUser *pasynUser, epicsInt16 *value,
                                        size_t nElements);
    virtual asynStatus doCallbacksInt16Array(epicsInt16 *value,
                                        size_t nElements, int reason, int addr);
    virtual asynStatus readInt32Array(asynUser *pasynUser, epicsInt32 *value,
                                        size_t nElements, size_t *nIn);
    virtual asynStatus writeInt32Array(asynUser *pasynUser, epicsInt32 *value,
                                        size_t nElements);
    virtual asynStatus doCallbacksInt32Array(epicsInt32 *value,
                                        size_t nElements, int reason, int addr);
    virtual asynStatus readFloat32Array(asynUser *pasynUser, epicsFloat32 *value,
                                        size_t nElements, size_t *nIn);
    virtual asynStatus writeFloat32Array(asynUser *pasynUser, epicsFloat32 *value,
                                        size_t nElements);
    virtual asynStatus doCallbacksFloat32Array(epicsFloat32 *value,
                                        size_t nElements, int reason, int addr);
    virtual asynStatus readFloat64Array(asynUser *pasynUser, epicsFloat64 *value,
                                        size_t nElements, size_t *nIn);
    virtual asynStatus writeFloat64Array(asynUser *pasynUser, epicsFloat64 *value,
                                        size_t nElements);
    virtual asynStatus doCallbacksFloat64Array(epicsFloat64 *value,
                                        size_t nElements, int reason, int addr);
    virtual asynStatus readGenericPointer(asynUser *pasynUser, void *pointer);
    virtual asynStatus writeGenericPointer(asynUser *pasynUser, void *pointer);
    virtual asynStatus doCallbacksGenericPointer(void *pointer, int reason, int addr);
    virtual asynStatus drvUserCreate(asynUser *pasynUser, const char *drvInfo, 
                                     const char **pptypeName, size_t *psize);
    virtual asynStatus drvUserGetType(asynUser *pasynUser,
                                        const char **pptypeName, size_t *psize);
    virtual asynStatus drvUserDestroy(asynUser *pasynUser);
    virtual void report(FILE *fp, int details);
    virtual asynStatus connect(asynUser *pasynUser);
    virtual asynStatus disconnect(asynUser *pasynUser);
   
    virtual asynStatus setIntegerParam(int index, int value);
    virtual asynStatus setIntegerParam(int list, int index, int value);
    virtual asynStatus setDoubleParam(int index, double value);
    virtual asynStatus setDoubleParam(int list, int index, double value);
    virtual asynStatus setStringParam(int index, const char *value);
    virtual asynStatus setStringParam(int list, int index, const char *value);
    virtual asynStatus getIntegerParam(int index, int * value);
    virtual asynStatus getIntegerParam(int list, int index, int * value);
    virtual asynStatus getDoubleParam(int index, double * value);
    virtual asynStatus getDoubleParam(int list, int index, double * value);
    virtual asynStatus getStringParam(int index, int maxChars, char *value);
    virtual asynStatus getStringParam(int list, int index, int maxChars, char *value);
    virtual asynStatus callParamCallbacks();
    virtual asynStatus callParamCallbacks(int list, int addr);
    virtual void reportParams();

    char *portName;
    int maxAddr;
    paramList **params;
    epicsMutexId mutexId;

    /* The asyn interfaces this driver implements */
    asynStandardInterfaces asynStdInterfaces;
    
    /* asynUser connected to ourselves for asynTrace */
    asynUser *pasynUserSelf;
};
</pre>
  <p>
    A brief explanation of the methods and data in this class is provided here. Users
    should look at the example driver in asyn (testAsynPortDriver) to see how this class
    is used. More complex examples can be found in the drivers and plugins provided
    with the <a href="http://cars.uchicago.edu/software/epics/areaDetector.html">areaDetector</a>
    module.
  </p>
  <pre>    asynPortDriver(const char *portNameIn, int maxAddrIn, int paramTableSize, int interfaceMask, int interruptMask,
                   int asynFlags, int autoConnect, int priority, int stackSize);

</pre>
  <p>
    This is the constructor for the class.
  </p>
  <ul>
    <li><code>portName</code> is the name of the asyn port for this driver or plugin.</li>
    <li><code>maxAddr</code> is the maximum number of asyn addresses that this driver
      supports. This number returned by the <code>pasynManager-&gt getAddr()</code> function.
      Often it is 1, but some drivers, for example a 16-channel D/A or A/D would support
      values &gt 1. This controls the number of parameter tables that are created.</li>
    <li><code>parmTableSize</code> is the maximum number of parameters that this driver
      supports. This controls the size of the parameter tables.</li>
    <li><code>interfaceMask</code> is a mask with each bit defining which asyn interfaces
      this driver or plugin supports. The bit mask values are defined in asynPortDriver.h,
      e.g. <code>asynInt32Mask</code>.</li>
    <li><code>interruptMask</code> is a mask with each bit defining which of the asyn
      interfaces this driver supports can generate callbacks (interrupts). The bit mask
      values are defined in asynPortDriver.h, e.g. <code>asynInt8ArrayMask</code>.</li>
    <li><code>asynFlags</code> is an attributes mask passed to pasynManager-&gt registerPort.
      The bits ASYN_CANBLOCK and ASYN_MULTIDEVICE are currently defined for this parameter.</li>
    <li><code>autoConnect</code> is passed to pasynManager-&gt registerPort. 1 if the
      driver should autoconnect.</li>
    <li><code>priority</code> is passed to pasynManager-&gt registerPort. If it is 0 then
      a default will be assigned.</li>
    <li><code>stackSize</code> is passed to pasynManager-&gt registerPort. If it is 0
      then a default will be assigned.</li>
  </ul>
  <pre>    virtual asynStatus getAddress(asynUser *pasynUser, const char *functionName, int *address); 
</pre>
  <p>
    Returns the value from pasynManager-&gt getAddr(pasynUser,...). Returns an error
    if the address is not valid, e.g. &gt= this-&gt maxAddr.
  </p>
  <pre>    virtual asynStatus readInt32(asynUser *pasynUser, epicsInt32 *value);
    virtual asynStatus readFloat64(asynUser *pasynUser, epicsFloat64 *value);
    virtual asynStatus readOctet(asynUser *pasynUser, char *value, size_t maxChars,
                             size_t *nActual, int *eomReason);
</pre>
  <p>
    These methods are called by asyn clients to return the current cached value for
    the parameter indexed by pasynUser-&gt reason in the parameter table defined by
    <code>getAddress()</code>. Derived classed typically do not need to implement these
    methods.
  </p>
  <pre>    virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
    virtual asynStatus writeFloat64(asynUser *pasynUser, epicsFloat64 value);
    virtual asynStatus writeOctet(asynUser *pasynUser, const char *value, size_t maxChars,
                          size_t *nActual);
</pre>
  <p>
    These methods are called by asynClients to set the new value of a parameter. The
    implementation of these methods in asynPortDriver copies the parameter into a cached
    location for use by the asynRead(Int32, Float64, and Octet) methods. Most drivers
    will provide their own implementations of these methods to do driver-dependent operations
    when there is a new value of the parameter. However, if none of the values written
    on a given interface, e.g. asynInt32, need to be acted upon immediately when they
    are written, but will only be accessed later using the cached values, then the driver
    does not need to implement this method and the base class method can be used.
  </p>
  <pre>     
    virtual asynStatus readXXXArray(asynUser *pasynUser, epicsInt8 *value, 
                                        size_t nElements, size_t *nIn);
    virtual asynStatus writeXXXArray(asynUser *pasynUser, epicsInt8 *value,
                                        size_t nElements);
    virtual asynStatus doCallbacksXXXArray(epicsInt8 *value,
                                        size_t nElements, int reason, int addr);
    virtual asynStatus readGenericPointer(asynUser *pasynUser, void *handle);
    virtual asynStatus writeGenericPointer(asynUser *pasynUser, void *handle);
    virtual asynStatus doCallbacksGenericPointer(void *handle, int reason, int addr);
</pre>
  <p>
    where XXX=(Int8, Int16, Int32, Float32, or Float64). The readXXX and writeXXX methods
    only have stub methods that return an error in asynPortDriver, so they must be implemented
    in the derived classes if the corresponding interface is used. They are not pure
    virtual functions so that the derived class need not implement the interface if
    it is not used. The doCallbacksXXX methods in asynPortDriver call any registered
    asyn clients on the corresponding interface if the <code>reason</code> and <code>addr</code>
    values match. It typically does not need to be implemented in derived classes.
  </p>
  <pre>     
    virtual asynStatus findParam(asynParamString_t *paramTable, int numParams, const char *paramName, int *param);
    virtual asynStatus drvUserCreate(asynUser *pasynUser, const char *drvInfo, 
                                     const char **pptypeName, size_t *psize);
    virtual asynStatus drvUserGetType(asynUser *pasynUser,
                                        const char **pptypeName, size_t *psize);
    virtual asynStatus drvUserDestroy(asynUser *pasynUser);
</pre>
  <p>
    drvUserCreate must be implemented in derived classes that use the parameter facilities
    of asynPortDriver. The <code>findParam</code> method is a convenience function that
    searches an array of asynParam_t structures ({enum, string}) and returns the enum
    (parameter number) matching the string. This is typically used in the implementation
    of <code>drvUserCreate</code> in derived classes. <code>drvUserGetType</code> and
    <code>drvUserDestroy</code> typically do not need to be implemented in derived classes.
  </p>
  <pre>     
    virtual void report(FILE *fp, int details);
    virtual asynStatus connect(asynUser *pasynUser);
    virtual asynStatus disconnect(asynUser *pasynUser);
</pre>
  <p>
    The <code>report</code> function prints information on registered interrupt clients
    if details &gt 0, and prints parameter table information if details &gt 5. It is
    typically called by the implementation of <code>report</code> in derived classes
    before or after they print specific information about themselves. <code>connect</code>
    and <code>disconnect</code> call <code>pasynManager-&gt exceptionConnect</code>
    and <code>pasynManager-&gt exceptionDisconnect</code> respectively. Derived classes
    may or may not need to implement these functions.
  </p>
  <pre>     
    virtual asynStatus setIntegerParam(int index, int value);
    virtual asynStatus setIntegerParam(int list, int index, int value);
    virtual asynStatus setDoubleParam(int index, double value);
    virtual asynStatus setDoubleParam(int list, int index, double value);
    virtual asynStatus setStringParam(int index, const char *value);
    virtual asynStatus setStringParam(int list, int index, const char *value);
    virtual asynStatus getIntegerParam(int index, int * value);
    virtual asynStatus getIntegerParam(int list, int index, int * value);
    virtual asynStatus getDoubleParam(int index, double * value);
    virtual asynStatus getDoubleParam(int list, int index, double * value);
    virtual asynStatus getStringParam(int index, int maxChars, char *value);
    virtual asynStatus getStringParam(int list, int index, int maxChars, char *value);
    virtual asynStatus callParamCallbacks();
    virtual asynStatus callParamCallbacks(int list, int addr);
</pre>
  <p>
    The <code>setXXXParam</code> methods set the value of a parameter in the parameter
    table in the object. If the value is different from the previous value of the parameter
    they also set the flag indicating that the value has changed. The <code>getXXXParam</code>
    methods return the current value of the parameter. There are two versions of the
    <code>setXXXParam</code> and <code>getXXXParam</code> methods, one with a <code>list</code>
    argument, and one without. The one without uses <code>list=0</code>, since there
    is often only a single parameter list (i.e. if maxAddr=1). The <code>callParamCallbacks</code>
    methods call back any registered clients for parameters that have changed since
    the last time <code>callParamCallbacks</code> was called. The version of <code>callParamCallbacks</code>
    with no arguments uses the first parameter list and matches asyn address=0. There
    is a second version of <code>callParamCallbacks</code> that takes an argument specifying
    the parameter list number, and the asyn address to match.
  </p>
 <h2>Example driver - testAsynPortDriver</h2>
 <p>An example driver using the asynPortDriver class is provided in the testAsynPortDriverApp application
 in asyn.  This example is a simple digital oscilloscope emulator.  In this example all of output control
 and input data is done in a calculated simulation.  But it is easy to see how to use the driver as a basis
 for real device control.  The code doing the simulation would simply be changed to talk to an actual device. 
 This could be done using the asyn serial or IP drivers via the asynOctetSyncIO interface (because at this
 driver level blocking is permitted), or via VME register access, or any other I/O mechanism.
 <p>This is the medm screen for controlling this example application.  It is started in the
    testAsynPortDriverApp/adl directory with the command:
 <pre>
 medm -x -macro "P=testAPD:, R=scope1:" testAsynPortDriver.adl &
 </pre>
   <div style="text-align: center">
    <h3>
      testAsynPortDriver.adl</h3>
    <p>
      <img alt="testAsynPortDriver.png" src="testAsynPortDriver.png" /></p>
  </div>
<p>The simulated scope input is a noisy 1kHz sin wave with an amplitude of +-1V.  
The amplitude of the noise is an adjustable parameter.  The scope parameters that can
be adjusted are the vertical volts/division, vertical volt offset, horizontal time/division,
trigger delay (relative to time=0 for the sin wave). The minimum, maximum and mean values
of the waveform are calculated.  The run/stop control turns the simulation of the waveform
on and off. The update time in seconds controls the rate at which the waveform and statistics
are calculated.  By default all of the EPICS input records are I/O Intr scanned.  There is
a control on the medm screen to change the scan rate of the waveform record itself.  By default
it is also I/O Intr scanned, so the plot updates on every simulation.  One can change this to,
for example, 1 second, and then the simulation can be running faster (for example 50 Hz, 
Update time=.02) so the statistics will update quickly but the waveform at only 1Hz to save CPU time and
network bandwidth.</p>
<p>This driver supports about 20 EPICS records, including ao, ai, bo, bi, and waveform.  It does callbacks 
to device support when any of the input records changes, so the records can use I/O Intr scanning rather
than polling.  It uses only the standard asyn EPICS record device support provided as part of asyn.  Yet the driver
is only about 400 lines of well-commented C++ code, because so much of the infrastructure is handled 
by the asynPortDriver base class.</p>
<p> Here are the important lines from the startup script to start this IOC:</p>
<pre>
testAsynPortDriverConfigure("testAPD", 1000)
dbLoadRecords("../../db/testAsynPortDriver.db","P=testAPD:,R=scope1:,PORT=testAPD,ADDR=0,TIMEOUT=1,NPOINTS=1000")
</pre>
<p>The first line starts the asyn port driver with a 1000 point waveform. The second line loads
the database.  The PORT parameter is the name of the asyn port created in the first line.  The ADDR
parameter is 0 because this driver is not ASYN_MULTIDEVICE, it only supports a single address.
The TIMEOUT parameter is not really significant because this is a synchronous asyn port driver,
i.e. ASYN_CANBLOCK=0.  NPOINTS is the value for NELM in the waveform record in the database.  It would
normally match the value provided in the configure command above.</p>

<p>This is an example of 2 of the record definitions in the database file, testAsynPortDriver.db.</p>
<pre>
###################################################################
#  These records are the time per division                        #
###################################################################
record(ao, "$(P)$(R)TimePerDiv")
{
   field(PINI, "1")
   field(DTYP, "asynFloat64")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))TIME_PER_DIV")
   field(PREC, "5")
}

record(ai, "$(P)$(R)TimePerDiv_RBV")
{
   field(PINI, "1")
   field(DTYP, "asynFloat64")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))TIME_PER_DIV")
   field(PREC, "5")
   field(SCAN, "I/O Intr")
}
</pre>
Note that there is both an output record and an input record for this parameter, the time per
horizontal division.  This is done so that if the driver is forced to modify a parameter (for
example because the device cannot support the output value it received) there is
feedback to the user on the actual value being used.  In this case the ai record will always
be the same as the ao record.  But in the case of the update time parameter the driver
enforces a minimum time of 0.02 seconds, so that if a value less than this is requested
the ao and ai records will not agree.  In that particular case DRVL could be used to enforce that
limit at the ao record level, but this is not always the case, because device limits can vary
with the value of other parameters.</p>
<p>The DTYP field of these records is asynFloat64, which uses the standard asyn device support
for ao and ai records, provided in asyn/devEpics/devAsynFloat64.c.</p>
<p>The OUT and INP fields use the PORT, ADDR and TIMEOUT values described above. The final parameter,
TIME_PER_DIV in these fields is used by the driver to identify which driver parameter these records
are connected to.  This is the asyn drvUser parameter, and is discussed below.
<p>Finally, note that the ai record has SCAN=I/O Intr.  This means that this record does not have
to be periodically scanned (which is inefficient), but rather it will be processed whenever
its value is changed by the driver.  For the ai statistics records (min, max, mean) in this
example record callbacks occur every time the simulation runs if the noise is non-zero.</p>
<p>
<p>This is the definition of the testAsynPortDriver class:</p>
<pre>
class testAsynPortDriver : public asynPortDriver {
public:
    testAsynPortDriver(const char *portName, int maxArraySize);
                 
    /* These are the methods that we override from asynPortDriver */
    virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
    virtual asynStatus writeFloat64(asynUser *pasynUser, epicsFloat64 value);
    virtual asynStatus readFloat64Array(asynUser *pasynUser, epicsFloat64 *value,
                                        size_t nElements, size_t *nIn);
    virtual asynStatus drvUserCreate(asynUser *pasynUser, const char *drvInfo, 
                                     const char **pptypeName, size_t *psize);
                                     
    /* These are the methods that are new to this class */
    void simTask(void);
    
    /* Our data */
    epicsEventId eventId;
    epicsFloat64 *pData;
    epicsFloat64 *pTimeBase;
};
</pre>
<p>testAsynPortDriver is derived from asynPortDriver.  It overrides the methods writeInt32, writeFloat64,
readFloat64Array, and drvUserCreate.  It adds a new method, simTask, which runs a separate thread
to compute the waveform at the specified update time.</p>
<p>
This is the how the parameters are defined in the driver, testAsynPortDriver.cpp</p>
<pre>
typedef enum {
    P_Run,                /* asynInt32,    r/w */
    P_MaxPoints,          /* asynInt32,    r/o */
    P_TimePerDivision,    /* asynFloat64,  r/w */
    P_VoltsPerDivision,   /* asynFloat64,  r/w */
    P_VoltOffset,         /* asynFloat64,  r/w */
    P_TriggerDelay,       /* asynFloat64,  r/w */
    P_NoiseAmplitude,     /* asynFloat64,  r/w */
    P_UpdateTime,         /* asynFloat64,  r/w */
    P_Waveform,           /* asynFloat64Array,  r/o */
    P_TimeBase,           /* asynFloat64Array,  r/o */
    P_MinValue,           /* asynFloat64,  r/o */
    P_MaxValue,           /* asynFloat64,  r/o */
    P_MeanValue           /* asynFloat64,  r/o */
} testParams;

/* The command strings are the userParam argument for asyn device support links
 * The asynDrvUser interface in this driver parses these strings and puts the
 * corresponding enum value in pasynUser->reason */
static asynParamString_t driverParamString[] = {
    {P_Run,              "RUN"            },
    {P_MaxPoints,        "MAX_POINTS"     },
    {P_TimePerDivision,  "TIME_PER_DIV"   },
    {P_VoltsPerDivision, "VOLTS_PER_DIV"  },
    {P_VoltOffset,       "VOLT_OFFSET"    },
    {P_TriggerDelay,     "TRIGGER_DELAY"  },
    {P_NoiseAmplitude,   "NOISE_AMPLITUDE"},
    {P_UpdateTime,       "UPDATE_TIME"    },
    {P_Waveform,         "WAVEFORM"       },
    {P_TimeBase,         "TIME_BASE"      },
    {P_MinValue,         "MIN_VALUE"      },
    {P_MaxValue,         "MAX_VALUE"      },
    {P_MeanValue,        "MEAN_VALUE"     }
};

#define NUM_DRIVER_PARAMS (sizeof(driverParamString)/sizeof(driverParamString[0]))

</pre>
<p>Note that each parameter is assigned an enum value that identifies it.  It is also associated with a string
that is used in the drvUser field of the record INP or OUT fields to associate a record with a parameter.</p>
<p>This is the beginning of the constructor for the testAsynPortDriver C++ class.</p>
<pre>
testAsynPortDriver::testAsynPortDriver(const char *portName, int maxPoints) 
   : asynPortDriver(portName, 
                    1, /* maxAddr */ 
                    NUM_DRIVER_PARAMS,
                    asynInt32Mask | asynFloat64Mask | asynFloat64ArrayMask | asynDrvUserMask, /* Interface mask */
                    asynInt32Mask | asynFloat64Mask | asynFloat64ArrayMask,  /* Interrupt mask */
                    0, /* asynFlags.  This driver does not block and it is not multi-device, so flag is 0 */
                    1, /* Autoconnect */
                    0, /* Default priority */
                    0) /* Default stack size*/    
...
</pre>
<p>It invoke the constructor for the asynPortDriver base class.  It passes:</p>
<ul>
  <li>The portName, which is the name of the asyn port to be created.  In the st.cmd file above this
  is "testAPD".</li>
  <li>The maximum number of asyn addresses that this driver supports, which is 1.</li>
  <li>The number of parameters that this driver supports.  This is NUM_DRIVER_PARAMS, which was computed
    above from the size of the <code>driverParamString</code> array.</li>
  <li>A mask which defines which asyn interfaces this driver supports, in this case asynInt32, asynFloat64,
    asynFloat64Array, and asynDrvUser.  All drivers must support asynCommon, so that bit is added in the base
    class</li>.
  <li>A mask which defines which asyn interfaces can generate interrupts (callbacks).  In this case that
    is asynInt32, asynFloat64, and asynFloat64Array.</li>
  <li>A mask which defines the asyn attributes for this driver.  asyn current defines two attribute bits,
    ASYN_CANBLOCK and ASYN_MULTIDEVICE.  ASYN_CANBLOCK must be set for drivers that perform "slow" operations
    on their interfaces, requiring asynManager to create a separate port thread for them and to use
    asynchronous device support.  ASYN_MULTIDEVICE must be set for drivers that support more than one asyn 
    address, for example a driver used to support a 16-channel A/D converter.</li>
  <li>A flag to tell asynManager that it should automatically attempt to connect to this device when a call is made
    on its interfaces.  This results in a call to asynCommon-&gt&connect().</li>
  <li>A priority flag for the port thread that asynManager will create is ASYN_CANBLOCK is 1.  If this
    is 0 then asyn will use a default medium thread priority.</li>
  <li>The stack size for the port thread that asynManager will create is ASYN_CANBLOCK is 1.  If this
    is 0 then asyn will use a default medium thread stack size.</li>
</ul>
<p>The constructor also allocates spaces for the waveform arrays (X and Y axes), and creates the simTask thread.</p>
<p>This is the implementation of the writeFloat64 function:</p>
<pre>
asynStatus testAsynPortDriver::writeFloat64(asynUser *pasynUser, epicsFloat64 value)
{
    int function = pasynUser->reason;
    asynStatus status = asynSuccess;
    int run;
    const char* functionName = "writeFloat64";

    /* Set the parameter in the parameter library. */
    status = (asynStatus) setDoubleParam(function, value);

    switch(function) {
        case P_UpdateTime:
            /* Make sure the update time is valid. If not change it and put back in parameter library */
            if (value < MIN_UPDATE_TIME) {
                value = MIN_UPDATE_TIME;
                setDoubleParam(P_UpdateTime, value);
            }
            /* If the update time has changed and we are running then wake up the simulation task */
            getIntegerParam(P_Run, &run);
            if (run) epicsEventSignal(this->eventId);
            break;
        default:
            /* All other parameters just get set in parameter list, no need to
             * act on them here */
            break;
    }
    
    /* Do callbacks so higher layers see any changes */
    status = (asynStatus) callParamCallbacks();
    
    if (status) 
        epicsSnprintf(pasynUser->errorMessage, pasynUser->errorMessageSize, 
                  "%s:%s: status=%d, function=%d, value=%f", 
                  driverName, functionName, status, function, value);
    else        
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, 
              "%s:%s: function=%d, value=%f\n", 
              driverName, functionName, function, value);
    return status;
}
</pre>
<p>This is what is being performed in this function:</p>
<ul>
  <li>The pasynUser-&gt reason field is used to get the value of <code>function</code>.  This is
    one of the testParams enum values (e.g. P_TimePerDivision).  It was placed in the pasynUser-&gt reason
    field by this driver's drvUserCreate method that was called at iocInit, and was passed the drvUser field from the
    record link, e.g. "TIME_PER_DIV".</li>
  <li>The value passed is set in the parameter list with <code>setDoubleParam</code>.</li>
  <li>A switch statement processes each of the parameters differently.  In this case only one float64 parameter,
    P_UpdateTime, needs to actually have any action taken in this function.  All other parameters just have their
    values set in the parameter list for later use.</li>
  <li>For P_Update time the value is checked for validity to make sure it is greater than MIN_UPDATE_TIME.  If
  not then the value is changed, and the new value is written to the parameter list.  This new value
  will be passed in callbacks to any callback clients, for example an ai record that is monitoring
  this parameter.  The function then retrieves the value of the P_Run parameter from the parameter list,
  and if it is 1 it sends an EPICS event signal to wake up the simTask.  This is done so that if the update
  time is changed from a very long value to a shorter one then it does not wait for the long timer to
  expire.</li>
  <li><code>callParamCallbacks()</code> is called, which results in callbacks to all registered clients
    for any parameters that have changed as a result of this function call.  In this case the only parameter
    that will have changed is whatever parameter was passed in pasynUser-&gt reason, but in general other
    parameters could have changed as a side-effect of changing this parameter.</li>
  <li>Diagnostic information is optionally printed for both error and success status.</li>
</ul>
<p>The <code>writeInt32</code> function is very similar.</p>
<p>Finally here is the <code>simTask</code> function, which actually does the simulation.  It runs in a 
separate thread created in the constuctor:</p>
<pre>
void testAsynPortDriver::simTask(void)
{
    /* This thread computes the waveform and does callbacks with it */

    double timePerDivision, voltsPerDivision, voltOffset, triggerDelay, noiseAmplitude;
    double updateTime, minValue, maxValue, meanValue;
    double time, timeStep;
    double noise, yScale;
    int run, i, maxPoints;
    double pi=4.0*atan(1.0);
    
    /* Loop forever */    
    while (1) {
        getDoubleParam(P_UpdateTime, &updateTime);
        getIntegerParam(P_Run, &run);
        if (run) epicsEventWaitWithTimeout(this->eventId, updateTime);
        else     epicsEventWait(this->eventId);
        /* run could have changed while we were waiting */
        getIntegerParam(P_Run, &run);
        if (!run) continue;
        getIntegerParam(P_MaxPoints,        &maxPoints);
        getDoubleParam (P_TimePerDivision,  &timePerDivision);
        getDoubleParam (P_VoltsPerDivision, &voltsPerDivision);
        getDoubleParam (P_VoltOffset,       &voltOffset);
        getDoubleParam (P_TriggerDelay,     &triggerDelay);
        getDoubleParam (P_NoiseAmplitude,   &noiseAmplitude);
        time = triggerDelay;
        timeStep = timePerDivision * NUM_DIVISIONS / maxPoints;
        minValue = 1e6;
        maxValue = -1e6;
        meanValue = 0.;
    
        yScale = 1.0 / voltsPerDivision;
        for (i=0; i<maxPoints; i++) {
            noise = noiseAmplitude * (rand()/(double)RAND_MAX - 0.5);
            pData[i] = AMPLITUDE * (sin(time*FREQUENCY*2*pi)) + noise;
            /* Compute statistics before doing the yOffset and yScale */
            if (pData[i] < minValue) minValue = pData[i];
            if (pData[i] > maxValue) maxValue = pData[i];
            meanValue += pData[i];
            pData[i] = NUM_DIVISIONS/2 + yScale * (voltOffset + pData[i]);
            time += timeStep;
        }
        meanValue = meanValue/maxPoints;
        setDoubleParam(P_MinValue, minValue);
        setDoubleParam(P_MaxValue, maxValue);
        setDoubleParam(P_MeanValue, meanValue);
        callParamCallbacks();
        doCallbacksFloat64Array(pData, maxPoints, P_Waveform, 0);
    }
}
</pre>
<p>Here are the important aspects of this function:</p>
<ul>
  <li>The value of <code>P_Run</code> determines whether the simulation is running or stopped.  If stopped
  it simply waits for a signal (from the <code>writeInt32()</code> function) to start running.  If running
  it waits for the update time, or until it receives a signal, which will occur if the update time
  is changed in the <code>writeFloat64()</code> function.</li>
  <li>It reads the values of the simulation parameters (<code>P_TimePerDivision</code>, etc.) from the parameter list.</li>
  <li>It computes each point in the waveform inside the <code>for</code> loop, using the current
  values of the simulation parameters.  It also updates the statistics parameters (min, max, mean) inside
  this loop.</li>
  <li>After the loop is done the new values of the statistics parameters are written to the parameter list
  with <code>setDoubleParam()</code>.
  <li>New values of all scalar parameters (int32, float64, string) in the parameter list are sent to registered clients
  (e.g. asyn device support for input records) with the call to <code>callParamCallbacks()</code>.</li>
  <li>The new value of the waveform is sent to registered clients (e.g. device support for the waveform input
  record) with the call to <code>doCallbacksFloat64Array()</code>.</li> 
</ul>
<p>Real drivers may or may not need such a separate thread.  Drivers that need to periodically poll status
information will probably use one.  Most drivers will probably implement one or more of the 
<code>writeInt32()</code>, <code>writeFloat64()</code>, or <code>writeOctet()</code> functions, 
in addition to <code>drvUserCreate()<code/>.</p>
</body>
</html>
