<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>asynDriver &mdash; asyn support</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/my_theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=5929fcd5"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="asynPortDriver" href="asynPortDriver.html" />
    <link rel="prev" title="asyn" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            asyn
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">asynDriver</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#license-agreement">License Agreement</a></li>
<li class="toctree-l2"><a class="reference internal" href="#purpose">Purpose</a></li>
<li class="toctree-l2"><a class="reference internal" href="#status">Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="#acknowledgments">Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="#overview-of-asyndriver">Overview of asynDriver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#standard-interfaces">Standard Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generic-interfaces">Generic Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynmanager">asynManager</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#reporting">reporting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#asynuser-creation">asynUser creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-asynuser-services">Basic asynUser services</a></li>
<li class="toctree-l4"><a class="reference internal" href="#queuing-services">Queuing services</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-driver-services">Basic Driver services</a></li>
<li class="toctree-l4"><a class="reference internal" href="#attribute-retrieval">Attribute Retrieval</a></li>
<li class="toctree-l4"><a class="reference internal" href="#connection-services">Connection services</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exception-services">Exception services</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interrupt-services">Interrupt services</a></li>
<li class="toctree-l4"><a class="reference internal" href="#timestamp-services">Timestamp services</a></li>
<li class="toctree-l4"><a class="reference internal" href="#general-purpose-freelist-service">General purpose freelist service</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interpose-service">Interpose service</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-device-vs-single-device-port-drivers">Multiple Device vs Single Device Port Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#connection-management">Connection Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#protecting-a-thread-from-blocking">Protecting a Thread from Blocking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#portthread">portThread</a></li>
<li class="toctree-l3"><a class="reference internal" href="#overview-of-queuing">Overview of Queuing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#theory-of-operation">Theory of Operation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#initialization">Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#requesting-access-to-a-port">Requesting access to a port</a></li>
<li class="toctree-l3"><a class="reference internal" href="#queuerequest-flow-of-control">queueRequest - Flow of Control</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#asyndriver-structures-and-interfaces">asynDriver Structures and Interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#asynstatus">asynStatus</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynexception">asynException</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynqueuepriority">asynQueuePriority</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynuser">asynUser</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asyninterface">asynInterface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">asynManager</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asyncommon">asynCommon</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asyncommonsyncio">asynCommonSyncIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asyndrvuser">asynDrvUser</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynlockportnotify">asynLockPortNotify</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynoption">asynOption</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asyntrace">asynTrace</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#standard-message-based-interfaces">Standard Message Based Interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#asynoctet">asynOctet</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynoctetsyncio">asynOctetSyncIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="#end-of-string-support">End of String Support</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#standard-register-based-interfaces">Standard Register Based Interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-drivers">Example Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynintxx-xx-32-or-64">asynIntXX (XX=32 or 64)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynintxxsyncio-xx-32-or-64">asynIntXXSyncIO (XX=32 or 64)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynuint32digital">asynUInt32Digital</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynuint32digitalsyncio">asynUInt32DigitalSyncIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynfloat64">asynFloat64</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynfloat64syncio">asynFloat64SyncIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynxxxarray-xxx-int8-int16-int32-int64-float32-or-float64">asynXXXArray (XXX=Int8, Int16, Int32, Int64, Float32 or Float64)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynxxxarraysyncio">asynXXXArraySyncIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynenum">asynEnum</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynenumsyncio">asynEnumSyncIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asyngenericpointer">asynGenericPointer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asyngenericpointersyncio">asynGenericPointerSyncIO</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#asynstandardinterfacesbase">asynStandardInterfacesBase</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#asynstandardinterfaces-structure">asynStandardInterfaces structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynstandardinterfacesbase-interface">asynStandardInterfacesBase interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#standard-interpose-interfaces">Standard Interpose Interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#asyninterposeeos">asynInterposeEos</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asyninterposeflush">asynInterposeFlush</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asyninterposecom">asynInterposeCom</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asyninterposedelay">asynInterposeDelay</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asyninterposeecho">asynInterposeEcho</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#generic-device-support-for-epics-records">Generic Device Support for EPICS records</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#asynmanager-interrupts-and-epics-device-support">asynManager interrupts and EPICS device support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initial-values-of-output-records">Initial values of output records</a></li>
<li class="toctree-l3"><a class="reference internal" href="#enum-values-for-bi-bo-mbbi-and-mbbo-records">Enum values for bi, bo, mbbi, and mbbo records</a></li>
<li class="toctree-l3"><a class="reference internal" href="#callback-updates-for-output-records">Callback updates for output records</a></li>
<li class="toctree-l3"><a class="reference internal" href="#buffering-of-driver-callbacks">Buffering of driver callbacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#time-stamps">Time stamps</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynint32-device-support">asynInt32 device support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynint64-device-support">asynInt64 device support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynintxxxarray-device-support-xxx-8-16-32-or-64">asynIntXXXArray device support (XXX=8, 16, 32, or 64)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynxxxtimeseries-device-support-xxx-int32-int64-or-float64">asynXXXTimeSeries device support (XXX=Int32, Int64, or Float64)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynuint32digital-device-support">asynUInt32Digital device support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynfloat64-device-support">asynFloat64 device support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynfloatxxxarray-device-support-xxx-32-or-64">asynFloatXXXArray device support (XXX=32 or 64)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynoctet-device-support">asynOctet device support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#record-alarms">Record alarms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#asynrecord-generic-epics-record-support">asynRecord: Generic EPICS Record Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="#asyngpib">asynGpib</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#asyngpibdriver-h">asynGpibDriver.h</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">asynGpib</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asyngpibport">asynGpibPort</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#port-drivers">Port Drivers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#local-serial-port">Local Serial Port</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tcp-ip-or-udp-ip-port">TCP/IP or UDP/IP Port</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tcp-ip-server">TCP/IP Server</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vxi-11">VXI-11</a></li>
<li class="toctree-l3"><a class="reference internal" href="#drvprologixgpib">drvPrologixGPIB</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linux-gpib">Linux-Gpib</a></li>
<li class="toctree-l3"><a class="reference internal" href="#green-springs-ip488">Green Springs IP488</a></li>
<li class="toctree-l3"><a class="reference internal" href="#national-instruments-gpib-1014d">National Instruments GPIB-1014D</a></li>
<li class="toctree-l3"><a class="reference internal" href="#usb-tmc-test-and-measurement-class-driver">USB TMC (Test and Measurement Class) driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#non-octet-records">Non-octet records</a></li>
<li class="toctree-l4"><a class="reference internal" href="#service-request-srq-handling">Service Request (SRQ) handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-status-byte-stb">Device Status Byte (STB)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#remote-enable-ren">Remote Enable (REN)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#local-lockout-llo">Local Lockout (LLO)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#go-to-local-gtl">Go To Local (GTL)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linux-udev-configuration">Linux udev configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#streamdevice-exception-handlers">StreamDevice Exception Handlers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ftdi-port">FTDI Port</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#asynportdriver-c-base-class">asynPortDriver C++ base class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#asynportclient-c-classes">asynPortClient C++ classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#diagnostic-aids">Diagnostic Aids</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#iocsh-commands">iocsh Commands</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#example-client">Example Client</a></li>
<li class="toctree-l2"><a class="reference internal" href="#test-applications">Test Applications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#testapp">testApp</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testarrayringbufferapp">testArrayRingBufferApp</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testasynportclientapp">testAsynPortClientApp</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testbroadcastapp">testBroadcastApp</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#testbroadcastasyn-c">testBroadcastAsyn.c</a></li>
<li class="toctree-l4"><a class="reference internal" href="#testbroadcastnoasyn-c">testBroadcastNoAsyn.c</a></li>
<li class="toctree-l4"><a class="reference internal" href="#testbroadcastburst-c">testBroadcastBurst.c</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#testconnectapp">testConnectApp</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testepicsapp">testEpicsApp</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testerrorsapp">testErrorsApp</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#install-and-build">Install and Build</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#install-and-build-asyndriver">Install and Build asynDriver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-asyndriver-components-with-an-epics-ioccore-application">Using asynDriver Components with an EPICS iocCore Application</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id3">License Agreement</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="asynPortDriver.html">asynPortDriver</a></li>
<li class="toctree-l1"><a class="reference internal" href="asynPortClient.html">asynPortClient</a></li>
<li class="toctree-l1"><a class="reference internal" href="asynRecord.html">asyn Record</a></li>
<li class="toctree-l1"><a class="reference internal" href="asynTimeStampSupport.html">asyn Timestamp Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="asynRecordControl.html">asyn Record I/O Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="HowToDoSerial.html">HowToDoSerial (StreamDevice)</a></li>
<li class="toctree-l1"><a class="reference internal" href="devGpib.html">devGpib (obsolete)</a></li>
<li class="toctree-l1"><a class="reference internal" href="doxygen.html">Doxygen documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">asyn</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">asynDriver</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/asynDriver.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="asyndriver">
<h1><a class="toc-backref" href="#id61" role="doc-backlink">asynDriver</a><a class="headerlink" href="#asyndriver" title="Link to this heading"></a></h1>
<dl class="field-list simple">
<dt class="field-odd">author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Mark Rivers, Eric Norum, and Marty Kraimer</p>
</dd>
<dt class="field-even">date<span class="colon">:</span></dt>
<dd class="field-even"><p>March 28, 2023</p>
</dd>
<dt class="field-odd">version<span class="colon">:</span></dt>
<dd class="field-odd"><p>R4-44-2</p>
</dd>
</dl>
<section id="license-agreement">
<h2><a class="toc-backref" href="#id62" role="doc-backlink">License Agreement</a><a class="headerlink" href="#license-agreement" title="Link to this heading"></a></h2>
<p>This product is available via the open source license
described at the end of this document.</p>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#asyndriver" id="id61">asynDriver</a></p>
<ul>
<li><p><a class="reference internal" href="#license-agreement" id="id62">License Agreement</a></p></li>
<li><p><a class="reference internal" href="#purpose" id="id63">Purpose</a></p></li>
<li><p><a class="reference internal" href="#status" id="id64">Status</a></p></li>
<li><p><a class="reference internal" href="#acknowledgments" id="id65">Acknowledgments</a></p></li>
<li><p><a class="reference internal" href="#overview-of-asyndriver" id="id66">Overview of asynDriver</a></p>
<ul>
<li><p><a class="reference internal" href="#definitions" id="id67">Definitions</a></p></li>
<li><p><a class="reference internal" href="#standard-interfaces" id="id68">Standard Interfaces</a></p></li>
<li><p><a class="reference internal" href="#generic-interfaces" id="id69">Generic Interfaces</a></p></li>
<li><p><a class="reference internal" href="#asynmanager" id="id70">asynManager</a></p>
<ul>
<li><p><a class="reference internal" href="#reporting" id="id71">reporting</a></p></li>
<li><p><a class="reference internal" href="#asynuser-creation" id="id72">asynUser creation</a></p></li>
<li><p><a class="reference internal" href="#basic-asynuser-services" id="id73">Basic asynUser services</a></p></li>
<li><p><a class="reference internal" href="#queuing-services" id="id74">Queuing services</a></p></li>
<li><p><a class="reference internal" href="#basic-driver-services" id="id75">Basic Driver services</a></p></li>
<li><p><a class="reference internal" href="#attribute-retrieval" id="id76">Attribute Retrieval</a></p></li>
<li><p><a class="reference internal" href="#connection-services" id="id77">Connection services</a></p></li>
<li><p><a class="reference internal" href="#exception-services" id="id78">Exception services</a></p></li>
<li><p><a class="reference internal" href="#interrupt-services" id="id79">Interrupt services</a></p></li>
<li><p><a class="reference internal" href="#timestamp-services" id="id80">Timestamp services</a></p></li>
<li><p><a class="reference internal" href="#general-purpose-freelist-service" id="id81">General purpose freelist service</a></p></li>
<li><p><a class="reference internal" href="#interpose-service" id="id82">Interpose service</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#multiple-device-vs-single-device-port-drivers" id="id83">Multiple Device vs Single Device Port Drivers</a></p></li>
<li><p><a class="reference internal" href="#connection-management" id="id84">Connection Management</a></p></li>
<li><p><a class="reference internal" href="#protecting-a-thread-from-blocking" id="id85">Protecting a Thread from Blocking</a></p></li>
<li><p><a class="reference internal" href="#portthread" id="id86">portThread</a></p></li>
<li><p><a class="reference internal" href="#overview-of-queuing" id="id87">Overview of Queuing</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#theory-of-operation" id="id88">Theory of Operation</a></p>
<ul>
<li><p><a class="reference internal" href="#initialization" id="id89">Initialization</a></p></li>
<li><p><a class="reference internal" href="#requesting-access-to-a-port" id="id90">Requesting access to a port</a></p></li>
<li><p><a class="reference internal" href="#queuerequest-flow-of-control" id="id91">queueRequest - Flow of Control</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#asyndriver-structures-and-interfaces" id="id92">asynDriver Structures and Interfaces</a></p>
<ul>
<li><p><a class="reference internal" href="#asynstatus" id="id93">asynStatus</a></p></li>
<li><p><a class="reference internal" href="#asynexception" id="id94">asynException</a></p></li>
<li><p><a class="reference internal" href="#asynqueuepriority" id="id95">asynQueuePriority</a></p></li>
<li><p><a class="reference internal" href="#asynuser" id="id96">asynUser</a></p></li>
<li><p><a class="reference internal" href="#asyninterface" id="id97">asynInterface</a></p></li>
<li><p><a class="reference internal" href="#id1" id="id98">asynManager</a></p></li>
<li><p><a class="reference internal" href="#asyncommon" id="id99">asynCommon</a></p></li>
<li><p><a class="reference internal" href="#asyncommonsyncio" id="id100">asynCommonSyncIO</a></p></li>
<li><p><a class="reference internal" href="#asyndrvuser" id="id101">asynDrvUser</a></p></li>
<li><p><a class="reference internal" href="#asynlockportnotify" id="id102">asynLockPortNotify</a></p></li>
<li><p><a class="reference internal" href="#asynoption" id="id103">asynOption</a></p></li>
<li><p><a class="reference internal" href="#asyntrace" id="id104">asynTrace</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#standard-message-based-interfaces" id="id105">Standard Message Based Interfaces</a></p>
<ul>
<li><p><a class="reference internal" href="#asynoctet" id="id106">asynOctet</a></p></li>
<li><p><a class="reference internal" href="#asynoctetsyncio" id="id107">asynOctetSyncIO</a></p></li>
<li><p><a class="reference internal" href="#end-of-string-support" id="id108">End of String Support</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#standard-register-based-interfaces" id="id109">Standard Register Based Interfaces</a></p>
<ul>
<li><p><a class="reference internal" href="#introduction" id="id110">Introduction</a></p></li>
<li><p><a class="reference internal" href="#example-drivers" id="id111">Example Drivers</a></p></li>
<li><p><a class="reference internal" href="#asynintxx-xx-32-or-64" id="id112">asynIntXX (XX=32 or 64)</a></p></li>
<li><p><a class="reference internal" href="#asynintxxsyncio-xx-32-or-64" id="id113">asynIntXXSyncIO (XX=32 or 64)</a></p></li>
<li><p><a class="reference internal" href="#asynuint32digital" id="id114">asynUInt32Digital</a></p></li>
<li><p><a class="reference internal" href="#asynuint32digitalsyncio" id="id115">asynUInt32DigitalSyncIO</a></p></li>
<li><p><a class="reference internal" href="#asynfloat64" id="id116">asynFloat64</a></p></li>
<li><p><a class="reference internal" href="#asynfloat64syncio" id="id117">asynFloat64SyncIO</a></p></li>
<li><p><a class="reference internal" href="#asynxxxarray-xxx-int8-int16-int32-int64-float32-or-float64" id="id118">asynXXXArray (XXX=Int8, Int16, Int32, Int64, Float32 or Float64)</a></p></li>
<li><p><a class="reference internal" href="#asynxxxarraysyncio" id="id119">asynXXXArraySyncIO</a></p></li>
<li><p><a class="reference internal" href="#asynenum" id="id120">asynEnum</a></p></li>
<li><p><a class="reference internal" href="#asynenumsyncio" id="id121">asynEnumSyncIO</a></p></li>
<li><p><a class="reference internal" href="#asyngenericpointer" id="id122">asynGenericPointer</a></p></li>
<li><p><a class="reference internal" href="#asyngenericpointersyncio" id="id123">asynGenericPointerSyncIO</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#asynstandardinterfacesbase" id="id124">asynStandardInterfacesBase</a></p>
<ul>
<li><p><a class="reference internal" href="#asynstandardinterfaces-structure" id="id125">asynStandardInterfaces structure</a></p></li>
<li><p><a class="reference internal" href="#asynstandardinterfacesbase-interface" id="id126">asynStandardInterfacesBase interface</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#standard-interpose-interfaces" id="id127">Standard Interpose Interfaces</a></p>
<ul>
<li><p><a class="reference internal" href="#asyninterposeeos" id="id128">asynInterposeEos</a></p></li>
<li><p><a class="reference internal" href="#asyninterposeflush" id="id129">asynInterposeFlush</a></p></li>
<li><p><a class="reference internal" href="#asyninterposecom" id="id130">asynInterposeCom</a></p></li>
<li><p><a class="reference internal" href="#asyninterposedelay" id="id131">asynInterposeDelay</a></p></li>
<li><p><a class="reference internal" href="#asyninterposeecho" id="id132">asynInterposeEcho</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#generic-device-support-for-epics-records" id="id133">Generic Device Support for EPICS records</a></p>
<ul>
<li><p><a class="reference internal" href="#asynmanager-interrupts-and-epics-device-support" id="id134">asynManager interrupts and EPICS device support</a></p></li>
<li><p><a class="reference internal" href="#initial-values-of-output-records" id="id135">Initial values of output records</a></p></li>
<li><p><a class="reference internal" href="#enum-values-for-bi-bo-mbbi-and-mbbo-records" id="id136">Enum values for bi, bo, mbbi, and mbbo records</a></p></li>
<li><p><a class="reference internal" href="#callback-updates-for-output-records" id="id137">Callback updates for output records</a></p></li>
<li><p><a class="reference internal" href="#buffering-of-driver-callbacks" id="id138">Buffering of driver callbacks</a></p></li>
<li><p><a class="reference internal" href="#time-stamps" id="id139">Time stamps</a></p></li>
<li><p><a class="reference internal" href="#asynint32-device-support" id="id140">asynInt32 device support</a></p></li>
<li><p><a class="reference internal" href="#asynint64-device-support" id="id141">asynInt64 device support</a></p></li>
<li><p><a class="reference internal" href="#asynintxxxarray-device-support-xxx-8-16-32-or-64" id="id142">asynIntXXXArray device support (XXX=8, 16, 32, or 64)</a></p></li>
<li><p><a class="reference internal" href="#asynxxxtimeseries-device-support-xxx-int32-int64-or-float64" id="id143">asynXXXTimeSeries device support (XXX=Int32, Int64, or Float64)</a></p></li>
<li><p><a class="reference internal" href="#asynuint32digital-device-support" id="id144">asynUInt32Digital device support</a></p></li>
<li><p><a class="reference internal" href="#asynfloat64-device-support" id="id145">asynFloat64 device support</a></p></li>
<li><p><a class="reference internal" href="#asynfloatxxxarray-device-support-xxx-32-or-64" id="id146">asynFloatXXXArray device support (XXX=32 or 64)</a></p></li>
<li><p><a class="reference internal" href="#asynoctet-device-support" id="id147">asynOctet device support</a></p></li>
<li><p><a class="reference internal" href="#record-alarms" id="id148">Record alarms</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#asynrecord-generic-epics-record-support" id="id149">asynRecord: Generic EPICS Record Support</a></p></li>
<li><p><a class="reference internal" href="#asyngpib" id="id150">asynGpib</a></p>
<ul>
<li><p><a class="reference internal" href="#asyngpibdriver-h" id="id151">asynGpibDriver.h</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id152">asynGpib</a></p></li>
<li><p><a class="reference internal" href="#asyngpibport" id="id153">asynGpibPort</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#port-drivers" id="id154">Port Drivers</a></p>
<ul>
<li><p><a class="reference internal" href="#local-serial-port" id="id155">Local Serial Port</a></p></li>
<li><p><a class="reference internal" href="#tcp-ip-or-udp-ip-port" id="id156">TCP/IP or UDP/IP Port</a></p></li>
<li><p><a class="reference internal" href="#tcp-ip-server" id="id157">TCP/IP Server</a></p></li>
<li><p><a class="reference internal" href="#vxi-11" id="id158">VXI-11</a></p></li>
<li><p><a class="reference internal" href="#drvprologixgpib" id="id159">drvPrologixGPIB</a></p></li>
<li><p><a class="reference internal" href="#linux-gpib" id="id160">Linux-Gpib</a></p></li>
<li><p><a class="reference internal" href="#green-springs-ip488" id="id161">Green Springs IP488</a></p></li>
<li><p><a class="reference internal" href="#national-instruments-gpib-1014d" id="id162">National Instruments GPIB-1014D</a></p></li>
<li><p><a class="reference internal" href="#usb-tmc-test-and-measurement-class-driver" id="id163">USB TMC (Test and Measurement Class) driver</a></p>
<ul>
<li><p><a class="reference internal" href="#non-octet-records" id="id164">Non-octet records</a></p></li>
<li><p><a class="reference internal" href="#service-request-srq-handling" id="id165">Service Request (SRQ) handling</a></p></li>
<li><p><a class="reference internal" href="#device-status-byte-stb" id="id166">Device Status Byte (STB)</a></p></li>
<li><p><a class="reference internal" href="#remote-enable-ren" id="id167">Remote Enable (REN)</a></p></li>
<li><p><a class="reference internal" href="#local-lockout-llo" id="id168">Local Lockout (LLO)</a></p></li>
<li><p><a class="reference internal" href="#go-to-local-gtl" id="id169">Go To Local (GTL)</a></p></li>
<li><p><a class="reference internal" href="#linux-udev-configuration" id="id170">Linux udev configuration</a></p></li>
<li><p><a class="reference internal" href="#streamdevice-exception-handlers" id="id171">StreamDevice Exception Handlers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#ftdi-port" id="id172">FTDI Port</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#asynportdriver-c-base-class" id="id173">asynPortDriver C++ base class</a></p></li>
<li><p><a class="reference internal" href="#asynportclient-c-classes" id="id174">asynPortClient C++ classes</a></p></li>
<li><p><a class="reference internal" href="#diagnostic-aids" id="id175">Diagnostic Aids</a></p>
<ul>
<li><p><a class="reference internal" href="#iocsh-commands" id="id176">iocsh Commands</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#example-client" id="id177">Example Client</a></p></li>
<li><p><a class="reference internal" href="#test-applications" id="id178">Test Applications</a></p>
<ul>
<li><p><a class="reference internal" href="#testapp" id="id179">testApp</a></p></li>
<li><p><a class="reference internal" href="#testarrayringbufferapp" id="id180">testArrayRingBufferApp</a></p></li>
<li><p><a class="reference internal" href="#testasynportclientapp" id="id181">testAsynPortClientApp</a></p></li>
<li><p><a class="reference internal" href="#testbroadcastapp" id="id182">testBroadcastApp</a></p>
<ul>
<li><p><a class="reference internal" href="#testbroadcastasyn-c" id="id183">testBroadcastAsyn.c</a></p></li>
<li><p><a class="reference internal" href="#testbroadcastnoasyn-c" id="id184">testBroadcastNoAsyn.c</a></p></li>
<li><p><a class="reference internal" href="#testbroadcastburst-c" id="id185">testBroadcastBurst.c</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#testconnectapp" id="id186">testConnectApp</a></p></li>
<li><p><a class="reference internal" href="#testepicsapp" id="id187">testEpicsApp</a></p></li>
<li><p><a class="reference internal" href="#testerrorsapp" id="id188">testErrorsApp</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#install-and-build" id="id189">Install and Build</a></p>
<ul>
<li><p><a class="reference internal" href="#install-and-build-asyndriver" id="id190">Install and Build asynDriver</a></p></li>
<li><p><a class="reference internal" href="#using-asyndriver-components-with-an-epics-ioccore-application" id="id191">Using asynDriver Components with an EPICS iocCore Application</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id3" id="id192">License Agreement</a></p></li>
</ul>
</li>
</ul>
</nav>
</section>
<section id="purpose">
<h2><a class="toc-backref" href="#id63" role="doc-backlink">Purpose</a><a class="headerlink" href="#purpose" title="Link to this heading"></a></h2>
<p><strong>asynDriver</strong> is a general purpose facility for interfacing device specific
code to low level drivers. asynDriver allows non-blocking device support that works
with both blocking and non-blocking drivers.</p>
<p>A primary target for asynDriver is EPICS IOC device support but, other than using
libCom, much of it is independent of EPICS.</p>
<p>asynDriver has the following key concepts:</p>
<ul class="simple">
<li><p>Device support communicates with drivers via interfaces</p>
<ul>
<li><p>Drivers take care of the details of how to communicate with a device and implement
interfaces for use by device support. Interfaces are defined for both message and
register based devices. In the past when support was written for a new type of device,
device support for standard EPICS records had to be written in addition to the driver
support. Now a driver just implements one or more of the standard interfaces.</p></li>
</ul>
</li>
<li><p>A port provides access to device instances</p>
<ul>
<li><p>A port, which has a portName, identifies a communication path to one or more device
instances. For example a GPIB port can have up to 15 devices connected to it. An
RS232 port communicates with a single device. Drivers register a port. Device support
connects to a port.</p></li>
</ul>
</li>
<li><p>asynManager controls access to a port</p>
<ul>
<li><p>asynManager, a component of asynDriver, provides exclusive access to a driver via
calls to queueRequest, lockPort/unlockPort, and queueLockPort/queueUnlockPort. Once
device support has access, it can make an arbitrary number of calls to the driver
knowing that no other support can call the driver. Device and driver support do
not need to implement queues or semaphores since asynManager does this for them.</p></li>
</ul>
</li>
<li><p>asynTrace provides a general purpose diagnostic facility</p>
<ul>
<li><p>Rules are defined for providing diagnostic messages. Provided device and driver
support follow the rules, a user can obtain several levels of diagnostic information
that can be displayed on the console, written to a file, or sent to the EPICS errlog
facility.</p></li>
</ul>
</li>
<li><p>asynRecord - Generic access to an device/port</p>
<ul>
<li><p>asynRecord is an EPICS record and set of associated MEDM displays that provide access</p>
<ul>
<li><p>A port or a device connected to a port</p>
<ul>
<li><p>The port or port,addr can be changed dynamically. Thus with one asynRecord in an
IOC, it is possible to talk to any device that has an asyn compatible driver.</p></li>
</ul>
</li>
<li><p>asynTrace - All asynTrace options can be controlled with the asynRecord.</p></li>
<li><p>Connection Management
- Display and change connection, enable, and autoConnect state</p></li>
<li><p>Standard interfaces</p>
<ul>
<li><p>These can be used to communicate with devices. For example if a new instrument arrives
that has a serial, GPIB, or ethernet port, then it is often possible to communicate
with it just by attaching an asynRecord to it.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Extensive Serial Support</p>
<ul>
<li><p>asynDriver provides many facilities for communicating with RS232, RS485, GPIB, and
ethernet.</p></li>
</ul>
</li>
</ul>
</section>
<section id="status">
<h2><a class="toc-backref" href="#id64" role="doc-backlink">Status</a><a class="headerlink" href="#status" title="Link to this heading"></a></h2>
<p>This version provides:</p>
<ul class="simple">
<li><p>asynManager: the software layer between device support and drivers.</p></li>
<li><p>asynRecord: EPICS record support that provides a generic interface to asynManager,
asynCommon, asynOctet, asynGpib, and other interfaces.</p></li>
<li><p>asynPortDriver: a C++ base class that makes it easy to write asyn drivers, with
much of the boilerplate asyn code handled in the base class methods.</p></li>
<li><p>asynPortClient: C++ classes that makes it easy to write C++ asyn clients that
communicate directly with asyn port drivers without running an EPICS IOC.</p></li>
<li><p>standard interfaces: Standard message and register based interfaces are defined.
Low Level Drivers implement standard interfaces. Device support communicates with
low level drivers via standard interfaces.</p></li>
<li><p>devEpics: Generic device support for EPICS records.</p></li>
<li><p>devGpib: EPICS device support that replaces the device support layer of the Winans/Franksen
gpibCore support.</p></li>
<li><p>asynGpib: a replacement for the drvGpibCommon layer of the Franksen gpibCore support.</p></li>
<li><p>drvAsynSerialPort: Support for devices connected to serial ports.</p></li>
<li><p>drvAsynIPPort: Support for TCP/IP and UDP/IP socket communication, including serial
devices accessed via Ethernet/Serial converter boxes.</p></li>
<li><p>drvAsynIPServerPort: Support for asyn socket servers that are accessed from remote
clients. TCP/IP sockets and UDP are supported.</p></li>
<li><p>VXI-11: A replacement for the VXI-11 support of the Franksen gpibCore support.</p></li>
<li><p>drvPrologixGPIB: Support for GPIB devices over Ethernet using the Prologix GPIB-Ethernet
controller.</p></li>
<li><p>Linux-gpib: Support for the Linux GPIB Package library.</p></li>
<li><p>gsIP488: A low level driver for the Greensprings IP488 Industry Pack module.</p></li>
<li><p>ni1014: A low level driver for the National Instruments VME 1014D.</p></li>
<li><p>Serial Bus Support: The asynLockPortNotify interface was added to make it easier
to support serial bus drivers that use the standard serial support.</p></li>
</ul>
<p>The following are some of the existing EPICS general purpose device support systems
that have been converted to use asynDriver:</p>
<ul class="simple">
<li><p>StreamDevice. This is the protocol file-based support for serial/GPIB/CAN from
Dirk Zimoch.</p></li>
<li><p>gpibCore. This is the operating-system-independent version of the Winans/Franksen
GPIB support.</p></li>
<li><p>synApps (The APS BCDA synchrotron applications). The mca, dxp, motor, Ip330, IpUnidig,
DAC128V and quadEM applications in this package have all been converted to asyn.
The serial and GPIB modules in this package are no longer needed, because the asyn
record replaces them. The areaDetector module was written to use asyn, and was the
original motivation for the development of asynPortDriver.</p></li>
</ul>
</section>
<section id="acknowledgments">
<h2><a class="toc-backref" href="#id65" role="doc-backlink">Acknowledgments</a><a class="headerlink" href="#acknowledgments" title="Link to this heading"></a></h2>
<p>The idea of creating asynDriver resulted from many years of experience with writing
device support for serial and GPIB devices. The following individuals have been
most influential.</p>
<ul>
<li><p><strong>John Winans</strong></p>
<ul class="simple">
<li><p>John provided the original EPICS GPIB support. Databases using John’s support can
be used without modification with devGpib. With small modifications, device support
modules written for John’s support can be used.</p></li>
</ul>
</li>
<li><p><strong>Benjamin Franksen</strong></p>
<ul class="simple">
<li><p>John’s support only worked on vxWorks. In addition, the driver support was implemented
as a single source file. Benjamin defined an interface between drvCommon and low
level controllers and split the code into drvGpib and the low level drivers. He
also created the support for drvVxi11.</p></li>
</ul>
</li>
<li><p><strong>Eric Norum</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>Eric started with Benjamin’s code and converted it to use the Operating System Independent
features of EPICS 3.14.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>Marty Kraimer</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>Marty started with Eric’s version and made changes to support secondary addressing;
and to replace ioctl with code to support general bus management, universal commands,
and addressed commands.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>Pete Owens</strong></p>
<ul class="simple">
<li><p>Pete, for the Diamond Light Source, did a survey of several types of device/driver
support packages for serial devices. Diamond decided to use the StreamDevice support
developed by Dirk Zimoch.</p></li>
</ul>
</li>
<li><p><strong>Dirk Zimoch</strong></p>
<ul class="simple">
<li><p>Dirk developed StreamDevice, which has a single device support model, but supports
arbitrary low level message based drivers, i.e. GPIB, serial, etc.</p></li>
</ul>
</li>
<li><p><strong>Jun-ichi Odagare</strong></p>
<ul class="simple">
<li><p>Jun-ichi developed NetDev, a system that provides EPICS device support for network
based devices. It has a single device support model, but provides a general framework
for communicating with network based devices.</p></li>
</ul>
</li>
<li><p><strong>Mark Rivers</strong></p>
<ul class="simple">
<li><p>Mark became an active developer of asynDriver soon after he started converting SynApps
to use asynDriver. He soon pushed to have asynDriver support synchronous drivers,
support register based drivers, and support interrupts. With these additions asynDriver
is a framework for interfacing to a large class of devices instead of just message
based asynchronous devices.</p></li>
</ul>
</li>
<li><p><strong>Yevgeny A. Gusev</strong></p>
<ul class="simple">
<li><p>Yevgeny has found bugs and suggested improvements in the way asynManager handles
queue timeouts and cancels. He provides an expert and welcome set of eyes to look
at difficult code!!!</p></li>
</ul>
</li>
</ul>
</section>
<section id="overview-of-asyndriver">
<h2><a class="toc-backref" href="#id66" role="doc-backlink">Overview of asynDriver</a><a class="headerlink" href="#overview-of-asyndriver" title="Link to this heading"></a></h2>
<section id="definitions">
<h3><a class="toc-backref" href="#id67" role="doc-backlink">Definitions</a><a class="headerlink" href="#definitions" title="Link to this heading"></a></h3>
<p>asynDriver is a software layer between device specific code and drivers that communicate
with devices. It supports both blocking and non-blocking communication and can be
used with both register and message based devices. asynDriver uses the following
terminology:</p>
<ul class="simple">
<li><p>interface</p>
<ul>
<li><p>All communication between software layers is done via interfaces. An interface definition
is a C language structure consisting entirely of function pointers. An asynDriver
interface is analogous to a C++ or Java pure virtual interface. Although the implementation
is in C, the spirit is object oriented. Thus this document uses the term “method”
rather than “function pointer”.</p></li>
</ul>
</li>
<li><p>port</p>
<ul>
<li><p>A physical or logical entity which provides access to a device. A port provides
access to one or more devices.</p></li>
</ul>
</li>
<li><p>portDriver</p>
<ul>
<li><p>Code that communicates with a port.</p></li>
</ul>
</li>
<li><p>portThread</p>
<ul>
<li><p>If a portDriver can block, a thread is created for each port, and all I/O to the
portDriver is done via this thread.</p></li>
</ul>
</li>
<li><p>device</p>
<ul>
<li><p>A device (instrument) connected to a port. For example a GPIB interface can have
up to 15 devices connected to it. Other ports, e.g. RS-232 serial ports, only support
a single device. Whenever this document uses the word device without a qualifier,
it means something that is connected to a port.</p></li>
</ul>
</li>
<li><p>device support</p>
<ul>
<li><p>Code that interacts with a device.</p></li>
</ul>
</li>
<li><p>synchronous</p>
<ul>
<li><p>Support that does not voluntarily give up control of the CPU.</p></li>
</ul>
</li>
<li><p>asynchronous</p>
<ul>
<li><p>Support that is not synchronous. Some examples of asynchronous operations are epicsThreadSleep,
epicsEventWait, and stdio operations. Calls to epicsMutexTake are considered to
be synchronous operations, i.e. they are permitted in synchronous support.</p></li>
</ul>
</li>
<li><p>asynDriver</p>
<ul>
<li><p>The name for the support described in this manual. It is also the name of the header
file that describes the core interfaces.</p></li>
</ul>
</li>
<li><p>asynManager</p>
<ul>
<li><p>An interface and the code which implements the methods for interfaces asynManager
and asynTrace.</p></li>
</ul>
</li>
<li><p>asynchronous Driver</p>
<ul>
<li><p>A driver that blocks while communicating with a device. Typical examples are serial,
gpib, and network based drivers.</p></li>
</ul>
</li>
<li><p>synchronous Driver</p>
<ul>
<li><p>A driver that does not block while communicating with a device. Typical examples
are VME register based devices.</p></li>
</ul>
</li>
<li><p>Message Based Interfaces</p>
<ul>
<li><p>Interfaces that use octet arrays for read/write operations.</p></li>
</ul>
</li>
<li><p>Register Based Interfaces</p>
<ul>
<li><p>Interfaces that use integers or floats for read/write operations.</p></li>
</ul>
</li>
<li><p>interrupt</p>
<ul>
<li><p>As implemented by asynManager, interrupt just means “I have a new value for port,
address”.</p></li>
</ul>
</li>
</ul>
<p>Synchronous/asynchronous and message/register are orthogonal concepts. For example
a register based driver can be either synchronous or asynchronous. The terminology
register vs message is adapted from VXI.</p>
<p>Standard interfaces are defined so that device specific code can communicate with
multiple port drivers. For example if device support does all its communication
via reads and writes consisting of 8 bit bytes (octets), then it should work with
all port drivers that support octet messages. If device support requires more complicated
support, then the types of ports will be more limited. Standard interfaces are also
defined for drivers that accept 32 bit integers or 64 bit floats. Additional interfaces
can be defined, and it is expected that additional standard interfaces will be defined.</p>
<p>One or more devices can be attached to a port. For example, only one device can
be attached to an RS-232 port, but up to 15 devices can be attached to a GPIB port.</p>
<p>Multiple layers can exist between device specific code and a port driver. A software
layer calls interposeInterface in order to be placed between device specific code
and drivers. For more complicated protocols, additional layers can be created. For
example, GPIB support is implemented as an asynGpib interface which is called by
user code, and an asynGpibPort interface which is called by asynGpib.</p>
<p>A driver normally implements multiple interfaces. For example asynGpib implements
asynCommon, asynOctet, and asynGpib.</p>
<p>asynManager uses the Operating System Independent features of EPICS base. It is,
however, independent of record/device support. Thus, it can be used by other code,
e.g. a sequence program.</p>
</section>
<section id="standard-interfaces">
<h3><a class="toc-backref" href="#id68" role="doc-backlink">Standard Interfaces</a><a class="headerlink" href="#standard-interfaces" title="Link to this heading"></a></h3>
<p>These are interfaces provided by asynManager or interfaces implemented by all or
most port drivers.</p>
<p>The interfaces are:</p>
<p><strong>asynManager</strong> provides services for communicating with a device connected to a port.</p>
<p><strong>asynCommon</strong> is an interface that must be implemented by all low level drivers. The methods are:</p>
<ul class="simple">
<li><p>report - Report status of port.</p></li>
<li><p>connect - Connect to the port or device.</p></li>
<li><p>disconnect - Disconnect from the port or device.</p></li>
</ul>
<p><strong>asynTrace</strong> is an interface for generating diagnostic messages.</p>
<p><strong>asynLockPortNotify</strong> is an interface that is implemented by a driver which is an asynUser of another driver.
An example is a serial bus driver that uses standard serial support. asynManager calls asynLockPortNotify
whenever it locks or unlocks the port.</p>
<p><strong>asynDrvUser</strong> is an interface for communicating information from device support to a driver without the device support knowing any
details about what is passed.</p>
</section>
<section id="generic-interfaces">
<h3><a class="toc-backref" href="#id69" role="doc-backlink">Generic Interfaces</a><a class="headerlink" href="#generic-interfaces" title="Link to this heading"></a></h3>
<p>In addition to <strong>asynCommon</strong> and optionally <strong>asynDrvUser</strong>, port drivers can implement one
or more of the following message and/or register based interfaces.</p>
<p><strong>asynOctet</strong> methods for message based devices</p>
<p><strong>asynFloat64</strong> methods for devices that read/write IEEE float values</p>
<p><strong>asynFloat32Array</strong> methods for devices that read/write arrays of IEEE 32-bit float values</p>
<p><strong>asynFloat64Array</strong> methods for devices that read/write arrays of IEEE 64-bit float values</p>
<p><strong>asynInt32</strong> methods for devices that read/write integer values. Many analog I/O drivers can use this interface.</p>
<p><strong>asynInt64</strong> methods for devices that read/write 64-bit integer values.</p>
<p><strong>asynInt8Array</strong> methods for devices that read/write arrays of 8-bit integer values</p>
<p><strong>asynInt16Array</strong> methods for devices that read/write arrays of 16-bit integer values</p>
<p><strong>asynInt32Array</strong> methods for devices that read/write arrays of 32-bit integer values</p>
<p><strong>asynInt64Array</strong> methods for devices that read/write arrays of 64-bit integer values</p>
<p><strong>asynUInt32Digital</strong> methods for devices that read/write arrays of digital values.
This interface provides a mask to address individual bits within registers.</p>
<p><strong>asynGenericPointer</strong> methods for devices that read/write arbitrary structures, passed via a void* pointer.
The client and the server of course need to agree on the structure type being pointed to.</p>
<p><strong>asynEnum</strong> methods for devices to define enum strings, values, and severities.</p>
<p><strong>asynOption</strong> methods for device configuration using key/value pairs.</p>
</section>
<section id="asynmanager">
<h3><a class="toc-backref" href="#id70" role="doc-backlink">asynManager</a><a class="headerlink" href="#asynmanager" title="Link to this heading"></a></h3>
<p>asynManager is an interface and associated code. It is the “heart” of asynDriver
since it manages the interactions between device support code and drivers. It provides
the following services:</p>
<section id="reporting">
<h4><a class="toc-backref" href="#id71" role="doc-backlink">reporting</a><a class="headerlink" href="#reporting" title="Link to this heading"></a></h4>
<blockquote>
<div><p>Method: report</p>
</div></blockquote>
</section>
<section id="asynuser-creation">
<h4><a class="toc-backref" href="#id72" role="doc-backlink">asynUser creation</a><a class="headerlink" href="#asynuser-creation" title="Link to this heading"></a></h4>
<blockquote>
<div><p>Methods: createAsynUser, duplicateAsynUser, freeAsynUser</p>
<p>An asynUser is a “handle” for accessing asynManager services and for calling interfaces
implemented by drivers. An asynUser must only be created via a call to createAsynUser
or duplicateAsynUser since asynManager keeps private information for each asynUser.
freeAsynUser puts the asynUser on a free list rather than calling free. Clients
can continually create and free asynUsers quickly and without fragmenting memory.</p>
<p>The call to createAsynUser specifies a processCallback and a timeoutCallback. These
are the callbacks that will be called as a result of a queueRequest.
An asynUser should not be shared between parts of code that can simultaneously access
a driver. For example device support for standard EPICS records should create an
asynUser for each record instance.</p>
</div></blockquote>
</section>
<section id="basic-asynuser-services">
<h4><a class="toc-backref" href="#id73" role="doc-backlink">Basic asynUser services</a><a class="headerlink" href="#basic-asynuser-services" title="Link to this heading"></a></h4>
<blockquote>
<div><p>Methods: connectDevice, disconnect, findInterface</p>
<p>These methods should only be called by the code that created the asynUser.</p>
<p>After an asynUser is created the user calls connectDevice. The user is connected
to a port driver that can communicate with a device. findInterface is called for
each interface the user requires. disconnect is called when the user is done with
the device.</p>
</div></blockquote>
</section>
<section id="queuing-services">
<h4><a class="toc-backref" href="#id74" role="doc-backlink">Queuing services</a><a class="headerlink" href="#queuing-services" title="Link to this heading"></a></h4>
<blockquote>
<div><p>Methods: queueRequest, cancelRequest, lockPort, unlockPort, queueLockPort, queueUnlockPort,
blockProcessCallback, unblockProcessCallback</p>
<p>queueRequest is a request to call the processCallback specified in the call to createAsynUser.
Most interface methods must only be called from processCallback via a call to queueRequest
or between calls to lockPort/unlockPort.. Exceptions to this rule must be clearly
documented (a common exception are methods registerInterruptUser/cancelInterruptUser).</p>
<p>queueRequest semantics differ for ports that can block and ports that do not block</p>
<p>When registerPort is called by a driver that can block, a thread is created for
the port. A set of queues, based on priority, is created for the thread. queueRequest
puts the request on one of the queues. The port thread takes the requests from the
queues and calls the associated callback. Only one callback is active at a time.</p>
<p>When registerPort is called by a driver that does not block, a mutex is created
for the port. queueRequest takes the mutex, calls the callback, and releases the
mutex. The mutex guarantees that two callbacks to a port are not active at the same
time.</p>
<p>lockPort is a request to lock all access to low level drivers until unlockPort is
called. If the port blocks then lockPort and all calls to the port driver may block.
lockPort/unlockPort are provided for use by code that is willing to block or for
communication with synchronous ports. A call to lockPort locks all addresses associated
with a multi-address port. Prior to asyn R4-14 pasynManager-&gt;lockPort() immediately
took the port mutex when it was available, rather than queueing a request to take
the mutex. From asyn R4-14 to R4-20 lockPort queues a request to access the port
and then blocks until the queue request callback runs in the portThread. When the
queue request runs, the thread that called pasynManager-&gt;lockPort() executes,
and the portThread blocks, until pasynManager-&gt;unlockPort() is called. In R4-21
the queued lockPort and unlockPort functions were renamed to queueLockPort and queueUnlockPort,
and the original lightweight lockPort and unlockPort functions were restored. Up
to R4-32 when queueLockPort called queueRequest it did not specify a timeout. This
could lead to code being hung if the port disconnected after the call to queueRequest
but before the callback was called. The code would remain hung until the port reconnected.
In R4-32 the queueRequest is done with a timeout. The default timeout value is 2.0
seconds but this can be change with the shell command asynSetQueueLockPortTimeout(portName,
double timeout). If the pasynUser-&gt;timeout passed to queueLockPort is greater
than the current port timeout value this larger timeout from the pasynUser is used
instead.</p>
<p>blockProcessCallback is a request to prevent acccess to a device or port by other
asynUsers between queueRequests. blockProcessCallback can be called from a processCallback
or when the asynUser has no request queued. When called from processCallback blocking
starts immediately, otherwise blocking starts the next time processCallback is called.
Blocking means that no other asynUser’s processCallback will be called until unblockProcessCallback
is called. blockProcessCallback only works with drivers that can block and an error
is returned if it is called for non-blocking drivers.</p>
</div></blockquote>
</section>
<section id="basic-driver-services">
<h4><a class="toc-backref" href="#id75" role="doc-backlink">Basic Driver services</a><a class="headerlink" href="#basic-driver-services" title="Link to this heading"></a></h4>
<blockquote>
<div><p>Methods: registerPort, registerInterface</p>
<p>registerPort is called by a portDriver. registerInterface is called by a portDriver
or an interposeInterface.</p>
<p>Each port driver provides a configuration command that is executed for each port
instance. The configuration command performs port specific initializations, calls
registerPort, and registerInterface for each interface it implements.</p>
</div></blockquote>
</section>
<section id="attribute-retrieval">
<h4><a class="toc-backref" href="#id76" role="doc-backlink">Attribute Retrieval</a><a class="headerlink" href="#attribute-retrieval" title="Link to this heading"></a></h4>
<blockquote>
<div><p>Methods: isMultiDevice, canBlock, getAddr, getPortName, isConnected, isEnabled,
isAutoConnect</p>
<p>These methods can be called by any code that has access to the asynUser</p>
</div></blockquote>
</section>
<section id="connection-services">
<h4><a class="toc-backref" href="#id77" role="doc-backlink">Connection services</a><a class="headerlink" href="#connection-services" title="Link to this heading"></a></h4>
<blockquote>
<div><p>Methods: enable,autoConnect,setAutoConnectTimeout</p>
<p>These methods can be called by any code that has access to the asynUser.</p>
<p>These methods can be called to set the enable and autoConnect settings for a port
and/or device. If autoConnect is true then asynManager does the following:</p>
<blockquote>
<div><p>When the port registers its asynCommon interface, asynManager queues a connection
request. It then waits for a short time for the connection callback to complete.
The default time is 0.5 seconds, but this time can be changed with a call to the
function pasynManager-&gt;setAutoConnectTimeout(double timeout). This function can
be accessed from the iocsh shell with the asynSetAutoConnectTimeout(double timeout)
command. This short timeout is designed to allow devices time to connect if they
are available, but not to excessively slow down booting of the IOC by waiting, for
example, for the system timeout on TCP connections. Note that this means that it
is very likely that the pasynCommon-&gt;connect() call will occur as soon as the
asynCommon interface is registered, which means that the driver must have already
done all initialization required for the asynCommon-&gt;connect() callback before
it registers the asynCommon interface. If the port does not connect initially, or
if it subsequently disconnects, then asynManager will queue a connection request
every 20 seconds. If autoConnect is true and port/device is enabled but the device
is not connected, then queueManager calls calling asynCommon:connect just before
it calls processCallback.</p>
</div></blockquote>
</div></blockquote>
</section>
<section id="exception-services">
<h4><a class="toc-backref" href="#id78" role="doc-backlink">Exception services</a><a class="headerlink" href="#exception-services" title="Link to this heading"></a></h4>
<blockquote>
<div><p>Methods: exceptionCallbackAdd, exceptionCallbackRemove, exceptionConnect, exceptionDisconnect</p>
<p>Device support code calls exceptionCallbackAdd and exceptionCallbackRemove. The
complete list of exceptions is defined in asynDriver.h as “enum asynException”.</p>
<p>Whenever a port driver connects or disconnects, normally as a result of a call to
asynCommon:connect or asynCommon:disconnect, it must also call exceptionConnect
or exceptionDisconnect.</p>
</div></blockquote>
</section>
<section id="interrupt-services">
<h4><a class="toc-backref" href="#id79" role="doc-backlink">Interrupt services</a><a class="headerlink" href="#interrupt-services" title="Link to this heading"></a></h4>
<blockquote>
<div><p>Methods: registerInterruptSource, getInterruptPvt, createInterruptNode, freeInterruptNode,
addInterruptUser, removeInterruptUser, interruptStart, interruptEnd</p>
<p>Interrupt just means: “I have a new value.” Many asyn interfaces, e.g. asynInt32,
provide interrupt support. These interfaces provide methods addInterruptUser and
removeInterruptUser. Device support calls addInterruptUser if it wants to be called
whenever an interrupt occurs. Drivers or other code that implements the interface
calls the registered users when it has new data. asynManager provides services that
help drivers implement thread-safe support for interrupts.</p>
<p>A driver that supports interrupts calls registerInterruptSource for each interface
that has associated interrupts. It calls interruptStart to obtain a list of all
registered users and interruptEnd after it calls the registered users. The driver
is also responsible for calling addInterruptUser and removeInterruptUser.</p>
<p>If any calls are made to addInterruptUser or removeInterruptUser between the calls
to interruptStart and interruptEnd, asynManager puts the request on a list and processes
the request after interruptEnd is called.</p>
<p>Many standard interfaces, e.g. asynInt32, provide methods registerInterruptUser,
cancelInterruptUser. These interfaces also provide an auxilliary interface, e.g.
asynInt32Base, and code which implements registerInterruptUser and cancelInterruptUser.</p>
<p>On operating systems like vxWorks or RTEMS interruptStart,interruptEnd MUST NOT
be called from interupt level.</p>
</div></blockquote>
</section>
<section id="timestamp-services">
<h4><a class="toc-backref" href="#id80" role="doc-backlink">Timestamp services</a><a class="headerlink" href="#timestamp-services" title="Link to this heading"></a></h4>
<blockquote>
<div><p>Methods: updateTimeStamp, getTimeStamp, setTimeStamp, registerTimeStampSource, unregisterTimeStampSource.</p>
<p>These methods provide support for setting a timestamp for a port. This timestamp
is typically used to set the pasynUser-&gt;timestamp field that is passed to device
support on read or callback operations. Device support uses the pasynUser-&gt;timestamp
field to set the record TIME field. This will then be the record timestamp if the
record TSE field is -2. asynManager provides a default timestamp source function
which just calls epicsTimeGetCurrent(). However, registerTimeStampSource can be
used to supply a different user-provided timestamp source function, for example
one that calls epicsTimeGetEvent(), or some other site-specific timestamp source.
unregisterTimeStampSource reverts to the default timestamp source in pasynManager.</p>
</div></blockquote>
</section>
<section id="general-purpose-freelist-service">
<h4><a class="toc-backref" href="#id81" role="doc-backlink">General purpose freelist service</a><a class="headerlink" href="#general-purpose-freelist-service" title="Link to this heading"></a></h4>
<blockquote>
<div><p>Methods: memMalloc, memFree</p>
<p>These methods do not require an asynUser. They are provided for code that must continually
allocate and free memory. Since memFree puts the memory on a free list instead of
calling free, they are more efficient that calloc/free and also help prevent memory
fragmentation.</p>
</div></blockquote>
</section>
<section id="interpose-service">
<h4><a class="toc-backref" href="#id82" role="doc-backlink">Interpose service</a><a class="headerlink" href="#interpose-service" title="Link to this heading"></a></h4>
<blockquote>
<div><p>Method: interposeInterface</p>
<p>Code that calls interposeInterface implements an interface which is either not supported
by a port driver or that is “interposed” between the caller and the port driver.
For example asynInterposeEos interposes asynOctet. It performs end of string processing
for port drivers that do not support it.</p>
<p>interposeInterface is recursive, i.e. an arbitrary number of interpose layers can
exist above a single port,addr.</p>
</div></blockquote>
</section>
</section>
<section id="multiple-device-vs-single-device-port-drivers">
<h3><a class="toc-backref" href="#id83" role="doc-backlink">Multiple Device vs Single Device Port Drivers</a><a class="headerlink" href="#multiple-device-vs-single-device-port-drivers" title="Link to this heading"></a></h3>
<p>When a low level driver calls registerPort, it declares if it handles multiple devices.
This determines how the addr argument to connectDevice is handled and what getAddr
returns.</p>
<blockquote>
<div><p><strong>multiDevice false</strong></p>
<blockquote>
<div><p>The addr argument to connectDevice is ignored and getAddr always returns -1</p>
</div></blockquote>
<p><strong>multiDevice true</strong></p>
<blockquote>
<div><p>If connectDevice is called with addr&lt;0, the connection is to the port and getAddr
always returns -1. If addr&gt;=0, then the caller is connected to the device at
the specified address. getAddr will return this address. An asynUser connected to
the port can issue requests that affect all address on the port. For example disabling
access to the port prevents access to all addresses on the port.</p>
</div></blockquote>
</div></blockquote>
</section>
<section id="connection-management">
<h3><a class="toc-backref" href="#id84" role="doc-backlink">Connection Management</a><a class="headerlink" href="#connection-management" title="Link to this heading"></a></h3>
<p>asynManager keeps track of the following states:</p>
<blockquote>
<div><p><strong>connection</strong></p>
<blockquote>
<div><p>Is the port or device connected? This state is initialized to disconnected.</p>
</div></blockquote>
<p><strong>enabled</strong></p>
<blockquote>
<div><p>Is the port or device enabled? This state is initialized to enabled.</p>
</div></blockquote>
<p><strong>autoConnect</strong></p>
<blockquote>
<div><p>Does asynManager automatically attempt to connect if it finds the port or device
disconnected? This is initialized to the state specified in the call to registerPort.</p>
</div></blockquote>
</div></blockquote>
<p>If the port does not support multiple devices, then port and device status are the
same. If the port does support multiple devices, then asynManager keeps track of
the states for the port and for every device connected to the port.</p>
<p>Whenever any of the states change for a port or device, then all users that previously
called exceptionCallbackAdd for that port or device are called.</p>
<p>Low level drivers must call pasynManager:exceptionConnect whenever they connect
to a port or port,addr and exceptionDisconnect whenever they disconnect.</p>
</section>
<section id="protecting-a-thread-from-blocking">
<h3><a class="toc-backref" href="#id85" role="doc-backlink">Protecting a Thread from Blocking</a><a class="headerlink" href="#protecting-a-thread-from-blocking" title="Link to this heading"></a></h3>
<p>The methods asynManager:report and asynCommon:report can be called by any thread,
but the caller is blocked until the report finishes. lockPort, unlockPort, queueLockPort,
queueUnlockPort, and most port methods may block. The other asynManager methods
can be called by any thread including portThread. None of these methods block.</p>
<p>Unless stated otherwise the methods for other interfaces must only be called by
processCallback or by calls between lockPort/unlockPort, or queueLockPort/queueUnlockPort.</p>
<p>Interface methods registerInterruptUser and cancelInterruptUser must never block.
The registerInterruptUser callback must not block because it could be called by
a non blocking driver.</p>
</section>
<section id="portthread">
<h3><a class="toc-backref" href="#id86" role="doc-backlink">portThread</a><a class="headerlink" href="#portthread" title="Link to this heading"></a></h3>
<p>If a driver calls asynManager:registerPort with the ASYN_CANBLOCK attributes bit
set, then asynManager creates a thread for the port. Each portThread has its own
set of queues for the calls to queueRequest. Four queues are maintained. One queue
is used only for asynCommon:connect and asynCommon:disconnect requests. The other
queues provide different priorities: low, medium, and high. queueRequests to any
queue other then the connection queue will be rejected if the port is not connected.
portThread runs forever implementing the following algorithm:</p>
<ol class="arabic">
<li><p>Wait for work by calling epicsEventMustWait. Other code such as queueRequest call
epicsEventSignal.</p></li>
<li><p>If the port is disabled, go back to 1.</p></li>
<li><p>For every element in queue, asynQueuePriorityConnect:</p>
<blockquote>
<div><ul class="simple">
<li><p>Removes the element from the queue.</p></li>
<li><p>Calls the user’s callback</p></li>
</ul>
</div></blockquote>
</li>
<li><p>For each element of the queues asynQueuePriorityHigh, …,asynQueuePriorityLow.</p>
<blockquote>
<div><ul>
<li><p>If disabled, skip this element.</p></li>
<li><p>If not connected and autoConnect is true for the device, then attempt to connect
to the device.</p></li>
<li><p>If not connected, skip this element.</p></li>
<li><p>If blocked by another thread, skip this element.</p></li>
<li><p>If not blocked and user has requested blocking, then blocked.</p></li>
<li><p>Remove from queue and:</p>
<blockquote>
<div><ul class="simple">
<li><p>lock port</p></li>
<li><p>call user callback</p></li>
<li><p>unlock port</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ol>
<p>The actual code is more complicated because it unlocks before it calls code outside
asynManager. This means that the queues can be modified and exceptions may occur.</p>
</section>
<section id="overview-of-queuing">
<h3><a class="toc-backref" href="#id87" role="doc-backlink">Overview of Queuing</a><a class="headerlink" href="#overview-of-queuing" title="Link to this heading"></a></h3>
<p>When discussing queuing it is useful to think of 3 components of asyn:</p>
<ol class="arabic">
<li><p>asynManager. This is the core part of asyn. It knows nothing about EPICS records.
In fact it is completely independent of EPICS except that it uses libCom for OS-independent
things like mutexes, message queues, events, etc. The queuing it provides is for
callback requests to communicate with asynchronous drivers (ASYN_CANBLOCK) via pasynManager-&gt;queueRequest().</p></li>
<li><p>Standard asyn device support (devEpics directory). This is the only part of asyn
that knows about EPICS records and depends on EPICS components other than libCom.
It supports callbacks from the driver under 3 conditions:</p>
<blockquote>
<div><ul class="simple">
<li><p>Input records with SCAN=I/O Intr</p></li>
<li><p>Input records with periodic scanning (asynInt32Average and asynFloat64Average only)</p></li>
<li><p>Output records with asyn:READBACK=1.</p></li>
</ul>
</div></blockquote>
<p>The callback values can be placed in a ring buffer so that values are not lost if
the callbacks happen faster than the record can process. The size of the ring buffer
can be controlled with the asyn:FIFO info tag. The default is 10 for scalar records.
The default is 0 for devAsynOctet, waveform, stringin, stringout, lsi, lso, printf
and scalcout records. If the ring buffer is in use then each driver callback results
in pushing a new value into the buffer and a request to process the record in a
separate callback thread. If the ring buffer is full then the oldest value in the
queue is discarded and the new value is added. This guarantees that the record will
eventually have the value of the most recent callback, but it may skip some before
this. If ASYN_TRACE_WARNING is set then a warning message is printed. The driver
callbacks do not block waiting for the record to process.</p>
</li>
<li><p>asynPortDriver. asynPortDriver does not support queueing. It does have a parameter
library that stores the most recent value of scalar parameters. It does not store
values for array parameters.</p></li>
</ol>
</section>
</section>
<section id="theory-of-operation">
<h2><a class="toc-backref" href="#id88" role="doc-backlink">Theory of Operation</a><a class="headerlink" href="#theory-of-operation" title="Link to this heading"></a></h2>
<section id="initialization">
<h3><a class="toc-backref" href="#id89" role="doc-backlink">Initialization</a><a class="headerlink" href="#initialization" title="Link to this heading"></a></h3>
<p>During initialization, port drivers register each communication port as well as
all supported interfaces.</p>
<p>User code creates an asynUser, which is a “handle” for accessing asynDriver facilities,
by calling</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pasynManager</span><span class="o">-&gt;</span><span class="n">createAsynUser</span><span class="p">(</span><span class="n">processCallback</span><span class="p">,</span> <span class="n">timeoutCallback</span><span class="p">);</span>
</pre></div>
</div>
<p>An asynUser has the following features:</p>
<ul class="simple">
<li><p>An asynUser is the means by which asynManager manages multiple requests for accessing
a port.</p></li>
<li><p>processCallback,which is used by queueRequest described below, is the addresss
of a user supplied callback routine.</p></li>
<li><p>timeoutCallback is the address of caller supplied callback that will be called
if a queueRequest remains on the queue too long.</p></li>
<li><p>Device support code should create an asynUser for each “atomic” access to low
level drivers, i.e. a set of calls that must not be interlaced with other calls
to the low level drivers. For example device support for EPICS record support should
create an asynUser for each record instance.</p></li>
<li><p>Device support code should NOT try to share an asynUser between multiple sources
of requests for access to a port. If this is done then device support must itself
handle contention issues that are already handled by asynManager.</p></li>
</ul>
<p>User code connects to a low level driver via a call to</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">status</span> <span class="o">=</span> <span class="n">pasynManager</span><span class="o">-&gt;</span><span class="n">connectDevice</span><span class="p">(</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">portName</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
</pre></div>
</div>
<p>This call must specify the name of the port and the address of the device. It then
calls findInterface to locate the interfaces with which it calls the driver. For example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pasynInterface</span> <span class="o">=</span> <span class="n">pasynManager</span><span class="o">-&gt;</span><span class="n">findInterface</span><span class="p">(</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">asynOctetType</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="requesting-access-to-a-port">
<h3><a class="toc-backref" href="#id90" role="doc-backlink">Requesting access to a port</a><a class="headerlink" href="#requesting-access-to-a-port" title="Link to this heading"></a></h3>
<ul>
<li><p>queueRequest</p>
<blockquote>
<div><p>The processCallback passed to createAsynUser makes calls to the port interfaces.</p>
</div></blockquote>
</li>
<li><p>lockPort/unlockPort, queueLockPort/queueUnlockPort</p>
<blockquote>
<div><p>The caller can make calls to the port interfaces while the lock is held. These calls
and calls to the port may block and thus should NOT be used by code that should
not block, e.g. synchronous device support for EPICS records.</p>
</div></blockquote>
</li>
</ul>
</section>
<section id="queuerequest-flow-of-control">
<h3><a class="toc-backref" href="#id91" role="doc-backlink">queueRequest - Flow of Control</a><a class="headerlink" href="#queuerequest-flow-of-control" title="Link to this heading"></a></h3>
<p>User code requests access to a port by calling</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">status</span> <span class="o">=</span> <span class="n">pasynManager</span><span class="o">-&gt;</span><span class="n">queueRequest</span><span class="p">(</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
</pre></div>
</div>
<p>This results in either processCallback or timeoutCallback being called. Most requests
to a port must be made from processCallback. queueRequest does not block. If queueRequest
is called for a port that can block the request is queued to a thread dedicated
to the port. If queueRequest is called for a port does not block it just calls processCallback.
guarantee is valid only if low level drivers are only accessed by calling queueRequest,
lockPort/unlockPort, and/or queueLockPort/queueUnlockPort</p>
<p>The following examples are based on EPICS IOC record/device support.</p>
<p>The first example shows access to a port that can block.</p>
<figure class="align-center" id="id4">
<img alt="_images/AsynFlow.jpg" src="_images/AsynFlow.jpg" />
<figcaption>
<p><span class="caption-text"><strong>Figure 1: Asynchronous Control Flow</strong></span><a class="headerlink" href="#id4" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The sequence of record device support events that occurs starting with an application
thread is pictured above in Figure 1, and explained below in the following steps:</p>
<ol class="arabic simple">
<li><p>Record processing calls device support with PACT 0 (Processing is not active).</p></li>
<li><p>Device support calls queueRequest.</p></li>
<li><p>queueRequest places the request on the driver work queue. The application thread
is now able to go on and perform other operations. Subsequent operations for this
I/O request are handled in the port driver thread.</p></li>
<li><p>The portThread removes the I/O request from the work queue.</p></li>
<li><p>The portThread calls the processCallback located in Record device support.</p></li>
<li><p>processCallback calls the low-level driver. The low-level driver read or write
routine blocks until the I/O completes or until a timeout occurs. The low-level
driver routine returns the results of the I/O operation to processCallback.</p></li>
<li><p>processCallback requests that the record be processed. NOTE: The process request
will be made by one of the standard callback requests rather than the port thread.</p></li>
<li><p>Record support calls device support again, this time with PACT 1(processing is
active). Device support updates fields in the record and returns to record support
which completes record processing.</p></li>
</ol>
<p>The second example shows access to a port that cannot block.</p>
<figure class="align-center" id="id5">
<img alt="_images/AsynSynFlow.jpg" src="_images/AsynSynFlow.jpg" />
<figcaption>
<p><span class="caption-text"><strong>Figure 2: Synchronous Control Flow</strong></span><a class="headerlink" href="#id5" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The sequence of record device support events that occurs starting with an application
thread is pictured above in Figure 2, and explained below in the following steps:</p>
<ol class="arabic simple">
<li><p>Record processing calls device support.</p></li>
<li><p>Device support calls queueRequest.</p></li>
<li><p>Since the port is synchronous, i.e. can not block, queueRequest locks the port
and then calls the processCallback.</p></li>
<li><p>processCallback calls the low-level driver read or write routine. The low-level
driver routine returns the results of the I/O operation to processCallback.</p></li>
<li><p>processCallback returns to queueRequest, which unlocks the port and returns to
device support, which returns to record support, which completes record processing.</p></li>
</ol>
</section>
</section>
<section id="asyndriver-structures-and-interfaces">
<h2><a class="toc-backref" href="#id92" role="doc-backlink">asynDriver Structures and Interfaces</a><a class="headerlink" href="#asyndriver-structures-and-interfaces" title="Link to this heading"></a></h2>
<p>asynDriver.h describes the following:</p>
<ul class="simple">
<li><p>asynStatus - An enum that describes the status returned by many methods.</p></li>
<li><p>asynException - An enum that describes exceptions.</p></li>
<li><p>asynQueuePriority - An enum that describes the queue priorities.</p></li>
<li><p>asynUser - A struture that contains generic information and is the “handle” for calling most methods.</p></li>
<li><p>asynInterface - a structure that describes an interface.</p></li>
<li><p>userCallback - a typedef for the user process callback function described above.</p></li>
<li><p>exceptionCallback - a typedef for a user callback to be called when exceptions occur.</p></li>
<li><p>timeStampCallback - a typedef for a user callback function that will be called by updateTimeStamp.</p></li>
<li><p>asynManager - An interface for communicating with asynDriver.</p></li>
<li><p>asynCommon - An interface providing methods that must be implemented by all low level drivers.</p></li>
<li><p>asynTrace - An interface plus associated functions and definitions that implement the trace facility.</p></li>
</ul>
<section id="asynstatus">
<h3><a class="toc-backref" href="#id93" role="doc-backlink">asynStatus</a><a class="headerlink" href="#asynstatus" title="Link to this heading"></a></h3>
<p>Defines the status returned by most methods. If a method returns a status other
than asynSuccess, and one of the arguments to the method is pasynUser, then the
method is expected to write a message into pasynUser-&gt;errorMessage.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">enum</span> <span class="p">{</span>
  <span class="n">asynSuccess</span><span class="p">,</span><span class="n">asynTimeout</span><span class="p">,</span><span class="n">asynOverflow</span><span class="p">,</span><span class="n">asynError</span><span class="p">,</span><span class="n">asynDisconnected</span><span class="p">,</span><span class="n">asynDisabled</span>
<span class="p">}</span> <span class="n">asynStatus</span>
</pre></div>
</div>
<table class="docutils align-default" id="id6">
<caption><span class="caption-text">asynStatus</span><a class="headerlink" href="#id6" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>asynSuccess</p></td>
<td><p>The request was successful.</p></td>
</tr>
<tr class="row-even"><td><p>asynTimeout</p></td>
<td><p>The request failed with a timeout.</p></td>
</tr>
<tr class="row-odd"><td><p>asynOverflow</p></td>
<td><p>The driver has lost input data. This can happen if an internal buffer or the user
supplied buffer is too small. Whenever possible, low level drivers should be written
so that the user can read input in small pieces.</p></td>
</tr>
<tr class="row-even"><td><p>asynError</p></td>
<td><p>Some other error occured.</p></td>
</tr>
<tr class="row-odd"><td><p>asynDisconnected</p></td>
<td><p>The request failed because the port is not connected.</p></td>
</tr>
<tr class="row-even"><td><p>asynDisabled</p></td>
<td><p>The request failed because the port or device is disabled.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynexception">
<h3><a class="toc-backref" href="#id94" role="doc-backlink">asynException</a><a class="headerlink" href="#asynexception" title="Link to this heading"></a></h3>
<p>Defines the exceptions for method exceptionOccurred</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">enum</span> <span class="p">{</span>
  <span class="n">asynExceptionConnect</span><span class="p">,</span><span class="n">asynExceptionEnable</span><span class="p">,</span><span class="n">asynExceptionAutoConnect</span><span class="p">,</span>
  <span class="n">asynExceptionTraceMask</span><span class="p">,</span><span class="n">asynExceptionTraceIOMask</span><span class="p">,</span><span class="n">asynExceptionTraceInfoMask</span><span class="p">,</span>
  <span class="n">asynExceptionTraceFile</span><span class="p">,</span><span class="n">asynExceptionTraceIOTruncateSize</span>
<span class="p">}</span> <span class="n">asynException</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id7">
<caption><span class="caption-text">asynException</span><a class="headerlink" href="#id7" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>asynExceptionConnect</p></td>
<td><p>The connection state of the port or device has changed.</p></td>
</tr>
<tr class="row-even"><td><p>asynExceptionEnable</p></td>
<td><p>The enable state of the port or device has changed.</p></td>
</tr>
<tr class="row-odd"><td><p>asynExceptionAutoConnect</p></td>
<td><p>The autoConnect state of the port or device has changed.</p></td>
</tr>
<tr class="row-even"><td><p>asynExceptionTraceMask</p></td>
<td><p>The traceMask for the port or device has changed.</p></td>
</tr>
<tr class="row-odd"><td><p>asynExceptionTraceIOMask</p></td>
<td><p>The traceIOMask for the port or device has changed.</p></td>
</tr>
<tr class="row-even"><td><p>asynExceptionTraceInfoMask</p></td>
<td><p>The traceInfoMask for the port or device has changed.</p></td>
</tr>
<tr class="row-odd"><td><p>asynExceptionTraceFile</p></td>
<td><p>The trace file for the port or device has changed.</p></td>
</tr>
<tr class="row-even"><td><p>asynExceptionTraceIOTruncateSize</p></td>
<td><p>The traceIOTruncateSize for the port or device has changed.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynqueuepriority">
<h3><a class="toc-backref" href="#id95" role="doc-backlink">asynQueuePriority</a><a class="headerlink" href="#asynqueuepriority" title="Link to this heading"></a></h3>
<p>This defines the priority passed to queueRequest.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">enum</span> <span class="p">{</span>
  <span class="n">asynQueuePriorityLow</span><span class="p">,</span><span class="n">asynQueuePriorityMedium</span><span class="p">,</span><span class="n">asynQueuePriorityHigh</span><span class="p">,</span>
  <span class="n">asynQueuePriorityConnect</span>
<span class="p">}</span> <span class="n">asynQueuePriority</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id8">
<caption><span class="caption-text">asynQueuePriority</span><a class="headerlink" href="#id8" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>asynQueuePriorityLow</p></td>
<td><p>Lowest queue priority.</p></td>
</tr>
<tr class="row-even"><td><p>asynQueuePriorityMedium</p></td>
<td><p>Medium queue priority.</p></td>
</tr>
<tr class="row-odd"><td><p>asynQueuePriorityHigh</p></td>
<td><p>High queue priority.</p></td>
</tr>
<tr class="row-even"><td><p>asynQueuePriorityConnect</p></td>
<td><p>Queue a connect or disconnect request. This priority must be used for and only for
connect/disconnect requests.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynuser">
<h3><a class="toc-backref" href="#id96" role="doc-backlink">asynUser</a><a class="headerlink" href="#asynuser" title="Link to this heading"></a></h3>
<p>Describes a structure that user code passes to most asynManager and driver methods.
Code must allocate and free an asynUser by calling asynManager:createAsynUser (or
asynManager:duplicateAsynUser) and asynManager:freeAsynUser.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynUser</span> <span class="p">{</span>
  <span class="n">char</span>          <span class="o">*</span><span class="n">errorMessage</span><span class="p">;</span>
  <span class="nb">int</span>            <span class="n">errorMessageSize</span><span class="p">;</span>
  <span class="o">/*</span> <span class="n">timeout</span> <span class="n">must</span> <span class="n">be</span> <span class="nb">set</span> <span class="n">by</span> <span class="n">the</span> <span class="n">user</span> <span class="o">*/</span>
  <span class="n">double</span>         <span class="n">timeout</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">Timeout</span> <span class="k">for</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">operations</span><span class="o">*/</span>
  <span class="n">void</span>          <span class="o">*</span><span class="n">userPvt</span><span class="p">;</span>
  <span class="n">void</span>          <span class="o">*</span><span class="n">userData</span><span class="p">;</span>
  <span class="o">/*</span> <span class="n">The</span> <span class="n">following</span> <span class="ow">is</span> <span class="k">for</span> <span class="n">use</span> <span class="n">by</span> <span class="n">driver</span> <span class="o">*/</span>
  <span class="n">void</span>          <span class="o">*</span><span class="n">drvUser</span><span class="p">;</span>
  <span class="o">/*</span> <span class="n">The</span> <span class="n">following</span> <span class="ow">is</span> <span class="n">normally</span> <span class="nb">set</span> <span class="n">by</span> <span class="n">driver</span> <span class="n">via</span> <span class="n">asynDrvUser</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">()</span> <span class="o">*/</span>
  <span class="nb">int</span>            <span class="n">reason</span><span class="p">;</span>
  <span class="n">epicsTimeStamp</span> <span class="n">timestamp</span><span class="p">;</span>
  <span class="o">/*</span> <span class="n">The</span> <span class="n">following</span> <span class="n">are</span> <span class="k">for</span> <span class="n">additional</span> <span class="n">information</span> <span class="kn">from</span> <span class="nn">method</span> <span class="n">calls</span> <span class="o">*/</span>
  <span class="nb">int</span>            <span class="n">auxStatus</span><span class="p">;</span>     <span class="o">/*</span> <span class="n">For</span> <span class="n">auxillary</span> <span class="n">status</span><span class="o">*/</span>
  <span class="nb">int</span>            <span class="n">alarmStatus</span><span class="p">;</span>   <span class="o">/*</span> <span class="n">Typically</span> <span class="k">for</span> <span class="n">EPICS</span> <span class="n">record</span> <span class="n">alarm</span> <span class="n">status</span> <span class="o">*/</span>
  <span class="nb">int</span>            <span class="n">alarmSeverity</span><span class="p">;</span> <span class="o">/*</span> <span class="n">Typically</span> <span class="k">for</span> <span class="n">EPICS</span> <span class="n">record</span> <span class="n">alarm</span> <span class="n">severity</span> <span class="o">*/</span>
<span class="p">}</span> <span class="n">asynUser</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id9">
<caption><span class="caption-text">asynUser</span><a class="headerlink" href="#id9" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>errorMessage</p></td>
<td><p>When a method returns asynError it should put an error message into errorMessage
via a call to</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">epicsSnprintf</span><span class="p">(</span><span class="n">pasynUser</span><span class="o">-&gt;</span><span class="n">errorMessage</span><span class="p">,</span><span class="n">pasynUser</span><span class="o">-&gt;</span><span class="n">errorMessageSize</span><span class="p">,</span> <span class="s2">&quot;&lt;format&gt;&quot;</span><span class="p">,</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>The error message should <em>not</em> end with (nor contain) a newline character
sequence (e.g. <code class="docutils literal notranslate"><span class="pre">\n</span></code>). It is up to user code to decide whether and how to
display the error message. Keeping newlines out of the error message make it easy
for user code to embed the error message in another message or output format.</p>
</td>
</tr>
<tr class="row-even"><td><p>errorMessageSize</p></td>
<td><p>The size of errorMessage. The user can not change this value.</p></td>
</tr>
<tr class="row-odd"><td><p>timeout</p></td>
<td><p>The number of seconds before timeout for I/O requests. This is set by the user and
can be changed between calls to a driver. If a call to a low level driver results
in the driver making many I/O requests this is the time for each I/O request.
The meaning is as follows:</p>
<p>&gt; 0.0 Wait for up to timeout seconds for the I/O to complete</p>
<p>= 0.0 Peform any I/O that can be done without blocking. Return timeout error if
no I/O can be done without blocking.</p>
<p>&lt; 0.0 Infinite timeout. Wait forever for I/O to complete.</p>
</td>
</tr>
<tr class="row-even"><td><p>userPvt</p></td>
<td><p>For use by the user. The user should set this immediately after the call to pasynManager-&gt;createAsynUser.</p>
<p>If this is changed while asynUser is queued, the results are undefined, e.g. it
could cause a crash.</p>
</td>
</tr>
<tr class="row-odd"><td><p>userData</p></td>
<td><p>Also for use by the user.</p></td>
</tr>
<tr class="row-even"><td><p>drvUser</p></td>
<td><p>A driver can use this to hold asynUser specific data. The asynDrvUser interface
is used for communication between asynUser and the driver.</p></td>
</tr>
<tr class="row-odd"><td><p>reason</p></td>
<td><p>Drivers and asynUsers can use this as a general purpose field. By convention it
is used to determine what “command” is being sent over a particular interface. For
example an A/D driver implementing the asynInt32 interface might define reason=0
to mean “return the A/D conversion”, while reason=1 might mean “return the amplifier
gain”. Typically drivers implement the asynDrvUser interface, and use this to convert
from descriptive strings for commands (e.g. “DATA” or “GAIN” in this example) to
the enum “reason”. A driver that is calling an interrupt users often uses reason
to decide if the users callback should be called. Values of reason less than 0 are
reserved for standard meanings. For example ASYN_REASON_SIGNAL is used to mean “out
of band” request. The devGpib support uses this to report SRQs.</p></td>
</tr>
<tr class="row-even"><td><p>timestamp</p></td>
<td><p>Devices which provide their own time stamps use this field to provide the time value
for records whose TSE field is set to “-2”.</p></td>
</tr>
<tr class="row-odd"><td><p>auxStatus</p></td>
<td><p>Any method can provide additional return information in auxStatus. The meaning is
determined by the method. Callbacks can use auxStatus to set record alarm status
in device support callback functions.</p></td>
</tr>
<tr class="row-even"><td><p>alarmStatus</p></td>
<td><p>Any method can provide additional return information in alarmStatus. The meaning
is determined by the method. Callbacks can use alarmStatus to set record alarm status
in device support callback functions.</p></td>
</tr>
<tr class="row-odd"><td><p>alarmSeverity</p></td>
<td><p>Any method can provide additional return information in alarmStatus. The meaning
is determined by the method. Callbacks can use alarmSeverity to set record alarm
severity in device support callback functions.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asyninterface">
<h3><a class="toc-backref" href="#id97" role="doc-backlink">asynInterface</a><a class="headerlink" href="#asyninterface" title="Link to this heading"></a></h3>
<p>This defines an interface registered with asynPortManager:registerPort or asynManager:interposeInterface.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynInterface</span><span class="p">{</span>
  <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">interfaceType</span><span class="p">;</span> <span class="o">/*</span><span class="n">For</span> <span class="n">example</span><span class="p">,</span> <span class="n">asynCommonType</span> <span class="o">*/</span>
  <span class="n">void</span> <span class="o">*</span><span class="n">pinterface</span><span class="p">;</span>          <span class="o">/*</span><span class="n">For</span> <span class="n">example</span><span class="p">,</span> <span class="n">pasynCommon</span> <span class="o">*/</span>
  <span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">;</span>
<span class="p">}</span> <span class="n">asynInterface</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id10">
<caption><span class="caption-text">asynInterface</span><a class="headerlink" href="#id10" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>interfaceType</p></td>
<td><p>A character string describing the interface.</p></td>
</tr>
<tr class="row-even"><td><p>pinterface</p></td>
<td><p>A pointer to the interface. The user must cast this to the correct type.</p></td>
</tr>
<tr class="row-odd"><td><p>drvPvt</p></td>
<td><p>For the exclusive use of the code that called registerPort or interposeInterface.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id1">
<h3><a class="toc-backref" href="#id98" role="doc-backlink">asynManager</a><a class="headerlink" href="#id1" title="Link to this heading"></a></h3>
<p>This is the main interface for communicating with asynDriver.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span><span class="n">registerPort</span> <span class="n">attributes</span><span class="o">*/</span>
<span class="c1">#define ASYN_MULTIDEVICE  0x0001</span>
<span class="c1">#define ASYN_CANBLOCK     0x0002</span>

<span class="o">/*</span><span class="n">standard</span> <span class="n">values</span> <span class="k">for</span> <span class="n">asynUser</span><span class="o">.</span><span class="n">reason</span><span class="o">*/</span>
<span class="c1">#define ASYN_REASON_SIGNAL -1</span>

<span class="c1">#define ASYN_REASON_RESERVED_LOW 0x70000000</span>
<span class="c1">#define ASYN_REASON_RESERVED_HIGH 0x7FFFFFFF</span>

<span class="c1">#define ASYN_REASON_QUEUE_EVEN_IF_NOT_CONNECTED ASYN_REASON_RESERVED_LOW</span>

<span class="n">typedef</span> <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">userCallback</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
<span class="n">typedef</span> <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exceptionCallback</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="n">asynException</span> <span class="n">exception</span><span class="p">);</span>
<span class="n">typedef</span> <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">timeStampCallback</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span> <span class="n">epicsTimeStamp</span> <span class="o">*</span><span class="n">pTimeStamp</span><span class="p">);</span>

<span class="n">typedef</span> <span class="n">struct</span> <span class="n">interruptNode</span><span class="p">{</span>
    <span class="n">ELLNODE</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">void</span>    <span class="o">*</span><span class="n">drvPvt</span><span class="p">;</span>
<span class="p">}</span><span class="n">interruptNode</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynManager</span> <span class="p">{</span>
    <span class="n">void</span>      <span class="p">(</span><span class="o">*</span><span class="n">report</span><span class="p">)(</span><span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span><span class="nb">int</span> <span class="n">details</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span><span class="o">*</span><span class="n">portName</span><span class="p">);</span>
    <span class="n">asynUser</span>  <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">createAsynUser</span><span class="p">)(</span><span class="n">userCallback</span> <span class="n">process</span><span class="p">,</span><span class="n">userCallback</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynUser</span>  <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">duplicateAsynUser</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                                 <span class="n">userCallback</span> <span class="n">queue</span><span class="p">,</span><span class="n">userCallback</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">freeAsynUser</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">void</span>       <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">memMalloc</span><span class="p">)(</span><span class="n">size_t</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">void</span>       <span class="p">(</span><span class="o">*</span><span class="n">memFree</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">pmem</span><span class="p">,</span><span class="n">size_t</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">isMultiDevice</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                                <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">yesNo</span><span class="p">);</span>
    <span class="o">/*</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">connect</span> <span class="n">to</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span><span class="n">device</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">connectDevice</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                                <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span><span class="nb">int</span> <span class="n">addr</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">exceptionCallbackAdd</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                                       <span class="n">exceptionCallback</span> <span class="n">callback</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">exceptionCallbackRemove</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynInterface</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">findInterface</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                            <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">interfaceType</span><span class="p">,</span><span class="nb">int</span> <span class="n">interposeInterfaceOK</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">queueRequest</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                              <span class="n">asynQueuePriority</span> <span class="n">priority</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">cancelRequest</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">wasQueued</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">blockProcessCallback</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="nb">int</span> <span class="n">allDevices</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">unblockProcessCallback</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="nb">int</span> <span class="n">allDevices</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">lockPort</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">unlockPort</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">queueLockPort</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">queueUnlockPort</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setQueueLockPortTimeout</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">canBlock</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">yesNo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getAddr</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getPortName</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">**</span><span class="n">pportName</span><span class="p">);</span>
    <span class="o">/*</span> <span class="n">drivers</span> <span class="n">call</span> <span class="n">the</span> <span class="n">following</span><span class="o">*/</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">registerPort</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span>
                              <span class="nb">int</span> <span class="n">attributes</span><span class="p">,</span><span class="nb">int</span> <span class="n">autoConnect</span><span class="p">,</span>
                              <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">priority</span><span class="p">,</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">stackSize</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">registerInterface</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span>
                              <span class="n">asynInterface</span> <span class="o">*</span><span class="n">pasynInterface</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">exceptionConnect</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">exceptionDisconnect</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="o">/*</span><span class="nb">any</span> <span class="n">code</span> <span class="n">can</span> <span class="n">call</span> <span class="n">the</span> <span class="n">following</span><span class="o">*/</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">interposeInterface</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                              <span class="n">asynInterface</span> <span class="o">*</span><span class="n">pasynInterface</span><span class="p">,</span>
                              <span class="n">asynInterface</span> <span class="o">**</span><span class="n">ppPrev</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">enable</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">yesNo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">autoConnect</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">yesNo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">isConnected</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">yesNo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">isEnabled</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">yesNo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">isAutoConnect</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">yesNo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setAutoConnectTimeout</span><span class="p">)(</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">waitConnect</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="o">/*</span><span class="n">The</span> <span class="n">following</span> <span class="n">are</span> <span class="n">methods</span> <span class="k">for</span> <span class="n">interrupts</span><span class="o">*/</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">registerInterruptSource</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span>
                               <span class="n">asynInterface</span> <span class="o">*</span><span class="n">pasynInterface</span><span class="p">,</span> <span class="n">void</span> <span class="o">**</span><span class="n">pasynPvt</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getInterruptPvt</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                               <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">interfaceType</span><span class="p">,</span> <span class="n">void</span> <span class="o">**</span><span class="n">pasynPvt</span><span class="p">);</span>
    <span class="n">interruptNode</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">createInterruptNode</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">pasynPvt</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">freeInterruptNode</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="n">interruptNode</span> <span class="o">*</span><span class="n">pnode</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">addInterruptUser</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                                  <span class="n">interruptNode</span><span class="o">*</span><span class="n">pinterruptNode</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">removeInterruptUser</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                                  <span class="n">interruptNode</span><span class="o">*</span><span class="n">pinterruptNode</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">interruptStart</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">pasynPvt</span><span class="p">,</span><span class="n">ELLLIST</span> <span class="o">**</span><span class="n">plist</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">interruptEnd</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">pasynPvt</span><span class="p">);</span>
    <span class="o">/*</span> <span class="n">Time</span> <span class="n">stamp</span> <span class="n">functions</span> <span class="o">*/</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">registerTimeStampSource</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span> <span class="n">timeStampCallback</span> <span class="n">callback</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">unregisterTimeStampSource</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">updateTimeStamp</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getTimeStamp</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">epicsTimeStamp</span> <span class="o">*</span><span class="n">pTimeStamp</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setTimeStamp</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">const</span> <span class="n">epicsTimeStamp</span> <span class="o">*</span><span class="n">pTimeStamp</span><span class="p">);</span>

    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">strStatus</span><span class="p">)(</span><span class="n">asynStatus</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynManager</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynManager</span> <span class="o">*</span><span class="n">pasynManager</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id11">
<caption><span class="caption-text">asynManager</span><a class="headerlink" href="#id11" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>report</p></td>
<td><p>Reports status about the asynPortManager. If portName is non-NULL it reports for
a specific port. If portName is NULL then it reports for each registered port. It
also calls asynCommon:report for each port being reported.</p></td>
</tr>
<tr class="row-even"><td><p>createAsynUser</p></td>
<td><p>Creates an asynUser. The caller specifies two callbacks, process and timeout. These
callback are only called as a result of a queueRequest. The timeout callback is
optional. errorMessageSize characters are allocated for errorMessage. The amount
of storage can not be changed. This method doesn’t return if it is unable to allocate
the storage.</p></td>
</tr>
<tr class="row-odd"><td><p>duplicateAsynUser</p></td>
<td><p>Creates an asynUser by calling createAsynUser. It then initializes the new asynUser
as follows: The fields timeout, userPvt, userData, and drvUser are initialized with
values taken from pasynUser. Its connectDevice state is the same as that for pasynUser.</p></td>
</tr>
<tr class="row-even"><td><p>freeAsynUser</p></td>
<td><p>Free an asynUser. The user must free an asynUser only via this call. If the asynUser
is connected to a port, asynManager:disconnect is called. If the disconnect fails,
this call will also fail. The storage for the asynUser is saved on a free list and
will be reused in later calls to createAsynUser or duplicateAsynUser. Thus continually
calling createAsynUser (or duplicateAsynUser) and freeAsynUser is efficient.</p></td>
</tr>
<tr class="row-odd"><td><p>memMalloc / memFree</p></td>
<td><p>Allocate/Free memory. memMalloc/memFree maintain a set of freelists of different
sizes. Thus any application that needs storage for a short time can use memMalloc/memFree
to allocate and free the storage without causing memory fragmentation. The size
passed to memFree MUST be the same as the value specified in the call to memMalloc.</p></td>
</tr>
<tr class="row-even"><td><p>isMultiDevice</p></td>
<td><p>Answers the question “Does the port support multiple devices?” This method can be
called before calling connectDevice.</p></td>
</tr>
<tr class="row-odd"><td><p>connectDevice</p></td>
<td><p>Connect the asynUser structure to a device specified by portName, addr. The port
Name is the same as that specified in a call to registerPort. The call will fail
if the asynUser is already connected to a device. If the port does not support multiple
devices, than addr is ignored. connectDevice only connects the asynUser to the port
driver for the portName,addr. The port driver may or may not be connected to the
actual device. Thus, connectDevice and asynCommon:connect are completely different.</p>
<p>See the Theory of Operation section for a description of the difference between
single and multi-device port drivers.</p>
</td>
</tr>
<tr class="row-even"><td><p>disconnect</p></td>
<td><p>Disconnect the asynUser from the port,addr to which it is connected via a previous
call to connectDevice. The call will fail if the asynUser is queued or locked, or
has a callback registered via exceptionCallbackAdd. Note that asynManager:disconnect
and asynCommon:disconnect are completely different.</p></td>
</tr>
<tr class="row-odd"><td><p>exceptionCallbackAdd</p></td>
<td><p>Callback will be called whenever one of the exceptions defined by asynException
occurs. The callback can call isConnected, isEnabled, or isAutoConnect to find the
connection state. asynTrace provides methods to find out the current trace settings.</p></td>
</tr>
<tr class="row-even"><td><p>exceptionCallbackRemove</p></td>
<td><p>Callback is removed. This must be called before disconnect.</p></td>
</tr>
<tr class="row-odd"><td><p>findInterface</p></td>
<td><p>Find a driver interface. If interposeInterfaceOK is true, then findInterface returns
the last interface registered or interposed. Otherwise, the interface registered
by registerPort is returned. It returns 0 if the interfaceType is not supported.</p>
<p>The user needs the address of the driver’s interface and of pdrvPvt so that calls
can be made to the driver. For example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>asynInterface *pasynInterface;
asynOctet *pasynOctet;
void *pasynOctetPvt;
...
pasynInterface = pasynManager-&gt;findInterface(
    pasynUser,asynOctetType,1);
if(!pasynInterface) { /*error do something*/}
pasynOctet = (asynOctet *)pasynInterface-&gt;pinterface;
pasynOctetPvt = pasynInterface-&gt;pdrvPvt;
...
/* The following call must be made from a callback */
pasynOctet-&gt;read(pasynOctetPvt,pasynUser,...
</pre></div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>queueRequest</p></td>
<td><p>When registerPort is called, the caller must specify if it can block, i.e. attribute
bit ASYN_CANBLOCK is set or cleared. If the port has been registered with ASYN_CANBLOCK
true then the request is put on a queue for the thread associated with the queue.
If the port has been registered with ASYN_CANBLOCK false then queueRequest locks
the port and calls the process callback. In either case the process callback specified
in the call to createAsynUser is called.</p>
<p>If the asynUser is already on a queue, asynError is returned. The timeout starts
when the request is queued. A value less than or equal to 0.0 means no timeout.
The request is removed from the queue before the callback is called. Callbacks are
allowed to make requests to asynManager such as queueRequest, blockProcessCallback,
etc. It is even permissible to call freeAsynUser from a callback but the request
will be delayed until after the callback completes.</p>
<p>The priority asynQueuePriorityConnect must be used for asynCommon:connect and asynCommon:disconnect
calls, and must NOT be used for any other calls.</p>
<p>If a timeout callback was not passed to createAsynUser and a queueRequest with a
non-zero timeout is requested, the request fails.</p>
<p>Attempts to queue a request other than a connection request to a disconnected port
will fail unless the reason is ASYN_REASON_QUEUE_EVEN_IF_NOT_CONNECTED.</p>
</td>
</tr>
<tr class="row-odd"><td><p>cancelRequest</p></td>
<td><p>If a asynUser is queued, remove it from the queue. If either the process or timeout
callback is active when cancelRequest is called than cancelRequest will not return
until the callback completes.</p></td>
</tr>
<tr class="row-even"><td><p>blockProcessCallback / unblockProcessCallback</p></td>
<td><p>blockProcessCallback is a request to prevent acccess to a device or port by other
asynUsers between queueRequests. blockProcessCallback can be called from a processCallback
or when the asynUser has no request queued. When called from processCallback blocking
starts immediately, otherwise blocking starts the next time processCallback is called.
Blocking means that no other asynUser’s processCallback will be called until unblockProcessCallback
is called. Note the following restrictions for blockProcessCallback:</p>
<ul class="simple">
<li><p>blockProcessCallback only works with drivers that can block and an error is returned
if it is called for non-blocking drivers.</p></li>
<li><p>queueRequests that specify a priority of asynQueuePriorityConnect are not blocked.</p></li>
</ul>
<p>It is permissible to simultaneously block allDevices and also the device to which
the asynUser is connected.</p>
</td>
</tr>
<tr class="row-odd"><td><p>lockPort / unlockPort</p></td>
<td><p>Lock access to a port driver. This is used by code that is willing to block while
making calls to a port driver. The code can call lockPort, make an arbitrary number
of calls to the port driver, and than call unlockPort. Other code that calls queueRequest
and/or lockPort will be delayed between the calls to lockPort and unlockPort.</p></td>
</tr>
<tr class="row-even"><td><p>queueLockPort / queueUnlockPort</p></td>
<td><p>Lock access to a port driver. This is used by code that is willing to block while
making calls to a port driver. The code can call queueLockPort, make an arbitrary
number of calls to the port driver, and than call queueUnlockPort. Other code that
calls queueRequest and/or lockPort will be delayed between the calls to queueLockPort
and queueUnlockPort. The difference between lockPort and queueLockPort is that queueLockPort
queues a request to lock the port, using the same queues as queueRequest. This means
that a thread that repeatedly calls queueLockPort without sleeping between calls
will still allow other threads to access the port. This is not true with lockPort,
which will take a mutex as soon as the port is free, and can prevent other threads
from accessing the port at all.</p></td>
</tr>
<tr class="row-odd"><td><p>setQueueLockPortTimeout</p></td>
<td><p>Sets the timeout passed to queueRequest() in queueLockPort(). The default value
of 2.0 seconds is set when the port is created. This function can be used to change
that value. Note that if the pasynUser-&gt;timeout value passed to queueLockPort
is larger than the current value then this larger timeout value is used.</p></td>
</tr>
<tr class="row-even"><td><p>canBlock</p></td>
<td><p>yesNo is set to (0,1), i.e. (false,true) if calls to the low level driver can block.
The value is determined by the attributes passed to registerPort.</p></td>
</tr>
<tr class="row-odd"><td><p>getAddr</p></td>
<td><p>*addr is set equal to the address which the user specified in the call to connectDevice
or -1 if the port does not support multiple devices.</p>
<p>See the Theory of Operation section for a description of the difference between
single and multi-device port drivers.</p>
</td>
</tr>
<tr class="row-even"><td><p>getPortName</p></td>
<td><p>*pportName is set equal to the name of the port to which the user is connected.</p></td>
</tr>
<tr class="row-odd"><td><p>registerPort</p></td>
<td><p>This method is called by drivers. A call is made for each port instance. Attributes
is a set of bits. Currently two bits are defined: ASYN_MULTIDEVICE and ASYN_CANBLOCK.
The driver must specify these properly. autoConnect, which is (0,1) for (no,yes),
provides the initial value for the port and all devices connected to the port. priority
and stacksize are only relevant if ASYN_CANBLOCK=1, in which case asynManager uses
these values when it creates the port thread with epicsThreadCreate(). If priority
is 0, then the default value epicsThreadPriorityMedium will be assigned. If stackSize
is 0, the default value of epicsThreadGetStackSize(epicsThreadStackMedium) will
be assigned. The portName argument specifies the name by which the upper levels
of the asyn code will refer to this communication interface instance. The registerPort
method makes an internal copy of the string to which the name argument points.</p></td>
</tr>
<tr class="row-even"><td><p>registerInterface</p></td>
<td><p>This is called by port drivers for each supported interface. This method <em>does
not</em> make a copy of the asynInterface to which the pasynInterface argument
points. Callers must store the asynInteface in a location which is retained for
the lifetime of the port. This is commonly done by placing the asynInterface structure
in the ‘driver private’ structure.</p></td>
</tr>
<tr class="row-odd"><td><p>exceptionConnect</p></td>
<td><p>This method must be called by the driver when and only when it connects to a port
or device.</p></td>
</tr>
<tr class="row-even"><td><p>exceptionDisconnect</p></td>
<td><p>This method must be called by the driver when and only when it disconnects from
a port or device.</p></td>
</tr>
<tr class="row-odd"><td><p>interposeInterface</p></td>
<td><p>This is called by a software layer between client code and the port driver. For
example, if a device echos writes then a software module that issues a read after
each write could be created and call interposeInterface for interface asynOctet.</p>
<p>Multiple interposeInterface calls for a port/addr/interface can be issued. *ppPrev
is set to the address of the previous asynInterface. Thus the software module that
last called interposeInterface is called by user code. It in turn can call the software
module that was the second to last to call interposeInterface. This continues until
the actual port driver is called.</p>
<p>interposeInterface can also be called with an asynInterface that has not been previously
registered or replaced. In this case *ppPrev will be null. Thus, new interfaces
that are unknown to the low level driver can be implemented.</p>
</td>
</tr>
<tr class="row-even"><td><p>enable</p></td>
<td><p>If enable is set yes, then queueRequests are not dequeued unless their queue timeout
occurs.</p></td>
</tr>
<tr class="row-odd"><td><p>autoConnect</p></td>
<td><p>If autoConnect is true and the port or device is not connected when a user callback
is scheduled to be called, asynManager calls pasynCommon-&gt;connect. See the discussion
of Flow of Control below for details.</p></td>
</tr>
<tr class="row-even"><td><p>isConnected</p></td>
<td><p>*yesNo is set to (0,1) if the port or device (is not, is) connected.</p></td>
</tr>
<tr class="row-odd"><td><p>isEnabled</p></td>
<td><p>*yesNo is set to (0,1) if the port or device (is not, is) enabled.</p></td>
</tr>
<tr class="row-even"><td><p>isAutoConnect</p></td>
<td><p>*yesNo is set to (0,1) if the portThread (will not, will) autoConnect for the port
or device.</p></td>
</tr>
<tr class="row-odd"><td><p>setAutoConnectTimeout</p></td>
<td><p>Changes the timeout when waiting for the initial connection callback from port drivers.
This callback occurs in response to asynManager queueing a connection request, which
happens when the port driver registers its asynCommon interface. The default timeout
is 0.5 seconds.</p></td>
</tr>
<tr class="row-even"><td><p>waitConnect</p></td>
<td><p>Wait for up to timeout seconds for the port/device to connect.</p></td>
</tr>
<tr class="row-odd"><td><p>registerInterruptSource</p></td>
<td><p>If a low level driver supports interrupts it must call this for each interface that
supports interrupts. pasynPvt must be the address of a void * that will be given
a value by registerInterruptSource. This argument is passed interruptStart and interruptEnd.</p></td>
</tr>
<tr class="row-even"><td><p>getInterruptPvt</p></td>
<td><p>Any code that wants to call createInterruptNode but does not know the adresss of
pasynPvt can find it via this method. The caller must be connected to a device,
i.e. must have called connectDevice. If the caller is not connected, getInterruptPvt
returns asynError.</p></td>
</tr>
<tr class="row-odd"><td><p>createInterruptNode / freeInterruptNode</p></td>
<td><p>These methods are the only way a user can allocate and free an interruptNode. pasynPvt
is the value obtained from getInterruptPvt. createInterruptNode/freeInterruptNode
are separate methods rather than being done automatically by addInterruptUser/removeInterruptUser
so that addInterruptUser/removeInterruptUser can be efficient.</p></td>
</tr>
<tr class="row-even"><td><p>addInterruptUser / removeInterruptUser</p></td>
<td><p>Code that implements registerInterruptUser/cancelInterruptUser must call addInterruptUser/removeInterruptUser
to add and remove users from the list or else calls to interruptStart/interruptEnd
will not work. This is an efficient operation so that a user can repeatedly call
registerInterruptUser / cancelInterruptUser. If either of these is called while a
interrupt is being processed, i.e. between calls to interruptStart/interruptEnd,
the call will block until interruptEnd is called. The process callback for the asynUser
specified in the call to addInterruptUser must not call removeInterruptUser or it
will block forever.</p></td>
</tr>
<tr class="row-odd"><td><p>interruptStart / interruptEnd</p></td>
<td><p>The code that implements interrupts is interface dependent. The only service asynManager
provides is a thread-safe implemention of the user list. When the code wants to
call the callback specified in the calls to registerInterruptUser, it calls interruptStart
to obtain the list of callbacks. When it is done it calls interruptEnd. If any requests
are made to addInterruptUser/removeInterruptUser between the calls to interruptStart
and interruptEnd, asynManager delays the requests until interruptEnd is called.</p></td>
</tr>
<tr class="row-even"><td><p>registerTimeStampSource</p></td>
<td><p>Registers a user-defined time stamp callback function.</p></td>
</tr>
<tr class="row-odd"><td><p>unregisterTimeStampSource</p></td>
<td><p>Unregisters any user-defined timestamp callback function and reverts to the default
timestamp source function in asynManager, which simply calls epicsTimeGetCurrent().</p></td>
</tr>
<tr class="row-even"><td><p>updateTimeStamp</p></td>
<td><p>Set the current time stamp for this port by calling either the default timestamp
source, or a user-defined timestamp source that was registered with registerTimeStampSource.</p></td>
</tr>
<tr class="row-odd"><td><p>getTimeStamp</p></td>
<td><p>Get the current time stamp for this port that was returned by the most recent call
to updateTimeStamp.</p></td>
</tr>
<tr class="row-even"><td><p>setTimeStamp</p></td>
<td><p>Set the current time stamp for this port directly from the timestamp value passed
to this function.</p></td>
</tr>
<tr class="row-odd"><td><p>strStatus</p></td>
<td><p>Returns a descriptive string corresponding to the asynStatus value.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asyncommon">
<h3><a class="toc-backref" href="#id99" role="doc-backlink">asynCommon</a><a class="headerlink" href="#asyncommon" title="Link to this heading"></a></h3>
<p>asynCommon describes the methods that must be implemented by drivers.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Device</span> <span class="n">Interface</span> <span class="n">supported</span> <span class="n">by</span> <span class="n">ALL</span> <span class="n">asyn</span> <span class="n">drivers</span><span class="o">*/</span>
<span class="c1">#define asynCommonType &quot;asynCommon&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span>  <span class="n">asynCommon</span> <span class="p">{</span>
    <span class="n">void</span>       <span class="p">(</span><span class="o">*</span><span class="n">report</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span><span class="nb">int</span> <span class="n">details</span><span class="p">);</span>
    <span class="o">/*</span><span class="n">following</span> <span class="n">are</span> <span class="n">to</span> <span class="n">connect</span><span class="o">/</span><span class="n">disconnect</span> <span class="n">to</span><span class="o">/</span><span class="kn">from</span> <span class="nn">hardware</span><span class="o">*/</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
<span class="p">}</span><span class="n">asynCommon</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id12">
<caption><span class="caption-text">asynCommon</span><a class="headerlink" href="#id12" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>report</p></td>
<td><p>Generates a report about the hardware device. This is the only asynCommon method
that does not have to be called by the queueRequest callback or between calls to
lockPort/unlockPort.</p></td>
</tr>
<tr class="row-even"><td><p>connect</p></td>
<td><p>Connect to the hardware device or communication path. The queueRequest must specify
priority asynQueuePriorityConnect.</p></td>
</tr>
<tr class="row-odd"><td><p>disconnect</p></td>
<td><p>Disconnect from the hardware device or communication path. The queueRequest must
specify priority asynQueuePriorityConnect.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asyncommonsyncio">
<h3><a class="toc-backref" href="#id100" role="doc-backlink">asynCommonSyncIO</a><a class="headerlink" href="#asyncommonsyncio" title="Link to this heading"></a></h3>
<p>asynCommonSyncIO provides a convenient interface for software that needs to perform
“synchronous” operations to an asyn device, i.e. that blocks while waiting for the
port to be available and for the operation to complete. The code does not need to
handle callbacks or understand the details of the asynManager and asynCommon interfaces.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynCommonSyncIO</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                          <span class="n">asynUser</span> <span class="o">**</span><span class="n">ppasynUser</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">connectDevice</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnectDevice</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">report</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">FILE</span> <span class="o">*</span><span class="n">fd</span><span class="p">,</span> <span class="nb">int</span> <span class="n">details</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynCommonSyncIO</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynCommonSyncIO</span> <span class="o">*</span><span class="n">pasynCommonSyncIO</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that there is a potential for confusion in the connect* and disconnect* function
names of this interface. For consistency with the other SyncIO interfaces, connect
calls pasynManager-&gt;connectDevice, disconnect calls pasynManager-&gt;disconnect,
connectDevice calls asynCommon-&gt;connect, and disconnectDevice calls asynCommon-&gt;disconnect.</p>
</section>
<section id="asyndrvuser">
<h3><a class="toc-backref" href="#id101" role="doc-backlink">asynDrvUser</a><a class="headerlink" href="#asyndrvuser" title="Link to this heading"></a></h3>
<p>asynDrvUser provides methods that allow an asynUser to communicate user specific
information to/from a port driver</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define asynDrvUserType &quot;asynDrvUser&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span>  <span class="n">asynDrvUser</span> <span class="p">{</span>
    <span class="o">/*</span><span class="n">The</span> <span class="n">following</span> <span class="n">do</span> <span class="ow">not</span> <span class="n">have</span> <span class="n">to</span> <span class="n">be</span> <span class="n">called</span> <span class="n">via</span> <span class="n">queueRequest</span> <span class="n">callback</span><span class="o">*/</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
        <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">**</span><span class="n">pptypeName</span><span class="p">,</span><span class="n">size_t</span> <span class="o">*</span><span class="n">psize</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getType</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
        <span class="n">const</span> <span class="n">char</span> <span class="o">**</span><span class="n">pptypeName</span><span class="p">,</span><span class="n">size_t</span> <span class="o">*</span><span class="n">psize</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
<span class="p">}</span><span class="n">asynDrvUser</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id13">
<caption><span class="caption-text">asynDrvUser</span><a class="headerlink" href="#id13" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>create</p></td>
<td><p>The user, i.e. device support calls create. The driver can create any resources
it needs. It can use pasynUser-&gt;drvUser to provide access to the resources. If
the asynUser and the driver both know how to access the resources they must agree
about the name for the resource and a size. If pptypeName is not null the driver
can give a value to *pptypeName. If psize is not null the driver can give a value
to *psize. Unless asynUser receives a typeName and size that it recognizes it must
not access asynUser.drvUser.</p></td>
</tr>
<tr class="row-even"><td><p>getType</p></td>
<td><p>If other code, e.g. an interposeInterface wants to access asynUser.drvUser it must
call this and verify that typeName and size are what it expects.</p></td>
</tr>
<tr class="row-odd"><td><p>destroy</p></td>
<td><p>Destroy the resources created by create and set asynUser.drvUser null.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynlockportnotify">
<h3><a class="toc-backref" href="#id102" role="doc-backlink">asynLockPortNotify</a><a class="headerlink" href="#asynlockportnotify" title="Link to this heading"></a></h3>
<p>This is provided for port drivers that are an asynUser of another port driver. For
example a serial bus driver can be implemented by connecting to a standard serial
port to perform the actual I/O. When the serial bus port is locked, either by the
requester calling lockPort or because a queueRequest was dequeued, then the serial
bus driver needs to lock the associated serial port.</p>
<p>The serial bus driver registers interface asynLockPortNotify. Whenever the serial
bus port is locked, asynManager calls pasynLockPortNotify.lock. The serial bus driver
calls asynManager.lockPort for the serial port to which it is connected. Similarly
for unlockPort. Thus while the serial bus port is locked, the serial bus is also
locked.</p>
<p>asynLockPortNotify is used only by asynManager itself. It is not put in the list
of interfaces for the port.</p>
<p>asynLockPortNotify is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define asynLockPortNotifyType &quot;asynLockPortNotify&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span>  <span class="n">asynLockPortNotify</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">unlock</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynLockPortNotify</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id14">
<caption><span class="caption-text">asynLockPortNotify</span><a class="headerlink" href="#id14" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>lock</p></td>
<td><p>Called when asynManager.lockPort is called. The driver normally calls asynManager.lockPort
for the port to which it is connected.</p></td>
</tr>
<tr class="row-even"><td><p>unlock</p></td>
<td><p>Called when asynManager.unlockPort is called. The driver normally calls asynManager.unlockPort
for the port to which it is connected.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynoption">
<h3><a class="toc-backref" href="#id103" role="doc-backlink">asynOption</a><a class="headerlink" href="#asynoption" title="Link to this heading"></a></h3>
<p>asynOption provides a generic way of setting driver specific options. For example
the serial port driver uses this to specify baud rate, stop bits, etc.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define asynOptionType &quot;asynOption&quot;</span>
<span class="o">/*</span><span class="n">The</span> <span class="n">following</span> <span class="n">are</span> <span class="n">generic</span> <span class="n">methods</span> <span class="n">to</span> <span class="nb">set</span><span class="o">/</span><span class="n">get</span> <span class="n">device</span> <span class="n">options</span><span class="o">*/</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynOption</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setOption</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                                <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getOption</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                                <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="nb">int</span> <span class="n">sizeval</span><span class="p">);</span>
<span class="p">}</span><span class="n">asynOption</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id15">
<caption><span class="caption-text">asynOption</span><a class="headerlink" href="#id15" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>setOption</p></td>
<td><p>Set value associated with key.</p></td>
</tr>
<tr class="row-even"><td><p>getOption</p></td>
<td><p>Get value associated with key.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asyntrace">
<h3><a class="toc-backref" href="#id104" role="doc-backlink">asynTrace</a><a class="headerlink" href="#asyntrace" title="Link to this heading"></a></h3>
<p>asynDriver provides a trace facility with the following attributes:</p>
<ul>
<li><p>Tracing is turned on/off for individual devices, i.e. a portName, addr.</p></li>
<li><p>Trace has a global trace mask for asynUsers not connected to a port or port, addr.</p></li>
<li><p>The output is sent to a file or to stdout or to errlog.</p></li>
<li><p>A mask determines the type of information that can be displayed. The various choices
can be ORed together. The default value of this mask when a port is created is ASYN_TRACE_ERROR.</p>
<blockquote>
<div><ul class="simple">
<li><p>ASYN_TRACE_ERROR Run time errors are reported, e.g. timeouts.</p></li>
<li><p>ASYN_TRACEIO_DEVICE Device support reports I/O activity.</p></li>
<li><p>ASYN_TRACEIO_FILTER Any layer between device support and the low level driver
reports any filtering it does on I/O.</p></li>
<li><p>ASYN_TRACEIO_DRIVER Low level driver reports I/O activity.</p></li>
<li><p>ASYN_TRACE_FLOW Report logic flow. Device support should report all queue requests,
callbacks entered, and all calls to drivers. Layers between device support and low
level drivers should report all calls they make to lower level drivers. Low level
drivers report calls they make to other support.</p></li>
<li><p>ASYN_TRACE_WARNING Report warnings, i.e. conditions that are between ASYN_TRACE_ERROR
and ASYN_TRACE_FLOW.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Another mask determines how message buffers are printed. The various choices can
be ORed together. The default value of this mask when a port is created is ASYN_TRACEIO_NODATA.</p>
<blockquote>
<div><ul class="simple">
<li><p>ASYN_TRACEIO_NODATA Don’t print any data from the message buffers.</p></li>
<li><p>ASYN_TRACEIO_ASCII Print with a “%s” style format.</p></li>
<li><p>ASYN_TRACEIO_ESCAPE Call epicsStrPrintEscaped.</p></li>
<li><p>ASYN_TRACEIO_HEX Print each byte with ” %2.2x”.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Another mask determines what information is printed at the beginning of each message.
The various choices can be ORed together. The default value of this mask when a
port is created is ASYN_TRACEINFO_TIME.</p>
<blockquote>
<div><ul class="simple">
<li><p>ASYN_TRACEINFO_TIME prints the date and time of the message.</p></li>
<li><p>ASYN_TRACEINFO_PORT prints [port,addr,reason], where port is the port name, addr
is the asyn address, and reason is pasynUser-&gt;reason. These are the 3 pieces
of “addressing” information in asyn.</p></li>
<li><p>ASYN_TRACEINFO_SOURCE prints the file name and line number, i.e. [__FILE__,__LINE__]
where the asynPrint or asynPrintIO statement occurs.</p></li>
<li><p>ASYN_TRACEINFO_THREAD prints the thread name, thread ID and thread priority, i.e.
[epicsThreadGetNameSelf(), epicsThreadGetIdSelf(), epicsThreadGetPrioritySelf()].</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>In order for the trace facility to perform properly; device support and all drivers
must use the trace facility. Device and driver support can directly call the asynTrace
methods. The asynPrint and asynPrintIO macros are provided so that it is easier
for device/driver support. Support can have calls like</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asynPrint</span><span class="p">(</span><span class="n">pasynUser</span><span class="p">,</span><span class="n">ASYN_TRACE_FLOW</span><span class="p">,</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> Calling queueRequest</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">someName</span><span class="p">);</span>
</pre></div>
</div>
<p>The asynPrintIO call is designed for device support or drivers that issue read or
write requests. They make calls like</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asynPrintIO</span><span class="p">(</span><span class="n">pasynUser</span><span class="p">,</span><span class="n">ASYN_TRACEIO_DRIVER</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">nchars</span><span class="p">,</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> nchars </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">someName</span><span class="p">,</span><span class="n">nchars</span><span class="p">);</span>
</pre></div>
</div>
<p>The asynTrace methods are implemented by asynManager. These methods can be used
by any code that has created an asynUser and is connected to a device. All methods
can be called by any thread. That is, an application thread and/or a portThread.
If a thread performs all I/O via calls to print or printIO, then it does not have
to call lock or unlock. If it does want to do its own I/O, it must lock before any
I/O and unlock after. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pasynTrace</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">(</span><span class="n">pasynUser</span><span class="p">);</span>
<span class="n">fd</span> <span class="o">=</span> <span class="n">pasynTrace</span><span class="o">-&gt;</span><span class="n">getTraceFile</span><span class="p">(</span><span class="n">pasynUser</span><span class="p">);</span>
<span class="o">/*</span><span class="n">perform</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">to</span> <span class="n">fd</span> <span class="o">*/</span>
<span class="n">pasynTrace</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">(</span><span class="n">pasynUser</span><span class="p">);</span>
</pre></div>
</div>
<p>If the asynUser is not connected to a port, i.e. pasynManager-&gt;connectDevice
has not been called, then a “global” device is assumed. This is useful when asynPrint
is called before connectDevice.</p>
<p>This is the asynTrace interface:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span><span class="n">asynTrace</span> <span class="ow">is</span> <span class="n">implemented</span> <span class="n">by</span> <span class="n">asynManager</span><span class="o">*/</span>
<span class="o">/*</span><span class="n">All</span> <span class="n">asynTrace</span> <span class="n">methods</span> <span class="n">can</span> <span class="n">be</span> <span class="n">called</span> <span class="kn">from</span> <span class="nn">any</span> <span class="n">thread</span><span class="o">*/</span>
<span class="o">/*</span> <span class="n">traceMask</span> <span class="n">definitions</span><span class="o">*/</span>
<span class="c1">#define ASYN_TRACE_ERROR     0x0001</span>
<span class="c1">#define ASYN_TRACEIO_DEVICE  0x0002</span>
<span class="c1">#define ASYN_TRACEIO_FILTER  0x0004</span>
<span class="c1">#define ASYN_TRACEIO_DRIVER  0x0008</span>
<span class="c1">#define ASYN_TRACE_FLOW      0x0010</span>
<span class="c1">#define ASYN_TRACE_WARNING   0x0020</span>

<span class="o">/*</span> <span class="n">traceIO</span> <span class="n">mask</span> <span class="n">definitions</span><span class="o">*/</span>
<span class="c1">#define ASYN_TRACEIO_NODATA 0x0000</span>
<span class="c1">#define ASYN_TRACEIO_ASCII  0x0001</span>
<span class="c1">#define ASYN_TRACEIO_ESCAPE 0x0002</span>
<span class="c1">#define ASYN_TRACEIO_HEX    0x0004</span>

<span class="o">/*</span> <span class="n">traceInfo</span> <span class="n">mask</span> <span class="n">definitions</span><span class="o">*/</span>
<span class="c1">#define ASYN_TRACEINFO_TIME 0x0001</span>
<span class="c1">#define ASYN_TRACEINFO_PORT 0x0002</span>
<span class="c1">#define ASYN_TRACEINFO_SOURCE 0x0004</span>
<span class="c1">#define ASYN_TRACEINFO_THREAD 0x0008</span>

<span class="o">/*</span> <span class="n">asynPrint</span> <span class="ow">and</span> <span class="n">asynPrintIO</span> <span class="n">are</span> <span class="n">macros</span> <span class="n">that</span> <span class="n">act</span> <span class="n">like</span>
   <span class="nb">int</span> <span class="n">asynPrintSource</span><span class="p">(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">format</span><span class="p">,</span> <span class="o">...</span> <span class="p">);</span>
   <span class="nb">int</span> <span class="n">asynPrintIOSource</span><span class="p">(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span>
        <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="nb">len</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">format</span><span class="p">,</span> <span class="o">...</span> <span class="p">);</span>
<span class="o">*/</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynTrace</span> <span class="p">{</span>
    <span class="o">/*</span> <span class="n">lock</span><span class="o">/</span><span class="n">unlock</span> <span class="n">are</span> <span class="n">only</span> <span class="n">necessary</span> <span class="k">if</span> <span class="n">caller</span> <span class="n">performs</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">other</span> <span class="n">than</span> <span class="o">*/</span>
    <span class="o">/*</span> <span class="n">by</span> <span class="n">calling</span> <span class="n">asynTrace</span> <span class="n">methods</span>                                     <span class="o">*/</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">unlock</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setTraceMask</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">mask</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">getTraceMask</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setTraceIOMask</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">mask</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">getTraceIOMask</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setTraceInfoMask</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">mask</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">getTraceInfoMask</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setTraceFile</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
    <span class="n">FILE</span>       <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">getTraceFile</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setTraceIOTruncateSize</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="n">size_t</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">size_t</span>     <span class="p">(</span><span class="o">*</span><span class="n">getTraceIOTruncateSize</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
<span class="c1">#if defined(__GNUC__) &amp;&amp; (__GNUC__ &lt; 3)</span>
    <span class="o">/*</span> <span class="n">GCC</span> <span class="mf">2.95</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">allow</span> <span class="n">EPICS_PRINTF_STYLE</span> <span class="n">on</span> <span class="n">function</span> <span class="n">pointers</span> <span class="o">*/</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="nb">print</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">printSource</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">fileName</span><span class="p">,</span> <span class="nb">int</span> <span class="n">line</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">vprint</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="n">va_list</span> <span class="n">pvar</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">vprintSource</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="nb">int</span> <span class="n">line</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="n">va_list</span> <span class="n">pvar</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">printIO</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span>
                    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="nb">len</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">printIOSource</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span>
                    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="nb">len</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="nb">int</span> <span class="n">line</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">vprintIO</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span>
                    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="nb">len</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="n">va_list</span> <span class="n">pvar</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">vprintIOSource</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span>
                    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="nb">len</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="nb">int</span> <span class="n">line</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="n">va_list</span> <span class="n">pvar</span><span class="p">);</span>
<span class="c1">#else</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="nb">print</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="n">EPICS_PRINTF_STYLE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">printSource</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">fileName</span><span class="p">,</span> <span class="nb">int</span> <span class="n">line</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="n">EPICS_PRINTF_STYLE</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">vprint</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="n">va_list</span> <span class="n">pvar</span><span class="p">)</span> <span class="n">EPICS_PRINTF_STYLE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">vprintSource</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="nb">int</span> <span class="n">line</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="n">va_list</span> <span class="n">pvar</span><span class="p">)</span> <span class="n">EPICS_PRINTF_STYLE</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">printIO</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span>
                    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="nb">len</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="n">EPICS_PRINTF_STYLE</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">printIOSource</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span>
                    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="nb">len</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="nb">int</span> <span class="n">line</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="n">EPICS_PRINTF_STYLE</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">vprintIO</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span>
                    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="nb">len</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="n">va_list</span> <span class="n">pvar</span><span class="p">)</span> <span class="n">EPICS_PRINTF_STYLE</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="nb">int</span>        <span class="p">(</span><span class="o">*</span><span class="n">vprintIOSource</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">reason</span><span class="p">,</span>
                    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="nb">len</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="nb">int</span> <span class="n">line</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">pformat</span><span class="p">,</span> <span class="n">va_list</span> <span class="n">pvar</span><span class="p">)</span> <span class="n">EPICS_PRINTF_STYLE</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">#endif</span>
<span class="p">}</span><span class="n">asynTrace</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynTrace</span> <span class="o">*</span><span class="n">pasynTrace</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id16">
<caption><span class="caption-text">asynTrace</span><a class="headerlink" href="#id16" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>lock/unlock</p></td>
<td><p>These are only needed for code that call asynTrace.print or asynTrace.printIO instead
of asynPrint and asynPrintIO.</p>
<p>print, and printIO both lock while performing their operations. The get methods
do not lock (except for getTraceFile) and they are safe. Except for setTraceFile
the set methods do not block, since worst that can happen is that the user gets
a little more or a little less output.</p>
</td>
</tr>
<tr class="row-even"><td><p>setTraceMask</p></td>
<td><p>Set the trace mask. Normally set by the user requesting it via a shell command or
the devTrace device support. Setting the trace mask for a port also sets the trace
mask for all devices connected to that port</p></td>
</tr>
<tr class="row-odd"><td><p>getTraceMask</p></td>
<td><p>Get the trace mask. Device support that wants to issue trace messages calls this
to see what trace options have been requested.</p></td>
</tr>
<tr class="row-even"><td><p>setTraceIOMask</p></td>
<td><p>Set the traceIO mask. Normally set by the user requesting it via a shell command
or the devTrace device support. Setting the traceIO mask for a port also sets the
traceIO mask for all devices connected to that port</p></td>
</tr>
<tr class="row-odd"><td><p>getTraceIOMask</p></td>
<td><p>Get the traceIO mask. Support that wants to issue its own IO messages instead of
calling asynPrintIO should call this and honor the mask settings. Most code will
not need it.</p></td>
</tr>
<tr class="row-even"><td><p>setTraceInfoMask</p></td>
<td><p>Set the traceInfo mask. Normally set by the user requesting it via a shell command
or the devTrace device support. Setting the traceInfo mask for a port also sets
the traceInfo mask for all devices connected to that port</p></td>
</tr>
<tr class="row-odd"><td><p>getTraceInfoMask</p></td>
<td><p>Get the traceInfo mask. Support that wants to issue its own IO messages instead
of calling asynPrint should call this and honor the mask settings. Most code will
not need it.</p></td>
</tr>
<tr class="row-even"><td><p>setTraceFile</p></td>
<td><p>Set the stream to use for output. A NULL argument means use errlog. Normally set
by the user requesting it via a shell command or by the devTrace device support.
If the current output stream is none of (NULL, stdout, stderr) then the current
output stream is closed before the new stream is used.</p></td>
</tr>
<tr class="row-odd"><td><p>getTraceFile</p></td>
<td><p>Get the file descriptor to use for output. Device support that wants to issue its
own IO messages instead of calling asynPrintIO should call this and honor the mask
settings. In this case, lock must have been called first. Most code will not need
it. If the return value is 0, then ouput should be directed to errlog.</p></td>
</tr>
<tr class="row-even"><td><p>setTraceIOTruncateSize</p></td>
<td><p>Determines how much data is printed by printIO. In all cases it determines how many
bytes of the buffer are displayed. The actual number of characters printed depends
on the traceIO mask. For example ASYN_TRACEIO_HEX results in 3 characters being
printed for each byte. Normally set by the user requesting it via a shell command
or the devTrace device support.</p></td>
</tr>
<tr class="row-odd"><td><p>getTraceIOTruncateSize</p></td>
<td><p>Get the current truncate size. Called by asynPrintIO. Code that does its own I/O
should also support the traceIO mask.</p></td>
</tr>
<tr class="row-even"><td><p>print</p></td>
<td><p>If reason ORed with the current traceMask is not zero, then the message is printed.
This method is provided for backwards compatibility. The asynPrint macro now calls
printSource().</p></td>
</tr>
<tr class="row-odd"><td><p>printSource</p></td>
<td><p>If reason ORed with the current traceMask is not zero, then the message is printed.
Most code should call asynPrint instead of calling this method. This method is the
same as print() but with the additional <strong>file</strong> and <strong>line</strong> arguments.</p></td>
</tr>
<tr class="row-even"><td><p>vprint</p></td>
<td><p>This is the same as print, but using a va_list as its final argument.</p></td>
</tr>
<tr class="row-odd"><td><p>vprintSource</p></td>
<td><p>This is the same as printSource, but using a va_list as its final argument.</p></td>
</tr>
<tr class="row-even"><td><p>printIO</p></td>
<td><p>If reason ORed with the current traceMask is not zero then the message is printed.
If len is &gt;0, then the buffer is printed using the traceIO mask and getTraceIOTruncateSize.
This method is provided for backwards compatibility. The asynPrintIO macro now calls
printIOSource().</p></td>
</tr>
<tr class="row-odd"><td><p>printIOSource</p></td>
<td><p>If reason ORed with the current traceMask is not zero then the message is printed.
If len is &gt;0, then the buffer is printed using the traceIO mask and getTraceIOTruncateSize.
Most code should call asynPrintIO instead of calling this method. This method is
the same as printIO() but with the additional <strong>file</strong> and <strong>line</strong> arguments.</p></td>
</tr>
<tr class="row-even"><td><p>vprintIO</p></td>
<td><p>This is the same as printIO, but using a va_list as its final argument.</p></td>
</tr>
<tr class="row-odd"><td><p>vprintIOSource</p></td>
<td><p>This is the same as printIOSource, but using a va_list as its final argument.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="standard-message-based-interfaces">
<h2><a class="toc-backref" href="#id105" role="doc-backlink">Standard Message Based Interfaces</a><a class="headerlink" href="#standard-message-based-interfaces" title="Link to this heading"></a></h2>
<p>These are interfaces for communicating with message based devices, where message
based means that the device communicates via octet strings, i.e. arrays of 8 bit
bytes. Three interfaces are provided: asynOctet, asynOctetBase, and asynOctetSyncIO.
asynOctet is generic message based interface. asynOctetBase is an interface used
by port drivers that implement asynOctet. It’s primary purpose is to help with interrupt
support. asynOctetSyncIO provides a synchronous inteface to asynOctet and can be
used by code that is willing to block.</p>
<section id="asynoctet">
<h3><a class="toc-backref" href="#id106" role="doc-backlink">asynOctet</a><a class="headerlink" href="#asynoctet" title="Link to this heading"></a></h3>
<p>asynOctet describes the methods implemented by drivers that use octet strings for
sending commands and receiving responses from a device.</p>
<p>NOTE: The name octet is used instead of ASCII because it implies that communication
is done via 8-bit bytes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define ASYN_EOM_CNT 0x0001 /*Request count reached*/</span>
<span class="c1">#define ASYN_EOM_EOS 0x0002 /*End of String detected*/</span>
<span class="c1">#define ASYN_EOM_END 0x0004 /*End indicator detected*/</span>

<span class="n">typedef</span> <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">interruptCallbackOctet</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
              <span class="n">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="n">size_t</span> <span class="n">numchars</span><span class="p">,</span> <span class="nb">int</span> <span class="n">eomReason</span><span class="p">);</span>

<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynOctetInterrupt</span> <span class="p">{</span>
    <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">;</span>
    <span class="nb">int</span>      <span class="n">addr</span><span class="p">;</span>
    <span class="n">interruptCallbackOctet</span> <span class="n">callback</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">;</span>
<span class="p">}</span><span class="n">asynOctetInterrupt</span><span class="p">;</span>


<span class="c1">#define asynOctetType &quot;asynOctet&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynOctet</span><span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="n">size_t</span> <span class="n">numchars</span><span class="p">,</span><span class="n">size_t</span> <span class="o">*</span><span class="n">nbytesTransfered</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                    <span class="n">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="n">size_t</span> <span class="n">maxchars</span><span class="p">,</span><span class="n">size_t</span> <span class="o">*</span><span class="n">nbytesTransfered</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="o">*</span><span class="n">eomReason</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">registerInterruptUser</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                    <span class="n">interruptCallbackOctet</span> <span class="n">callback</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span>
                    <span class="n">void</span> <span class="o">**</span><span class="n">registrarPvt</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">cancelInterruptUser</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                    <span class="n">void</span> <span class="o">*</span><span class="n">registrarPvt</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setInputEos</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">eos</span><span class="p">,</span><span class="nb">int</span> <span class="n">eoslen</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getInputEos</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                    <span class="n">char</span> <span class="o">*</span><span class="n">eos</span><span class="p">,</span> <span class="nb">int</span> <span class="n">eossize</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">eoslen</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setOutputEos</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">eos</span><span class="p">,</span><span class="nb">int</span> <span class="n">eoslen</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getOutputEos</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                    <span class="n">char</span> <span class="o">*</span><span class="n">eos</span><span class="p">,</span> <span class="nb">int</span> <span class="n">eossize</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">eoslen</span><span class="p">);</span>
<span class="p">}</span><span class="n">asynOctet</span><span class="p">;</span>
<span class="o">/*</span> <span class="n">asynOctetBase</span> <span class="n">does</span> <span class="n">the</span> <span class="n">following</span><span class="p">:</span>
   <span class="n">calls</span>  <span class="n">registerInterface</span> <span class="k">for</span> <span class="n">asynOctet</span><span class="o">.</span>
   <span class="n">Implements</span> <span class="n">registerInterruptUser</span> <span class="ow">and</span> <span class="n">cancelInterruptUser</span>
   <span class="n">Provides</span> <span class="n">default</span> <span class="n">implementations</span> <span class="n">of</span> <span class="nb">all</span> <span class="n">methods</span><span class="o">.</span>
   <span class="n">registerInterruptUser</span> <span class="ow">and</span> <span class="n">cancelInterruptUser</span> <span class="n">can</span> <span class="n">be</span> <span class="n">called</span>
   <span class="n">directly</span> <span class="n">rather</span> <span class="n">than</span> <span class="n">via</span> <span class="n">queueRequest</span><span class="o">.</span>
<span class="o">*/</span>

<span class="c1">#define asynOctetBaseType &quot;asynOctetBase&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynOctetBase</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">initialize</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span>
        <span class="n">asynDriverasynInterface</span> <span class="o">*</span><span class="n">pasynOctetInterface</span><span class="p">,</span>
        <span class="nb">int</span> <span class="n">processEosIn</span><span class="p">,</span><span class="nb">int</span> <span class="n">processEosOut</span><span class="p">,</span><span class="nb">int</span> <span class="n">interruptProcess</span><span class="p">);</span>
    <span class="n">void</span>       <span class="p">(</span><span class="o">*</span><span class="n">callInterruptUsers</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="n">void</span> <span class="o">*</span><span class="n">pasynPvt</span><span class="p">,</span>
        <span class="n">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="n">size_t</span> <span class="o">*</span><span class="n">nbytesTransfered</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">eomReason</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynOctetBase</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynOctetBase</span> <span class="o">*</span><span class="n">pasynOctetBase</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id17">
<caption><span class="caption-text">asynOctet</span><a class="headerlink" href="#id17" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Send a message to the device. *nbytesTransfered is the number of 8-bit bytes sent
to the device. Interpose or driver code may add end of string terminators to the
message but the extra characters are not included in *nbytesTransfered.</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Read a message from the device. *nbytesTransfered is the number of 8-bit bytes read
from the device. If read returns asynSuccess than eomReason ( some combination of
ASYN_EOM_CNT, ASYN_EOM_EOS, and ASYN_EOM_END)tells why the read completed. Interpose
or driver code may strip end of string terminators from the message. If it does
the first eos character will be replaced by null and the eos characters will not
be included in nbytesTransfered.</p></td>
</tr>
<tr class="row-odd"><td><p>flush</p></td>
<td><p>Flush the input buffer.</p></td>
</tr>
<tr class="row-even"><td><p>registerInterruptUser</p></td>
<td><p>Register a user that will be called whenever a new message is received. NOTE: The
callback must not block and must not call registerInterruptUser or cancelInterruptUser.</p></td>
</tr>
<tr class="row-odd"><td><p>cancelInterruptUser</p></td>
<td><p>Cancel a registered user.</p></td>
</tr>
<tr class="row-even"><td><p>setInputEos</p></td>
<td><p>Set End Of String for input. For example “\n”. Note that gpib drivers usually accept
at most a one character terminator.</p></td>
</tr>
<tr class="row-odd"><td><p>getInputEos</p></td>
<td><p>Get the current End of String.</p></td>
</tr>
<tr class="row-even"><td><p>setOutputEos</p></td>
<td><p>Set End Of String for output.</p></td>
</tr>
<tr class="row-odd"><td><p>getOutputEos</p></td>
<td><p>Get the current End of String.</p></td>
</tr>
</tbody>
</table>
<p>asynOctetBase is an interface and implementation for drivers that implement interface
asynOctet. asynOctetBase implements registerInterruptUser and cancelInterruptUser.</p>
<p>For single device support, it can optionally implement interrupt support. A driver
that implements interrupts must call registerInterruptSource. If it asks asynOctetBase
to handle interrupts it calls asynOctetBase:callInterruptUsers when it has new data.</p>
<p>For single device support asynOctetBase can optionally call asynInterposeEosConfig
to handle end of string processing for input and/or output.</p>
<p>Any null method in the interface passed to initialize are replaced by a method supplied
by asynOctetBase.</p>
<p>For an example of how to use asynOctetBase look at <code class="docutils literal notranslate"><span class="pre">asyn/testApp/src/echoDriver.c</span></code></p>
<table class="docutils align-default" id="id18">
<caption><span class="caption-text">asynOctetBase</span><a class="headerlink" href="#id18" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>initialize</p></td>
<td><p>After a driver calls registerPort it can call</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pasynOctetBase</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">(</span><span class="o">...</span>
</pre></div>
</div>
<p>Any null methods in the asynInterface are replaced by default implementations. If
the port is not multi-device and either processEosIn or processEosOut is specified,
asynInterposeEosConfig is called. If the port is not multi-device and interruptProcess
is specified, then whenever read is called, asynBase calls all the registered interrupt
users. asynOctetBase can not implement processEosIn, processEosOut, and interruptProcess
if the port is a multi-device port. Since this method is called only during initialization
it can be called directly rather than via queueRequest.</p>
</td>
</tr>
<tr class="row-even"><td><p>callInterruptUsers</p></td>
<td><p>Calls the callbacks registered via registerInterruptUser.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynoctetsyncio">
<h3><a class="toc-backref" href="#id107" role="doc-backlink">asynOctetSyncIO</a><a class="headerlink" href="#asynoctetsyncio" title="Link to this heading"></a></h3>
<p>asynOctetSyncIO provides a convenient interface for software that needs to perform
“synchronous” I/O to an asyn device, i.e. that starts an I/O operation and then
blocks while waiting for the response. The code does not need to handle callbacks
or understand the details of the asynManager and asynOctet interfaces. Examples
include motor drivers running in their own threads, SNL programs, and the shell
commands described later in this document.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynOctetSyncIO</span> <span class="p">{</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                         <span class="n">asynUser</span> <span class="o">**</span><span class="n">ppasynUser</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                  <span class="n">char</span> <span class="n">const</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">buffer_len</span><span class="p">,</span>
                  <span class="n">double</span> <span class="n">timeout</span><span class="p">,</span><span class="n">size_t</span> <span class="o">*</span><span class="n">nbytesTransfered</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">buffer_len</span><span class="p">,</span>
                  <span class="n">double</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">nbytesTransfered</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">eomReason</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">writeRead</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                  <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">write_buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">write_buffer_len</span><span class="p">,</span>
                  <span class="n">char</span> <span class="o">*</span><span class="n">read_buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">read_buffer_len</span><span class="p">,</span>
                  <span class="n">double</span> <span class="n">timeout</span><span class="p">,</span>
                  <span class="n">size_t</span> <span class="o">*</span><span class="n">nbytesOut</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">nbytesIn</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">eomReason</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setInputEos</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                  <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">eos</span><span class="p">,</span><span class="nb">int</span> <span class="n">eoslen</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getInputEos</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                  <span class="n">char</span> <span class="o">*</span><span class="n">eos</span><span class="p">,</span> <span class="nb">int</span> <span class="n">eossize</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">eoslen</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setOutputEos</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                  <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">eos</span><span class="p">,</span><span class="nb">int</span> <span class="n">eoslen</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getOutputEos</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                  <span class="n">char</span> <span class="o">*</span><span class="n">eos</span><span class="p">,</span> <span class="nb">int</span> <span class="n">eossize</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">eoslen</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">writeOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                  <span class="n">char</span> <span class="n">const</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">buffer_len</span><span class="p">,</span> <span class="n">double</span> <span class="n">timeout</span><span class="p">,</span>
                  <span class="n">size_t</span> <span class="o">*</span><span class="n">nbytesTransfered</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">readOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                  <span class="n">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">buffer_len</span><span class="p">,</span> <span class="n">double</span> <span class="n">timeout</span><span class="p">,</span>
                  <span class="n">size_t</span> <span class="o">*</span><span class="n">nbytesTransfered</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">eomReason</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">writeReadOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                  <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">write_buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">write_buffer_len</span><span class="p">,</span>
                  <span class="n">char</span> <span class="o">*</span><span class="n">read_buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">read_buffer_len</span><span class="p">,</span>
                  <span class="n">double</span> <span class="n">timeout</span><span class="p">,</span>
                  <span class="n">size_t</span> <span class="o">*</span><span class="n">nbytesOut</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">nbytesIn</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">eomReason</span><span class="p">,</span>
                  <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">flushOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setInputEosOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                  <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">eos</span><span class="p">,</span><span class="nb">int</span> <span class="n">eoslen</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getInputEosOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                  <span class="n">char</span> <span class="o">*</span><span class="n">eos</span><span class="p">,</span> <span class="nb">int</span> <span class="n">eossize</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">eoslen</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setOutputEosOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                  <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">eos</span><span class="p">,</span><span class="nb">int</span> <span class="n">eoslen</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
   <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getOutputEosOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                  <span class="n">char</span> <span class="o">*</span><span class="n">eos</span><span class="p">,</span> <span class="nb">int</span> <span class="n">eossize</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">eoslen</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynOctetSyncIO</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynOctetSyncIO</span> <span class="o">*</span><span class="n">pasynOctetSyncIO</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id19">
<caption><span class="caption-text">asynOctetSyncIO</span><a class="headerlink" href="#id19" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>connect</p></td>
<td><p>Connects to an asyn port and address, returns a pointer to an asynUser structure.</p></td>
</tr>
<tr class="row-even"><td><p>disconnect</p></td>
<td><p>Disconnect. This frees all resources allocated by connect.</p></td>
</tr>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Calls asynOctet-&gt;write and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Calls asynOctet-&gt;read. Waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-odd"><td><p>writeRead</p></td>
<td><p>Calls pasynOctet-&gt;flush, pasynOctet-&gt;write, and asynOctet-&gt;read. Waits
for the operations to complete or time out.</p></td>
</tr>
<tr class="row-even"><td><p>flush</p></td>
<td><p>Calls pasynOctet-&gt;flush</p></td>
</tr>
<tr class="row-odd"><td><p>setInputEos</p></td>
<td><p>Calls pasynOctet-&gt;setInputEos</p></td>
</tr>
<tr class="row-even"><td><p>getInputEos</p></td>
<td><p>Calls pasynOctet-&gt;getInputEos</p></td>
</tr>
<tr class="row-odd"><td><p>setOutputEos</p></td>
<td><p>Calls pasynOctet-&gt;setOutputEos</p></td>
</tr>
<tr class="row-even"><td><p>getOutputEos</p></td>
<td><p>Calls pasynOctet-&gt;getOutputEos</p></td>
</tr>
<tr class="row-odd"><td><p>writeOnce</p></td>
<td><p>This does a connect, write, and disconnect.</p></td>
</tr>
<tr class="row-even"><td><p>readOnce</p></td>
<td><p>This does a connect, read, and disconnect.</p></td>
</tr>
<tr class="row-odd"><td><p>readOnce</p></td>
<td><p>This does a connect, read, and disconnect.</p></td>
</tr>
<tr class="row-even"><td><p>writeReadOnce</p></td>
<td><p>This does a connect, writeRead, and disconnect.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="end-of-string-support">
<h3><a class="toc-backref" href="#id108" role="doc-backlink">End of String Support</a><a class="headerlink" href="#end-of-string-support" title="Link to this heading"></a></h3>
<p>asynOctet provides methods for handling end of string (message) processing. It does
not specify policy. Device support code, interpose layers, or low level drivers
can all handle EOS processing. An application developer must decide what policy
will be followed for individual devices. The policy will be determined by the device,
the device support, and the driver.</p>
</section>
</section>
<section id="standard-register-based-interfaces">
<h2><a class="toc-backref" href="#id109" role="doc-backlink">Standard Register Based Interfaces</a><a class="headerlink" href="#standard-register-based-interfaces" title="Link to this heading"></a></h2>
<section id="introduction">
<h3><a class="toc-backref" href="#id110" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading"></a></h3>
<p>This section describes interfaces for register based devices. Support is provided
for:</p>
<ul class="simple">
<li><p>Int32 - registers appear as 32 integers</p></li>
<li><p>Int64 - registers appear as 64 integers</p></li>
<li><p>UInt32Digital - registers appear a 32 bit unsigned integers and masks can be used
to address specific bits.</p></li>
<li><p>Float64 - registers appear as double precision floats.</p></li>
<li><p>Int8Array - Arrays of 8 bit integers.</p></li>
<li><p>Int16Array - Arrays of 16 bit integers.</p></li>
<li><p>Int32Array - Arrays of 32 bit integers.</p></li>
<li><p>Int64Array - Arrays of 64 bit integers.</p></li>
<li><p>Float32Array - Arrays of single precision floats.</p></li>
<li><p>Float64Array - Arrays of double precision floats.</p></li>
<li><p>Enum - Arrays of strings, integer values and integer severities.</p></li>
<li><p>GenericPointer - void* pointer.</p></li>
</ul>
<p>Note that hardware may have registers with smaller sizes, e.g. 16 bit registers.
The standard interfaces can still be used by setting the unused bits to 0.</p>
<p>For all of these interfaces a default implementation and a synchronous inplementation
are provided. Let’s use Int32 as an example.</p>
<ul>
<li><p>asynInt32 - An interface with methods: read, write, getBounds, registerInterruptUser,
and cancelInterruptUser.</p></li>
<li><p>asynInt32Base - An interface used by drivers that implement asynInt32. It also
has an implementation that:</p>
<blockquote>
<div><ul class="simple">
<li><p>registers the asynInt32 interface</p></li>
<li><p>has default methods for read, write, and getBounds. A null method in the interface
passed to initialize is replaced by a method implemented by asynInt32Base.</p></li>
<li><p>implements registerInterruptUser and cancelInterruptUser. The caller should leave
these methods null because asynInt32Base always replaces them by it’s implementation.</p></li>
</ul>
</div></blockquote>
<p>Drivers that implement asynInt32 normally call asynInt32Base:initialize. It implements
registerInterruptUser and cancelInterruptUser. If the driver provides interrupt
support it must:</p>
<blockquote>
<div><ul class="simple">
<li><p>Call <code class="docutils literal notranslate"><span class="pre">pasynInt32Base-&gt;initialize</span></code></p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">pasynManager-&gt;registerInterruptSource</span></code></p></li>
<li><p>Interact with asynManager to call the users that have registered with asynInt32Base:registerInterruptUser.
The driver calls users when there is new data available.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">asyn/testEpicsApp/src/int32Driver.c</span></code> provides
an example of how to provide support for interrupts.</p>
</li>
<li><p>asynInt32SyncIO - A synchronous interface to asynInt32</p></li>
</ul>
<p><strong>addr - What does it mean for register based interfaces?</strong></p>
<p>Low level register based drivers are normally multi-device. The meaning of addr
is:</p>
<ul class="simple">
<li><p>Int32 - The driver supports an array of Int32 values. addr selects an array element.
For example a 16 channel ADC would support addr 0 through 15.</p></li>
<li><p>Int64 - The driver supports an array of Int64 values. addr selects an array element.</p></li>
<li><p>Int8Array - Each addr is an array of Int8 values.</p></li>
<li><p>Int16Array - Each addr is an array of Int16 values.</p></li>
<li><p>Int32Array - Each addr is an array of Int32 values.</p></li>
<li><p>Int64Array - Each addr is an array of Int64 values.</p></li>
<li><p>Float64 - The driver supports an array of Float64 values. addr selects an array
element.</p></li>
<li><p>Float32Array - Each addr is an array of Float32 values.</p></li>
<li><p>Float64Array - Each addr is an array of Float64 values.</p></li>
<li><p>UInt32Digital - The driver supports an array of UInt32 values. addr selects an
array element. For example a 128 bit digital I/O module appears as an array of four
UInt32 registers.</p></li>
</ul>
</section>
<section id="example-drivers">
<h3><a class="toc-backref" href="#id111" role="doc-backlink">Example Drivers</a><a class="headerlink" href="#example-drivers" title="Link to this heading"></a></h3>
<p>Two examples of drivers that might implement and use the interfaces are:
- Analog to Digital Converter.</p>
<blockquote>
<div><p>An example is a 16 channel ADC. The driver implements interfaces asynCommon and
asynInt32. It uses interface asynInt32Base. It can call asynManager:interruptStart
and asynManager:interruptEnd to support interrupts. It can use pasynUser-&gt;reason
and addr to decide which callbacks to call. <code class="docutils literal notranslate"><span class="pre">asyn/testEpicsApp/int32Driver.c</span></code>
is a soft example of how to implement a driver that implements asynInt32 and also
asynFloat64.</p>
</div></blockquote>
<ul>
<li><p>Digital I/O module</p>
<p>An example is a 64 bit combination digital input and digital output module. The
driver implements interfaces asynCommon and asynUInt32Digital. It uses interface
asynUInt32DigitalBase. It can call asynManager:interruptStart and asynManager:interruptEnd
to support interrupts. It can use reason, mask, and addr to decide which callbacks
to call. <code class="docutils literal notranslate"><span class="pre">asyn/testEpicsApp/uint32DigitalDriver.c</span></code>
is a soft example of a driver that implements asynUInt32Digital.</p>
</li>
</ul>
</section>
<section id="asynintxx-xx-32-or-64">
<h3><a class="toc-backref" href="#id112" role="doc-backlink">asynIntXX (XX=32 or 64)</a><a class="headerlink" href="#asynintxx-xx-32-or-64" title="Link to this heading"></a></h3>
<p>asynIntXX describes the methods implemented by drivers that use integers for communicating
with a device.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">interruptCallbackIntXX</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                                       <span class="n">epicsIntXX</span> <span class="n">data</span><span class="p">);</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynIntXXInterrupt</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">addr</span><span class="p">;</span>
    <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">;</span>
    <span class="n">interruptCallbackIntXX</span> <span class="n">callback</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">;</span>
<span class="p">}</span> <span class="n">asynIntXXInterrupt</span><span class="p">;</span>
<span class="c1">#define asynIntXXType &quot;asynIntXX&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynIntXX</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">epicsIntXX</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">epicsIntXX</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getBounds</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                           <span class="n">epicsIntXX</span> <span class="o">*</span><span class="n">low</span><span class="p">,</span> <span class="n">epicsIntXX</span> <span class="o">*</span><span class="n">high</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">registerInterruptUser</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                           <span class="n">interruptCallbackIntXX</span> <span class="n">callback</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span>
                           <span class="n">void</span> <span class="o">**</span><span class="n">registrarPvt</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">cancelInterruptUser</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                    <span class="n">void</span> <span class="o">*</span><span class="n">registrarPvt</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynIntXX</span><span class="p">;</span>

<span class="o">/*</span> <span class="n">asynIntXXBase</span> <span class="n">does</span> <span class="n">the</span> <span class="n">following</span><span class="p">:</span>
   <span class="n">calls</span>  <span class="n">registerInterface</span> <span class="k">for</span> <span class="n">asynIntXX</span><span class="o">.</span>
   <span class="n">Implements</span> <span class="n">registerInterruptUser</span> <span class="ow">and</span> <span class="n">cancelInterruptUser</span>
   <span class="n">Provides</span> <span class="n">default</span> <span class="n">implementations</span> <span class="n">of</span> <span class="nb">all</span> <span class="n">methods</span><span class="o">.</span>
   <span class="n">registerInterruptUser</span> <span class="ow">and</span> <span class="n">cancelInterruptUser</span> <span class="n">can</span> <span class="n">be</span> <span class="n">called</span>
   <span class="n">directly</span> <span class="n">rather</span> <span class="n">than</span> <span class="n">via</span> <span class="n">queueRequest</span><span class="o">.</span>
<span class="o">*/</span>

<span class="c1">#define asynIntXXBaseType &quot;asynIntXXBase&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynIntXXBase</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">initialize</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span>
                            <span class="n">asynInterface</span> <span class="o">*</span><span class="n">pintXXInterface</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynIntXXBase</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynIntXXBase</span> <span class="o">*</span><span class="n">pasynIntXXBase</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id20">
<caption><span class="caption-text">asynIntXX</span><a class="headerlink" href="#id20" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Write an integer value to the device.</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Read an integer value from the device.</p></td>
</tr>
<tr class="row-odd"><td><p>getBounds</p></td>
<td><p>Get the bounds. For example a 16 bit ADC might set low=-32768 and high = 32767.</p></td>
</tr>
<tr class="row-even"><td><p>registerInterruptUser</p></td>
<td><p>Registers a callback that will be called whenever new data is available. Since it
can be called directly rather than via a queueRequest this method must not block.</p></td>
</tr>
<tr class="row-odd"><td><p>cancelInterruptUser</p></td>
<td><p>Cancels the callback. Since it can be called directly rather than via a queueRequest
this method must not block.</p></td>
</tr>
</tbody>
</table>
<p>asynIntXXBase is an interface and associated code that is used by drivers that implement
interface asynIntXX. asynIntXXBase provides code to handle registerInterruptUser/cancelInterruptUser.
The driver must itself call the callbacks via calls to asynManager:interruptStart
and asynManager:interruptEnd.</p>
<table class="docutils align-default" id="id21">
<caption><span class="caption-text">asynIntXXBase</span><a class="headerlink" href="#id21" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>initialize</p></td>
<td><p>After a driver calls registerPort it can call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pasynIntXXBase</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">(</span><span class="o">...</span>
</pre></div>
</div>
<p>Any null methods in the asynInterface are replaced by default implementations.</p>
</td>
</tr>
</tbody>
</table>
<p>The default implementation of each method does the following:</p>
<table class="docutils align-default" id="id22">
<caption><span class="caption-text">asynIntXX</span><a class="headerlink" href="#id22" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Reports an error “write is not supported” and returns asynError</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Reports an error “read is not supported” and returns asynError</p></td>
</tr>
<tr class="row-odd"><td><p>getBounds</p></td>
<td><p>Reports an error “getBounds is not supported” and returns asynError</p></td>
</tr>
<tr class="row-even"><td><p>registerInterruptUser</p></td>
<td><p>registers an interrupt callback.</p></td>
</tr>
<tr class="row-odd"><td><p>cancelInterruptUser</p></td>
<td><p>Cancels the callback</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynintxxsyncio-xx-32-or-64">
<h3><a class="toc-backref" href="#id113" role="doc-backlink">asynIntXXSyncIO (XX=32 or 64)</a><a class="headerlink" href="#asynintxxsyncio-xx-32-or-64" title="Link to this heading"></a></h3>
<p>asynIntXXSyncIO describes a synchronous interface to asynIntXX. The code that calls
it must be willing to block.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define asynIntXXSyncIOType &quot;asynIntXXSyncIO&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynIntXXSyncIO</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                          <span class="n">asynUser</span> <span class="o">**</span><span class="n">ppasynUser</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">epicsIntXX</span> <span class="n">value</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">epicsIntXX</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getBounds</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                    <span class="n">epicsIntXX</span> <span class="o">*</span><span class="n">plow</span><span class="p">,</span> <span class="n">epicsIntXX</span> <span class="o">*</span><span class="n">phigh</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">writeOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                    <span class="n">epicsIntXX</span> <span class="n">value</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">readOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                    <span class="n">epicsIntXX</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getBoundsOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                    <span class="n">epicsIntXX</span> <span class="o">*</span><span class="n">plow</span><span class="p">,</span> <span class="n">epicsIntXX</span> <span class="o">*</span><span class="n">phigh</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynIntXXSyncIO</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynIntXXSyncIO</span> <span class="o">*</span><span class="n">pasynIntXXSyncIO</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id23">
<caption><span class="caption-text">asynIntXXSyncIO</span><a class="headerlink" href="#id23" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>connect</p></td>
<td><p>Connects to a port and address, returns a pointer to an asynUser.</p></td>
</tr>
<tr class="row-even"><td><p>disconnect</p></td>
<td><p>Disconnect. This frees all resources allocated by connect.</p></td>
</tr>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Calls pasynIntXX-&gt;write and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Calls pasynIntXX-&gt;read and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-odd"><td><p>getBounds</p></td>
<td><p>Calls pasynIntXX-&gt;getBounds and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-even"><td><p>writeOnce</p></td>
<td><p>This does a connect, write, and disconnect.</p></td>
</tr>
<tr class="row-odd"><td><p>readOnce</p></td>
<td><p>This does a connect, read, and disconnect.</p></td>
</tr>
<tr class="row-even"><td><p>getBoundsOnce</p></td>
<td><p>This does a connect, getBounds, and disconnect.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynuint32digital">
<h3><a class="toc-backref" href="#id114" role="doc-backlink">asynUInt32Digital</a><a class="headerlink" href="#asynuint32digital" title="Link to this heading"></a></h3>
<p>asynUInt32Digital describes the methods for communicating via bits of an Int32 register.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">enum</span> <span class="p">{</span>
    <span class="n">interruptOnZeroToOne</span><span class="p">,</span> <span class="n">interruptOnOneToZero</span><span class="p">,</span> <span class="n">interruptOnBoth</span>
<span class="p">}</span> <span class="n">interruptReason</span><span class="p">;</span>

<span class="n">typedef</span> <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">interruptCallbackUInt32Digital</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span>
                 <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">epicsUInt32</span> <span class="n">data</span><span class="p">);</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynUInt32DigitalInterrupt</span> <span class="p">{</span>
    <span class="n">epicsUInt32</span> <span class="n">mask</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">addr</span><span class="p">;</span>
    <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">;</span>
    <span class="n">interruptCallbackUInt32Digital</span> <span class="n">callback</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">;</span>
<span class="p">}</span> <span class="n">asynUInt32DigitalInterrupt</span><span class="p">;</span>
<span class="c1">#define asynUInt32DigitalType &quot;asynUInt32Digital&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynUInt32Digital</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
         <span class="n">epicsUInt32</span> <span class="n">value</span><span class="p">,</span> <span class="n">epicsUInt32</span> <span class="n">mask</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
        <span class="n">epicsUInt32</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">epicsUInt32</span> <span class="n">mask</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setInterrupt</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
        <span class="n">epicsUInt32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">interruptReason</span> <span class="n">reason</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">clearInterrupt</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
        <span class="n">epicsUInt32</span> <span class="n">mask</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getInterrupt</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
        <span class="n">epicsUInt32</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">interruptReason</span> <span class="n">reason</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">registerInterruptUser</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
        <span class="n">interruptCallbackUInt32Digital</span> <span class="n">callback</span><span class="p">,</span><span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span><span class="n">epicsUInt32</span> <span class="n">mask</span><span class="p">,</span>
        <span class="n">void</span> <span class="o">**</span><span class="n">registrarPvt</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">cancelInterruptUser</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                    <span class="n">void</span> <span class="o">*</span><span class="n">registrarPvt</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynUInt32Digital</span><span class="p">;</span>

<span class="o">/*</span> <span class="n">asynUInt32DigitalBase</span> <span class="n">does</span> <span class="n">the</span> <span class="n">following</span><span class="p">:</span>
   <span class="n">calls</span>  <span class="n">registerInterface</span> <span class="k">for</span> <span class="n">asynUInt32Digital</span><span class="o">.</span>
   <span class="n">Implements</span> <span class="n">registerInterruptUser</span> <span class="ow">and</span> <span class="n">cancelInterruptUser</span>
   <span class="n">Provides</span> <span class="n">default</span> <span class="n">implementations</span> <span class="n">of</span> <span class="nb">all</span> <span class="n">methods</span><span class="o">.</span>
   <span class="n">registerInterruptUser</span> <span class="ow">and</span> <span class="n">cancelInterruptUser</span> <span class="n">can</span> <span class="n">be</span> <span class="n">called</span>
   <span class="n">directly</span> <span class="n">rather</span> <span class="n">than</span> <span class="n">via</span> <span class="n">queueRequest</span><span class="o">.</span>
<span class="o">*/</span>

<span class="c1">#define asynUInt32DigitalBaseType &quot;asynUInt32DigitalBase&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynUInt32DigitalBase</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">initialize</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span>
                            <span class="n">asynInterface</span> <span class="o">*</span><span class="n">pasynUInt32DigitalInterface</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynUInt32DigitalBase</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynUInt32DigitalBase</span> <span class="o">*</span><span class="n">pasynUInt32DigitalBase</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id24">
<caption><span class="caption-text">asynUInt32Digital</span><a class="headerlink" href="#id24" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Modify the bits specified by mask with the corresponding bits in value.</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Read the bits specified by mask into value. The other bits of value will be set
to 0.</p></td>
</tr>
<tr class="row-odd"><td><p>setInterrupt</p></td>
<td><p>Set the bits specified by mask to interrupt for reason.</p></td>
</tr>
<tr class="row-even"><td><p>clearInterrupt</p></td>
<td><p>Clear the interrupt bits specified by mask.</p></td>
</tr>
<tr class="row-odd"><td><p>getInterrupt</p></td>
<td><p>Set each bit of mask that is enabled for reason.</p></td>
</tr>
<tr class="row-even"><td><p>registerInterruptUser</p></td>
<td><p>Register a callback that will be called whenever the driver detects a change in
any of the bits specified by mask. Since it can be called directly rather than via
a queueRequest this method must not block.</p></td>
</tr>
<tr class="row-odd"><td><p>cancelInterruptUser</p></td>
<td><p>Cancels the registered callback. Since it can be called directly rather than via
a queueRequest this method must not block.</p></td>
</tr>
</tbody>
</table>
<p>asynUInt32DigitalBase is an interface and associated code that is used by drivers
that implement interface asynUInt32Digital. asynUInt32DigitalBase provides code
to implement registerInterruptUser and cancelInterruptUser.</p>
<table class="docutils align-default" id="id25">
<caption><span class="caption-text">asynUInt32DigitalBase</span><a class="headerlink" href="#id25" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>initialize</p></td>
<td><p>After a driver calls registerPort it can call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pasynUInt32DigitalBase</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">(</span><span class="o">...</span>
</pre></div>
</div>
<p>Any null methods in the asynInterface are replaced by default implementations.</p>
</td>
</tr>
</tbody>
</table>
<p>The default implementation of each method does the following:</p>
<table class="docutils align-default" id="id26">
<caption><span class="caption-text">asynUInt32Digital</span><a class="headerlink" href="#id26" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Reports an error “write is not supported” and returns asynError</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Reports an error “read is not supported” and returns asynError</p></td>
</tr>
<tr class="row-odd"><td><p>setInterrupt</p></td>
<td><p>Reports an error “setInterrupt is not supported” and returns asynError</p></td>
</tr>
<tr class="row-even"><td><p>clearInterrupt</p></td>
<td><p>Reports an error “clearInterrupt is not supported” and returns asynError</p></td>
</tr>
<tr class="row-odd"><td><p>getInterrupt</p></td>
<td><p>Reports an error “getInterrupt is not supported” and returns asynError</p></td>
</tr>
<tr class="row-even"><td><p>registerInterruptUser</p></td>
<td><p>registers the interrupt user. The low level driver must call the registered callbacks
via calls to asynManager:interruptStart and asynManager:interruptEnd.</p></td>
</tr>
<tr class="row-odd"><td><p>cancelInterruptUser</p></td>
<td><p>Cancels the callback</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynuint32digitalsyncio">
<h3><a class="toc-backref" href="#id115" role="doc-backlink">asynUInt32DigitalSyncIO</a><a class="headerlink" href="#asynuint32digitalsyncio" title="Link to this heading"></a></h3>
<p>asynUInt32DigitalSyncIO describes a synchronous interface to asynUInt32Digital.
The code that calls it must be willing to block.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define asynUInt32DigitalSyncIOType &quot;asynUInt32DigitalSyncIO&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynUInt32DigitalSyncIO</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                       <span class="n">asynUser</span> <span class="o">**</span><span class="n">ppasynUser</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                       <span class="n">epicsUInt32</span> <span class="n">value</span><span class="p">,</span><span class="n">epicsUInt32</span> <span class="n">mask</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                       <span class="n">epicsUInt32</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">,</span><span class="n">epicsUInt32</span> <span class="n">mask</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setInterrupt</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                       <span class="n">epicsUInt32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">interruptReason</span> <span class="n">reason</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">clearInterrupt</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                       <span class="n">epicsUInt32</span> <span class="n">mask</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getInterrupt</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                       <span class="n">epicsUInt32</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">interruptReason</span> <span class="n">reason</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">writeOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                       <span class="n">epicsUInt32</span> <span class="n">value</span><span class="p">,</span><span class="n">epicsUInt32</span> <span class="n">mask</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">,</span>
                       <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">readOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                       <span class="n">epicsUInt32</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">,</span><span class="n">epicsUInt32</span> <span class="n">mask</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">,</span>
                       <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setInterruptOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                       <span class="n">epicsUInt32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">interruptReason</span> <span class="n">reason</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">,</span>
                       <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">clearInterruptOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                       <span class="n">epicsUInt32</span> <span class="n">mask</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getInterruptOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                       <span class="n">epicsUInt32</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">interruptReason</span> <span class="n">reason</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">,</span>
                       <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynUInt32DigitalSyncIO</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynUInt32DigitalSyncIO</span> <span class="o">*</span><span class="n">pasynUInt32DigitalSyncIO</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id27">
<caption><span class="caption-text">asynUInt32DigitalSyncIO</span><a class="headerlink" href="#id27" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>connect</p></td>
<td><p>Connects to a port and address, returns a pointer to an asynUser structure.</p></td>
</tr>
<tr class="row-even"><td><p>disconnect</p></td>
<td><p>Disconnect. This frees all resources allocated by connect.</p></td>
</tr>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Calls pasynUInt32Digital-&gt;write and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Calls pasynUInt32Digital-&gt;read and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-odd"><td><p>setInterrupt</p></td>
<td><p>Calls pasynUInt32Digital-&gt;setInterrupt and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-even"><td><p>clearInterrupt</p></td>
<td><p>Calls pasynUInt32Digital-&gt;clearInterrupt and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-odd"><td><p>getInterrupt</p></td>
<td><p>Calls pasynUInt32Digital-&gt;getInterrupt and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-even"><td><p>writeOnce,…,getInterruptOnce</p></td>
<td><p>Does a connect, (write,…,getInterrupt), and disconnect.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynfloat64">
<h3><a class="toc-backref" href="#id116" role="doc-backlink">asynFloat64</a><a class="headerlink" href="#asynfloat64" title="Link to this heading"></a></h3>
<p>asynFloat64 describes the methods for communicating via IEEE double precision float
values.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">interruptCallbackFloat64</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
            <span class="n">epicsFloat64</span> <span class="n">data</span><span class="p">);</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynFloat64Interrupt</span> <span class="p">{</span>
    <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">addr</span><span class="p">;</span>
    <span class="n">interruptCallbackFloat64</span> <span class="n">callback</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">;</span>
<span class="p">}</span> <span class="n">asynFloat64Interrupt</span><span class="p">;</span>
<span class="c1">#define asynFloat64Type &quot;asynFloat64&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynFloat64</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">epicsFloat64</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">epicsFloat64</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">registerInterruptUser</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
        <span class="n">interruptCallbackFloat64</span> <span class="n">callback</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span><span class="n">void</span> <span class="o">**</span><span class="n">registrarPvt</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">cancelInterruptUser</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                    <span class="n">void</span> <span class="o">*</span><span class="n">registrarPvt</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynFloat64</span><span class="p">;</span>

<span class="o">/*</span> <span class="n">asynFloat64Base</span> <span class="n">does</span> <span class="n">the</span> <span class="n">following</span><span class="p">:</span>
   <span class="n">calls</span>  <span class="n">registerInterface</span> <span class="k">for</span> <span class="n">asynFloat64</span><span class="o">.</span>
   <span class="n">Implements</span> <span class="n">registerInterruptUser</span> <span class="ow">and</span> <span class="n">cancelInterruptUser</span>
   <span class="n">Provides</span> <span class="n">default</span> <span class="n">implementations</span> <span class="n">of</span> <span class="nb">all</span> <span class="n">methods</span><span class="o">.</span>
   <span class="n">registerInterruptUser</span> <span class="ow">and</span> <span class="n">cancelInterruptUser</span> <span class="n">can</span> <span class="n">be</span> <span class="n">called</span>
   <span class="n">directly</span> <span class="n">rather</span> <span class="n">than</span> <span class="n">via</span> <span class="n">queueRequest</span><span class="o">.</span>
<span class="o">*/</span>

<span class="c1">#define asynFloat64BaseType &quot;asynFloat64Base&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynFloat64Base</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">initialize</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span>
                            <span class="n">asynInterface</span> <span class="o">*</span><span class="n">pasynFloat64Interface</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynFloat64Base</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynFloat64Base</span> <span class="o">*</span><span class="n">pasynFloat64Base</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id28">
<caption><span class="caption-text">asynFloat64</span><a class="headerlink" href="#id28" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Write a value.</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Read a value.</p></td>
</tr>
<tr class="row-odd"><td><p>registerInterruptUser</p></td>
<td><p>Register a callback that is called whenever new data is available. Since it can
be called directly rather than via a queueRequest this method must not block.</p></td>
</tr>
<tr class="row-even"><td><p>cancelInterruptUser</p></td>
<td><p>Cancel the callback. Since it can be called directly rather than via a queueRequest
this method must not block.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id29">
<caption><span class="caption-text">asynFloat64Base</span><a class="headerlink" href="#id29" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>initialize</p></td>
<td><p>After a driver calls registerPort it can call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pasynFloat64Base</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">(</span><span class="o">...</span>
</pre></div>
</div>
<p>Any null methods in the asynInterface are replaced by default implementations.</p>
</td>
</tr>
</tbody>
</table>
<p>The default implementation of each method does the following:</p>
<table class="docutils align-default" id="id30">
<caption><span class="caption-text">asynFloat64Base</span><a class="headerlink" href="#id30" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Reports an error “write is not supported” and returns asynError</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Reports an error “read is not supported” and returns asynError</p></td>
</tr>
<tr class="row-odd"><td><p>registerInterruptUser</p></td>
<td><p>registers the interrupt user. The low level driver must call the registered callbacks
via calls to asynManager:interruptStart and asynManager:interruptEnd.</p></td>
</tr>
<tr class="row-even"><td><p>cancelInterruptUser</p></td>
<td><p>Cancels the callback</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynfloat64syncio">
<h3><a class="toc-backref" href="#id117" role="doc-backlink">asynFloat64SyncIO</a><a class="headerlink" href="#asynfloat64syncio" title="Link to this heading"></a></h3>
<p>asynFloat64SyncIO describes a synchronous interrace to asynFloat64. The code that
calls it must be willing to block.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define asynFloat64SyncIOType &quot;asynFloat64SyncIO&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynFloat64SyncIO</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                       <span class="n">asynUser</span> <span class="o">**</span><span class="n">ppasynUser</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="n">epicsFloat64</span> <span class="n">value</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="n">epicsFloat64</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">writeOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                       <span class="n">epicsFloat64</span> <span class="n">value</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">readOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                       <span class="n">epicsFloat64</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynFloat64SyncIO</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynFloat64SyncIO</span> <span class="o">*</span><span class="n">pasynFloat64SyncIO</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id31">
<caption><span class="caption-text">asynFloat64SyncIO</span><a class="headerlink" href="#id31" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>connect</p></td>
<td><p>Connects to a port and address, returns a pointer to an asynUser structure.</p></td>
</tr>
<tr class="row-even"><td><p>disconnect</p></td>
<td><p>Disconnect. This frees all resources allocated by connect.</p></td>
</tr>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Calls pasynFloat64-&gt;write and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Calls pasynFloat64-&gt;read and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-odd"><td><p>writeOnce</p></td>
<td><p>This does a connect, write, and disconnect.</p></td>
</tr>
<tr class="row-even"><td><p>readOnce</p></td>
<td><p>This does a connect, read, and disconnect.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynxxxarray-xxx-int8-int16-int32-int64-float32-or-float64">
<h3><a class="toc-backref" href="#id118" role="doc-backlink">asynXXXArray (XXX=Int8, Int16, Int32, Int64, Float32 or Float64)</a><a class="headerlink" href="#asynxxxarray-xxx-int8-int16-int32-int64-float32-or-float64" title="Link to this heading"></a></h3>
<p>asynXXXArray describes the methods for communicating via 8, 16, 32, or 64-bit integers,
or 32 or 64-bit IEEE float values.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">interruptCallbackXXXArray</span><span class="p">)(</span>
              <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
              <span class="n">epicsXXX</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">nelements</span><span class="p">);</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynXXXArrayInterrupt</span> <span class="p">{</span>
    <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">addr</span><span class="p">;</span>
    <span class="n">interruptCallbackXXXArray</span> <span class="n">callback</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">;</span>
<span class="p">}</span> <span class="n">asynXXXArrayInterrupt</span><span class="p">;</span>
<span class="c1">#define asynXXXArrayType &quot;asynXXXArray&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynXXXArray</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                       <span class="n">epicsXXX</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">nelements</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                       <span class="n">epicsXXX</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">nelements</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">nIn</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">registerInterruptUser</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
         <span class="n">interruptCallbackXXXArray</span> <span class="n">callback</span><span class="p">,</span>
         <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span><span class="n">void</span> <span class="o">**</span><span class="n">registrarPvt</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">cancelInterruptUser</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                    <span class="n">void</span> <span class="o">*</span><span class="n">registrarPvt</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynXXXArray</span><span class="p">;</span>

<span class="o">/*</span> <span class="n">asynXXXArrayBase</span> <span class="n">does</span> <span class="n">the</span> <span class="n">following</span><span class="p">:</span>
   <span class="n">calls</span>  <span class="n">registerInterface</span> <span class="k">for</span> <span class="n">asynXXXArray</span><span class="o">.</span>
   <span class="n">Implements</span> <span class="n">registerInterruptUser</span> <span class="ow">and</span> <span class="n">cancelInterruptUser</span>
   <span class="n">Provides</span> <span class="n">default</span> <span class="n">implementations</span> <span class="n">of</span> <span class="nb">all</span> <span class="n">methods</span><span class="o">.</span>
   <span class="n">registerInterruptUser</span> <span class="ow">and</span> <span class="n">cancelInterruptUser</span> <span class="n">can</span> <span class="n">be</span> <span class="n">called</span>
   <span class="n">directly</span> <span class="n">rather</span> <span class="n">than</span> <span class="n">via</span> <span class="n">queueRequest</span><span class="o">.</span>
<span class="o">*/</span>

<span class="c1">#define asynXXXArrayBaseType &quot;asynXXXArrayBase&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynXXXArrayBase</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">initialize</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span>
                            <span class="n">asynInterface</span> <span class="o">*</span><span class="n">pXXXArrayInterface</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynXXXArrayBase</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynXXXArrayBase</span> <span class="o">*</span><span class="n">pasynXXXArrayBase</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id32">
<caption><span class="caption-text">asynXXXArray</span><a class="headerlink" href="#id32" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Write an array of values.</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Read an array of values.</p></td>
</tr>
<tr class="row-odd"><td><p>registerInterruptUser</p></td>
<td><p>Register a callback that is called whenever new data is available.</p></td>
</tr>
<tr class="row-even"><td><p>cancelInterruptUser</p></td>
<td><p>Cancel the callback</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id33">
<caption><span class="caption-text">asynXXXArrayBase</span><a class="headerlink" href="#id33" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>initialize</p></td>
<td><p>After a driver calls registerPort it can call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pasynXXXArrayBase</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">(</span><span class="o">...</span>
</pre></div>
</div>
<p>Any null methods in the asynInterface are replaced by default implementations.</p>
</td>
</tr>
</tbody>
</table>
<p>The default implementation of each method does the following:</p>
<table class="docutils align-default" id="id34">
<caption><span class="caption-text">asynXXXArrayBase</span><a class="headerlink" href="#id34" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Reports an error “write is not supported” and returns asynError</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Reports an error “read is not supported” and returns asynError</p></td>
</tr>
<tr class="row-odd"><td><p>registerInterruptUser</p></td>
<td><p>Registers an interrupt callback.</p></td>
</tr>
<tr class="row-even"><td><p>cancelInterruptUser</p></td>
<td><p>Cancels the callback</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynxxxarraysyncio">
<h3><a class="toc-backref" href="#id119" role="doc-backlink">asynXXXArraySyncIO</a><a class="headerlink" href="#asynxxxarraysyncio" title="Link to this heading"></a></h3>
<p>asynXXXArraySyncIO describes a synchronous interface to asynXXXArray. The code that
calls it must be willing to block.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define asynXXXArraySyncIOType &quot;asynXXXArraySyncIO&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynXXXArraySyncIO</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                          <span class="n">asynUser</span> <span class="o">**</span><span class="n">ppasynUser</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">epicsXXX</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">,</span><span class="n">size_t</span> <span class="n">nelem</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">epicsXXX</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">,</span><span class="n">size_t</span> <span class="n">nelem</span><span class="p">,</span><span class="n">size_t</span> <span class="o">*</span><span class="n">nIn</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">writeOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                    <span class="n">epicsXXX</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">,</span><span class="n">size_t</span> <span class="n">nelem</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">readOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                    <span class="n">epicsXXX</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">,</span><span class="n">size_t</span> <span class="n">nelem</span><span class="p">,</span><span class="n">size_t</span> <span class="o">*</span><span class="n">nIn</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynXXXArraySyncIO</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynXXXArraySyncIO</span> <span class="o">*</span><span class="n">pasynXXXArraySyncIO</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id35">
<caption><span class="caption-text">asynXXXArraySyncIO</span><a class="headerlink" href="#id35" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>connect</p></td>
<td><p>Connects to a port and address, returns a pointer to an asynUser.</p></td>
</tr>
<tr class="row-even"><td><p>disconnect</p></td>
<td><p>Disconnect. This frees all resources allocated by connect.</p></td>
</tr>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Calls pasynXXXArray-&gt;write and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Calls pasynXXXArray-&gt;read and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-odd"><td><p>writeOnce</p></td>
<td><p>This does a connect, write, and disconnect.</p></td>
</tr>
<tr class="row-even"><td><p>readOnce</p></td>
<td><p>This does a connect, read, and disconnect.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynenum">
<h3><a class="toc-backref" href="#id120" role="doc-backlink">asynEnum</a><a class="headerlink" href="#asynenum" title="Link to this heading"></a></h3>
<p>asynEnum describes the methods implemented by drivers to define the enum strings,
values, and severities for a device.</p>
<p>This interface is typically used by drivers to set the enum strings and values for
EPICS bi, bo, mbbi, and mbbo records. The strings[] are used to define the ZNAM
and ONAM fields in bi and bo records, and the ZRST, ONST, …FFST fields in mbbi
and mbbo records. The integer values[] are ignored for bi and bo records, since
these always have the values of 0 and 1 corresponding to the ZNAM and ONAM states.
The integer values[] are used to assign the ZRVL, ONVL, … FFVL fields for mbbi
and mbbo records. The integer severities[] are used to set the ZSV and OSV fields
of bi and bo records, and the ZRSV, ONSV, … FFSV fields of mbbi and mbbo records.
The nelements parameter in the write() and read() functions is used by the client
to specify the dimensions of the strings[], values[], and severities[] arrays. The
driver must not access these arrays beyond element nElements-1. The nIn parameter
in the read() is used by the driver to set the actual number of value enum strings,
values, and severities. There is no size limitation on nElements imposed by the
asynEnum interface. However, the bi and bo records limit nElements to 2, and mbbi
and mbbo records limit nElements to 16. There is no size limitation on the strings
imposed by the asynEnum interface. However, the string fields in the bi, bo, mbbo,
and mbbi records are currently limited to 26 characters.</p>
<p>Clients must ensure that the char* pointers passed in strings[] in the read() function
are either set to NULL or have been allocated by malloc(). The driver read() function
must first call free() if a string pointer contains a non-NULL value. The driver
must then allocate the strings using malloc() before copying the current enum string
values to them.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">interruptCallbackEnum</span><span class="p">)</span>
              <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
              <span class="n">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[],</span> <span class="nb">int</span> <span class="n">values</span><span class="p">[],</span> <span class="nb">int</span> <span class="n">severities</span><span class="p">[],</span> <span class="n">size_t</span> <span class="n">nelements</span><span class="p">);</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynEnumInterrupt</span> <span class="p">{</span>
    <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">addr</span><span class="p">;</span>
    <span class="n">interruptCallbackEnum</span> <span class="n">callback</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">;</span>
<span class="p">}</span> <span class="n">asynEnumInterrupt</span><span class="p">;</span>
<span class="c1">#define asynEnumType &quot;asynEnum&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynEnum</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                       <span class="n">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[],</span> <span class="nb">int</span> <span class="n">values</span><span class="p">[],</span> <span class="nb">int</span> <span class="n">severities</span><span class="p">[],</span> <span class="n">size_t</span> <span class="n">nelements</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                       <span class="n">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[],</span> <span class="nb">int</span> <span class="n">values</span><span class="p">[],</span> <span class="nb">int</span> <span class="n">severities</span><span class="p">[],</span> <span class="n">size_t</span> <span class="n">nelements</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">nIn</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">registerInterruptUser</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
             <span class="n">interruptCallbackEnum</span> <span class="n">callback</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span>
             <span class="n">void</span> <span class="o">**</span><span class="n">registrarPvt</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">cancelInterruptUser</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
             <span class="n">void</span> <span class="o">*</span><span class="n">registrarPvt</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynEnum</span><span class="p">;</span>

<span class="o">/*</span> <span class="n">asynEnumBase</span> <span class="n">does</span> <span class="n">the</span> <span class="n">following</span><span class="p">:</span>
   <span class="n">calls</span> <span class="n">registerInterface</span> <span class="k">for</span> <span class="n">asynEnum</span><span class="o">.</span>
   <span class="n">Implements</span> <span class="n">registerInterruptUser</span> <span class="ow">and</span> <span class="n">cancelInterruptUser</span>
   <span class="n">Provides</span> <span class="n">default</span> <span class="n">implementations</span> <span class="n">of</span> <span class="nb">all</span> <span class="n">methods</span><span class="o">.</span>
   <span class="n">registerInterruptUser</span> <span class="ow">and</span> <span class="n">cancelInterruptUser</span> <span class="n">can</span> <span class="n">be</span> <span class="n">called</span>
   <span class="n">directly</span> <span class="n">rather</span> <span class="n">than</span> <span class="n">via</span> <span class="n">queueRequest</span><span class="o">.</span>
<span class="o">*/</span>

<span class="c1">#define asynEnumBaseType &quot;asynEnumBase&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynEnumBase</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">initialize</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span>
                            <span class="n">asynInterface</span> <span class="o">*</span><span class="n">pEnumInterface</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynEnumBase</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynEnumBase</span> <span class="o">*</span><span class="n">pasynEnumBase</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id36">
<caption><span class="caption-text">asynEnum</span><a class="headerlink" href="#id36" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Writes the enum strings, enum values and enum severities to the driver.</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Reads the enum strings, enum values and enum severities to the driver.</p></td>
</tr>
<tr class="row-odd"><td><p>registerInterruptUser</p></td>
<td><p>Registers a callback that will be called whenever there are new enum strings, values
and severities. Since it can be called directly rather than via a queueRequest this
method must not block.</p></td>
</tr>
<tr class="row-even"><td><p>cancelInterruptUser</p></td>
<td><p>Cancels the callback. Since it can be called directly rather than via a queueRequest
this method must not block.</p></td>
</tr>
</tbody>
</table>
<p>asynEnumBase is an interface and associated code that is used by drivers that implement
interface asynEnum. asynEnumBase provides code to handle registerInterruptUser/cancelInterruptUser.
The driver must itself call the callbacks via calls to asynManager:interruptStart
and asynManager:interruptEnd.</p>
<table class="docutils align-default" id="id37">
<caption><span class="caption-text">asynEnumBase</span><a class="headerlink" href="#id37" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>initialize</p></td>
<td><p>After a driver calls registerPort it can call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pasynEnumBase</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">(</span><span class="o">...</span>
</pre></div>
</div>
<p>Any null methods in the asynInterface are replaced by default implementations.</p>
</td>
</tr>
</tbody>
</table>
<p>The default implementation of each method does the following:</p>
<table class="docutils align-default" id="id38">
<caption><span class="caption-text">asynEnumBase</span><a class="headerlink" href="#id38" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Reports an error “write is not supported” and returns asynError</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Reports an error “read is not supported” and returns asynError</p></td>
</tr>
<tr class="row-odd"><td><p>registerInterruptUser</p></td>
<td><p>registers an interrupt callback.</p></td>
</tr>
<tr class="row-even"><td><p>cancelInterruptUser</p></td>
<td><p>Cancels the callback</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynenumsyncio">
<h3><a class="toc-backref" href="#id121" role="doc-backlink">asynEnumSyncIO</a><a class="headerlink" href="#asynenumsyncio" title="Link to this heading"></a></h3>
<p>asynEnumSyncIO describes a synchronous interface to asynEnum. The code that calls
it must be willing to block.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define asynEnumSyncIOType &quot;asynEnumSyncIO&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynEnumSyncIO</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                          <span class="n">asynUser</span> <span class="o">**</span><span class="n">ppasynUser</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[],</span> <span class="nb">int</span> <span class="n">values</span><span class="p">[],</span> <span class="nb">int</span> <span class="n">severities</span><span class="p">[],</span>
                       <span class="n">size_t</span> <span class="n">nElements</span><span class="p">,</span> <span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">string</span><span class="p">[],</span> <span class="nb">int</span> <span class="n">values</span><span class="p">[],</span>  <span class="nb">int</span> <span class="n">severities</span><span class="p">[],</span>
                       <span class="n">size_t</span> <span class="n">nElements</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">nIn</span><span class="p">,</span> <span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">writeOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[],</span> <span class="nb">int</span> <span class="n">values</span><span class="p">[],</span>  <span class="nb">int</span> <span class="n">severities</span><span class="p">[],</span>
                           <span class="n">size_t</span> <span class="n">nElements</span><span class="p">,</span> <span class="n">double</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">readOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[],</span> <span class="nb">int</span> <span class="n">values</span><span class="p">[],</span>  <span class="nb">int</span> <span class="n">severities</span><span class="p">[],</span>
                           <span class="n">size_t</span> <span class="n">nElements</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">nIn</span><span class="p">,</span> <span class="n">double</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynEnumSyncIO</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynEnumSyncIO</span> <span class="o">*</span><span class="n">pasynEnumSyncIO</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id39">
<caption><span class="caption-text">asynEnumSyncIO</span><a class="headerlink" href="#id39" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>connect</p></td>
<td><p>Connects to a port and address, returns a pointer to an asynUser.</p></td>
</tr>
<tr class="row-even"><td><p>disconnect</p></td>
<td><p>Disconnect. This frees all resources allocated by connect.</p></td>
</tr>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Calls pasynEnum-&gt;write and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Calls pasynEnum-&gt;read and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-odd"><td><p>writeOnce</p></td>
<td><p>This does a connect, write, and disconnect.</p></td>
</tr>
<tr class="row-even"><td><p>readOnce</p></td>
<td><p>This does a connect, read, and disconnect.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asyngenericpointer">
<h3><a class="toc-backref" href="#id122" role="doc-backlink">asynGenericPointer</a><a class="headerlink" href="#asyngenericpointer" title="Link to this heading"></a></h3>
<p>asynGenericPointer describes the methods for communicating via void* pointers. asyn
clients and port drivers must agree on the type of object that is being pointed to!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">interruptCallbackGenericPointer</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
            <span class="n">void</span> <span class="o">*</span><span class="n">pdata</span><span class="p">);</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynGenericPointerInterrupt</span> <span class="p">{</span>
    <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">addr</span><span class="p">;</span>
    <span class="n">interruptCallbackGenericPointer</span> <span class="n">callback</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">;</span>
<span class="p">}</span> <span class="n">asynGenericPointerInterrupt</span><span class="p">;</span>
<span class="c1">#define asynGenericPointerType &quot;asynGenericPointer&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynGenericPointer</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">registerInterruptUser</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
        <span class="n">interruptCallbackGenericPointer</span> <span class="n">callback</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">userPvt</span><span class="p">,</span><span class="n">void</span> <span class="o">**</span><span class="n">registrarPvt</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">cancelInterruptUser</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                    <span class="n">void</span> <span class="o">*</span><span class="n">registrarPvt</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynGenericPointer</span><span class="p">;</span>

<span class="o">/*</span> <span class="n">asynGenericPointerBase</span> <span class="n">does</span> <span class="n">the</span> <span class="n">following</span><span class="p">:</span>
   <span class="n">calls</span>  <span class="n">registerInterface</span> <span class="k">for</span> <span class="n">asynGenericPointer</span><span class="o">.</span>
   <span class="n">Implements</span> <span class="n">registerInterruptUser</span> <span class="ow">and</span> <span class="n">cancelInterruptUser</span>
   <span class="n">Provides</span> <span class="n">default</span> <span class="n">implementations</span> <span class="n">of</span> <span class="nb">all</span> <span class="n">methods</span><span class="o">.</span>
   <span class="n">registerInterruptUser</span> <span class="ow">and</span> <span class="n">cancelInterruptUser</span> <span class="n">can</span> <span class="n">be</span> <span class="n">called</span>
   <span class="n">directly</span> <span class="n">rather</span> <span class="n">than</span> <span class="n">via</span> <span class="n">queueRequest</span><span class="o">.</span>
<span class="o">*/</span>

<span class="c1">#define asynGenericPointerBaseType &quot;asynGenericPointerBase&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynGenericPointerBase</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">initialize</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span>
                            <span class="n">asynInterface</span> <span class="o">*</span><span class="n">pasynGenericPointerInterface</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynGenericPointerBase</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynGenericPointerBase</span> <span class="o">*</span><span class="n">pasynGenericPointerBase</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id40">
<caption><span class="caption-text">asynGenericPointer</span><a class="headerlink" href="#id40" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Write a value.</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Read a value.</p></td>
</tr>
<tr class="row-odd"><td><p>registerInterruptUser</p></td>
<td><p>Register a callback that is called whenever new data is available. Since it can
be called directly rather than via a queueRequest this method must not block.</p></td>
</tr>
<tr class="row-even"><td><p>cancelInterruptUser</p></td>
<td><p>Cancel the callback. Since it can be called directly rather than via a queueRequest
this method must not block.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id41">
<caption><span class="caption-text">asynGenericPointerBase</span><a class="headerlink" href="#id41" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>initialize</p></td>
<td><p>After a driver calls registerPort it can call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pasynGenericPointerBase</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">(</span><span class="o">...</span>
</pre></div>
</div>
<p>Any null methods in the asynInterface are replaced by default implementations.</p>
</td>
</tr>
</tbody>
</table>
<p>The default implementation of each method does the following:</p>
<table class="docutils align-default" id="id42">
<caption><span class="caption-text">asynGenericPointerBase</span><a class="headerlink" href="#id42" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Reports an error “write is not supported” and returns asynError</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Reports an error “read is not supported” and returns asynError</p></td>
</tr>
<tr class="row-odd"><td><p>registerInterruptUser</p></td>
<td><p>registers the interrupt user. The low level driver must call the registered callbacks
via calls to asynManager:interruptStart and asynManager:interruptEnd.</p></td>
</tr>
<tr class="row-even"><td><p>cancelInterruptUser</p></td>
<td><p>Cancels the callback</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asyngenericpointersyncio">
<h3><a class="toc-backref" href="#id123" role="doc-backlink">asynGenericPointerSyncIO</a><a class="headerlink" href="#asyngenericpointersyncio" title="Link to this heading"></a></h3>
<p>asynGenericPointerSyncIO describes a synchronous interrace to asynGenericPointer.
The code that calls it must be willing to block.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define asynGenericPointerSyncIOType &quot;asynGenericPointerSyncIO&quot;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynGenericPointerSyncIO</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                       <span class="n">asynUser</span> <span class="o">**</span><span class="n">ppasynUser</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="n">void</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="n">void</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">writeRead</span><span class="p">)(</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="n">void</span> <span class="o">*</span><span class="n">pwrite_buffer</span><span class="p">,</span><span class="n">void</span> <span class="o">*</span><span class="n">pread_buffer</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">writeOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                       <span class="n">void</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">readOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                       <span class="n">void</span> <span class="o">*</span><span class="n">pvalue</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">writeReadOnce</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span>
                       <span class="n">void</span> <span class="o">*</span><span class="n">pwrite_buffer</span><span class="p">,</span><span class="n">void</span> <span class="o">*</span><span class="n">pread_buffer</span><span class="p">,</span><span class="n">double</span> <span class="n">timeout</span><span class="p">,</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">drvInfo</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynGenericPointerSyncIO</span><span class="p">;</span>
<span class="n">epicsShareExtern</span> <span class="n">asynGenericPointerSyncIO</span> <span class="o">*</span><span class="n">pasynGenericPointerSyncIO</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils align-default" id="id43">
<caption><span class="caption-text">asynGenericPointerSyncIO</span><a class="headerlink" href="#id43" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>connect</p></td>
<td><p>Connects to a port and address, returns a pointer to an asynUser structure.</p></td>
</tr>
<tr class="row-even"><td><p>disconnect</p></td>
<td><p>Disconnect. This frees all resources allocated by connect.</p></td>
</tr>
<tr class="row-odd"><td><p>write</p></td>
<td><p>Calls pasynGenericPointer-&gt;write and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-even"><td><p>read</p></td>
<td><p>Calls pasynGenericPointer-&gt;read and waits for the operation to complete or time out.</p></td>
</tr>
<tr class="row-odd"><td><p>writeRead</p></td>
<td><p>Calls pasynGenericPointer-&gt;write, then pasynGenericPointer-&gt;read. Waits for
the operations to complete or time out.</p></td>
</tr>
<tr class="row-even"><td><p>writeOnce</p></td>
<td><p>This does a connect, write, and disconnect.</p></td>
</tr>
<tr class="row-odd"><td><p>readOnce</p></td>
<td><p>This does a connect, read, and disconnect.</p></td>
</tr>
<tr class="row-even"><td><p>writeReadOnce</p></td>
<td><p>This does a connect, writeRead, and disconnect.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="asynstandardinterfacesbase">
<h2><a class="toc-backref" href="#id124" role="doc-backlink">asynStandardInterfacesBase</a><a class="headerlink" href="#asynstandardinterfacesbase" title="Link to this heading"></a></h2>
<p>asynStandardInterfacesBase is an interface designed as a convenience to minimize
the amount of code that must be written in the initialization routine of a port
driver that uses the standard asyn message-based or register-based interfaces that
are described above. Without asynStandardInterfacesBase a port driver needs to call
asynRegisterInterface(), and possibly asynRegisterInterruptSource() for each interface
that it supports, and handle any errors that may occur in these calls. It also needs
to explicitly include several fields in its drvPvt structure for each interface.
asynStandardInterfacesBase provides an interface that allows port drivers to include
a single structure in its drvPvt structure, and define values in this structure.
It then calls a single function to register all interfaces that it supports, and
to register itself as an interrupt source on one or more of those interfaces. This
can reduce the number of lines of code in the driver initialization routine by a
factor of four or more.</p>
<section id="asynstandardinterfaces-structure">
<h3><a class="toc-backref" href="#id125" role="doc-backlink">asynStandardInterfaces structure</a><a class="headerlink" href="#asynstandardinterfaces-structure" title="Link to this heading"></a></h3>
<p>The following is the definition of the asynStandardInterfaces structure. Drivers
will normally have a structure of this type contained in their drvPvt structure.
If this structure is initialized to all zeros when drvPvt is created, then all that
is necessary is to fill in the addresses of each of each of the supported interfaces
(in that interface’s .pinterface field), and to set the CanInterrupt flag to 1 for
those interfaces that are interrupt sources.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynStandardInterfaces</span> <span class="p">{</span>
    <span class="n">asynInterface</span> <span class="n">common</span><span class="p">;</span>

    <span class="n">asynInterface</span> <span class="n">drvUser</span><span class="p">;</span>

    <span class="n">asynInterface</span> <span class="n">option</span><span class="p">;</span>

    <span class="n">asynInterface</span> <span class="n">octet</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">octetProcessEosIn</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">octetProcessEosOut</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">octetInterruptProcess</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">octetCanInterrupt</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">octetInterruptPvt</span><span class="p">;</span>

    <span class="n">asynInterface</span> <span class="n">uInt32Digital</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">uInt32DigitalCanInterrupt</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">uInt32DigitalInterruptPvt</span><span class="p">;</span>

    <span class="n">asynInterface</span> <span class="n">int32</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">int32CanInterrupt</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">int32InterruptPvt</span><span class="p">;</span>

    <span class="n">asynInterface</span> <span class="n">int64</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">int64CanInterrupt</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">int64InterruptPvt</span><span class="p">;</span>

    <span class="n">asynInterface</span> <span class="n">float64</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">float64CanInterrupt</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">float64InterruptPvt</span><span class="p">;</span>

    <span class="n">asynInterface</span> <span class="n">int8Array</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">int8ArrayCanInterrupt</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">int8ArrayInterruptPvt</span><span class="p">;</span>

    <span class="n">asynInterface</span> <span class="n">int16Array</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">int16ArrayCanInterrupt</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">int16ArrayInterruptPvt</span><span class="p">;</span>

    <span class="n">asynInterface</span> <span class="n">int32Array</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">int32ArrayCanInterrupt</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">int32ArrayInterruptPvt</span><span class="p">;</span>

    <span class="n">asynInterface</span> <span class="n">int64Array</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">int64ArrayCanInterrupt</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">int64ArrayInterruptPvt</span><span class="p">;</span>

    <span class="n">asynInterface</span> <span class="n">float32Array</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">float32ArrayCanInterrupt</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">float32ArrayInterruptPvt</span><span class="p">;</span>

    <span class="n">asynInterface</span> <span class="n">float64Array</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">float64ArrayCanInterrupt</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">float64ArrayInterruptPvt</span><span class="p">;</span>

    <span class="n">asynInterface</span> <span class="n">genericPointer</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">genericPointerCanInterrupt</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">genericPointerInterruptPvt</span><span class="p">;</span>

    <span class="n">asynInterface</span> <span class="n">Enum</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">enumCanInterrupt</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">enumInterruptPvt</span><span class="p">;</span>

<span class="p">}</span> <span class="n">asynStandardInterfaces</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="asynstandardinterfacesbase-interface">
<h3><a class="toc-backref" href="#id126" role="doc-backlink">asynStandardInterfacesBase interface</a><a class="headerlink" href="#asynstandardinterfacesbase-interface" title="Link to this heading"></a></h3>
<p>The following is the definition of the asynStandardInterfacesBase interface.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynStandardInterfacesBase</span> <span class="p">{</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">initialize</span><span class="p">)(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span> <span class="n">asynStandardInterfaces</span> <span class="o">*</span><span class="n">pInterfaces</span><span class="p">,</span>
                             <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">pPvt</span><span class="p">);</span>
<span class="p">}</span> <span class="n">asynStandardInterfacesBase</span><span class="p">;</span>

<span class="n">epicsShareExtern</span> <span class="n">asynStandardInterfacesBase</span> <span class="o">*</span><span class="n">pasynStandardInterfacesBase</span><span class="p">;</span>
</pre></div>
</div>
<p>asynStandardInterfacesBase has a single method, initialize(), which calls registerInterface
or Base-&gt;initialize for each interface which has a non-NULL value in its .pinterface
field. It also calls registerInterruptSource for interfaces that are defined and
that have the CanInterrupt flag set to 1. The pasynUser argument to the initialize()
method is used only to provide a place for the method to return an error message
(in pasynUser-&gt;errorMessage) so the invoking routine may reuse or free the asynUser
structure when the method has returned.</p>
<p>The following is an example of the code required in a port driver that uses the
asynStandardInterfacesBase interface.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;asynStandardInterfaces.h&gt;</span>
<span class="o">...</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">drvADPvt</span> <span class="p">{</span>
<span class="o">...</span>
    <span class="o">/*</span> <span class="n">The</span> <span class="n">asyn</span> <span class="n">interfaces</span> <span class="n">this</span> <span class="n">driver</span> <span class="n">implements</span> <span class="o">*/</span>
    <span class="n">asynStandardInterfaces</span> <span class="n">asynStdInterfaces</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">asynUser</span> <span class="n">connected</span> <span class="n">to</span> <span class="n">ourselves</span> <span class="k">for</span> <span class="n">asynTrace</span> <span class="o">*/</span>
    <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">;</span>
<span class="o">...</span>
<span class="p">}</span> <span class="n">drvADPvt</span><span class="p">;</span>
<span class="o">...</span>
<span class="o">/*</span> <span class="n">Structures</span> <span class="k">with</span> <span class="n">function</span> <span class="n">pointers</span> <span class="k">for</span> <span class="n">each</span> <span class="n">of</span> <span class="n">the</span> <span class="n">asyn</span> <span class="n">interfaces</span> <span class="o">*/</span>
<span class="n">static</span> <span class="n">asynCommon</span> <span class="n">ifaceCommon</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">report</span><span class="p">,</span>
    <span class="n">connect</span><span class="p">,</span>
    <span class="n">disconnect</span>
<span class="p">};</span>

<span class="n">static</span> <span class="n">asynInt32</span> <span class="n">ifaceInt32</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">writeInt32</span><span class="p">,</span>
    <span class="n">readInt32</span><span class="p">,</span>
    <span class="n">getBounds</span>
<span class="p">};</span>

<span class="n">static</span> <span class="n">asynInt64</span> <span class="n">ifaceInt64</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">writeInt64</span><span class="p">,</span>
    <span class="n">readInt64</span><span class="p">,</span>
    <span class="n">getBounds</span>
<span class="p">};</span>

<span class="n">static</span> <span class="n">asynFloat64</span> <span class="n">ifaceFloat64</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">writeFloat64</span><span class="p">,</span>
    <span class="n">readFloat64</span>
<span class="p">};</span>

<span class="n">static</span> <span class="n">asynOctet</span> <span class="n">ifaceOctet</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">writeOctet</span><span class="p">,</span>
    <span class="n">NULL</span><span class="p">,</span>
    <span class="n">readOctet</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">static</span> <span class="n">asynDrvUser</span> <span class="n">ifaceDrvUser</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">drvUserCreate</span><span class="p">,</span>
    <span class="n">drvUserGetType</span><span class="p">,</span>
    <span class="n">drvUserDestroy</span>
<span class="p">};</span>

<span class="n">static</span> <span class="n">asynGenericPointer</span> <span class="n">ifaceGenericPointer</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">writeADImage</span><span class="p">,</span>
    <span class="n">readADImage</span>
<span class="p">};</span>
<span class="o">...</span>

<span class="nb">int</span> <span class="n">simDetectorConfig</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span> <span class="nb">int</span> <span class="n">maxSizeX</span><span class="p">,</span> <span class="nb">int</span> <span class="n">maxSizeY</span><span class="p">,</span> <span class="nb">int</span> <span class="n">dataType</span><span class="p">)</span>

<span class="p">{</span>
    <span class="n">drvADPvt</span> <span class="o">*</span><span class="n">pPvt</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">asynSuccess</span><span class="p">;</span>
    <span class="n">char</span> <span class="o">*</span><span class="n">functionName</span> <span class="o">=</span> <span class="s2">&quot;simDetectorConfig&quot;</span><span class="p">;</span>
    <span class="n">asynStandardInterfaces</span> <span class="o">*</span><span class="n">pInterfaces</span><span class="p">;</span>

    <span class="n">pPvt</span> <span class="o">=</span> <span class="n">callocMustSucceed</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pPvt</span><span class="p">),</span> <span class="n">functionName</span><span class="p">);</span>
    <span class="n">pPvt</span><span class="o">-&gt;</span><span class="n">portName</span> <span class="o">=</span> <span class="n">epicsStrDup</span><span class="p">(</span><span class="n">portName</span><span class="p">);</span>

    <span class="n">status</span> <span class="o">=</span> <span class="n">pasynManager</span><span class="o">-&gt;</span><span class="n">registerPort</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span>
                                        <span class="n">ASYN_MULTIDEVICE</span> <span class="o">|</span> <span class="n">ASYN_CANBLOCK</span><span class="p">,</span>
                                        <span class="mi">1</span><span class="p">,</span>  <span class="o">/*</span>  <span class="n">autoconnect</span> <span class="o">*/</span>
                                        <span class="mi">0</span><span class="p">,</span>  <span class="o">/*</span> <span class="n">medium</span> <span class="n">priority</span> <span class="o">*/</span>
                                        <span class="mi">0</span><span class="p">);</span> <span class="o">/*</span> <span class="n">default</span> <span class="n">stack</span> <span class="n">size</span> <span class="o">*/</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">asynSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> ERROR: Can&#39;t register port</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">functionName</span><span class="p">);</span>
        <span class="k">return</span><span class="p">(</span><span class="n">asynError</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="o">/*</span> <span class="n">Create</span> <span class="n">asynUser</span> <span class="k">for</span> <span class="n">debugging</span> <span class="o">*/</span>
    <span class="n">pPvt</span><span class="o">-&gt;</span><span class="n">pasynUser</span> <span class="o">=</span> <span class="n">pasynManager</span><span class="o">-&gt;</span><span class="n">createAsynUser</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">pInterfaces</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pPvt</span><span class="o">-&gt;</span><span class="n">asynStdInterfaces</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">Initialize</span> <span class="n">interface</span> <span class="n">pointers</span> <span class="o">*/</span>
    <span class="n">pInterfaces</span><span class="o">-&gt;</span><span class="n">common</span><span class="o">.</span><span class="n">pinterface</span>         <span class="o">=</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifaceCommon</span><span class="p">;</span>
    <span class="n">pInterfaces</span><span class="o">-&gt;</span><span class="n">drvUser</span><span class="o">.</span><span class="n">pinterface</span>        <span class="o">=</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifaceDrvUser</span><span class="p">;</span>
    <span class="n">pInterfaces</span><span class="o">-&gt;</span><span class="n">octet</span><span class="o">.</span><span class="n">pinterface</span>          <span class="o">=</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifaceOctet</span><span class="p">;</span>
    <span class="n">pInterfaces</span><span class="o">-&gt;</span><span class="n">int32</span><span class="o">.</span><span class="n">pinterface</span>          <span class="o">=</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifaceInt32</span><span class="p">;</span>
    <span class="n">pInterfaces</span><span class="o">-&gt;</span><span class="n">int64</span><span class="o">.</span><span class="n">pinterface</span>          <span class="o">=</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifaceInt64</span><span class="p">;</span>
    <span class="n">pInterfaces</span><span class="o">-&gt;</span><span class="n">float64</span><span class="o">.</span><span class="n">pinterface</span>        <span class="o">=</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifaceFloat64</span><span class="p">;</span>
    <span class="n">pInterfaces</span><span class="o">-&gt;</span><span class="n">genericPointer</span><span class="o">.</span><span class="n">pinterface</span> <span class="o">=</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifaceGenericPointer</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">Define</span> <span class="n">which</span> <span class="n">interfaces</span> <span class="n">can</span> <span class="n">generate</span> <span class="n">interrupts</span> <span class="o">*/</span>
    <span class="n">pInterfaces</span><span class="o">-&gt;</span><span class="n">octetCanInterrupt</span>          <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">pInterfaces</span><span class="o">-&gt;</span><span class="n">int32CanInterrupt</span>          <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">pInterfaces</span><span class="o">-&gt;</span><span class="n">int64CanInterrupt</span>          <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">pInterfaces</span><span class="o">-&gt;</span><span class="n">float64CanInterrupt</span>        <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">pInterfaces</span><span class="o">-&gt;</span><span class="n">genericPointerCanInterrupt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">status</span> <span class="o">=</span> <span class="n">pasynStandardInterfacesBase</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span> <span class="n">pInterfaces</span><span class="p">,</span>
                                                     <span class="n">pPvt</span><span class="o">-&gt;</span><span class="n">pasynUser</span><span class="p">,</span> <span class="n">pPvt</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">asynSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> ERROR: Can&#39;t register interfaces: </span><span class="si">%s</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
               <span class="n">functionName</span><span class="p">,</span> <span class="n">pPvt</span><span class="o">-&gt;</span><span class="n">pasynUser</span><span class="o">-&gt;</span><span class="n">errorMessage</span><span class="p">);</span>
        <span class="k">return</span><span class="p">(</span><span class="n">asynError</span><span class="p">);</span>
    <span class="p">}</span>
<span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="standard-interpose-interfaces">
<h2><a class="toc-backref" href="#id127" role="doc-backlink">Standard Interpose Interfaces</a><a class="headerlink" href="#standard-interpose-interfaces" title="Link to this heading"></a></h2>
<section id="asyninterposeeos">
<h3><a class="toc-backref" href="#id128" role="doc-backlink">asynInterposeEos</a><a class="headerlink" href="#asyninterposeeos" title="Link to this heading"></a></h3>
<p>This can be used to simulate EOS processing for asynOctet if the port driver doesn’t
provide EOS support. If an EOS is specified it looks for the eos on each read. It
is started by the shell command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asynInterposeEosConfig</span> <span class="n">port</span> <span class="n">addr</span> <span class="n">processEosIn</span> <span class="n">processEosOut</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li><p>port is the name of the port.</p></li>
<li><p>addr is the address</p></li>
<li><p>processEosIn (0,1) means (do not, do) implement eosIn commands.</p></li>
<li><p>processEosOut (0,1) means (do not, do) implement eosOut commands.</p></li>
</ul>
<p>This command should appear immediately after the command that initializes a port.
Some drivers provide configuration options to call this automatically.</p>
</section>
<section id="asyninterposeflush">
<h3><a class="toc-backref" href="#id129" role="doc-backlink">asynInterposeFlush</a><a class="headerlink" href="#asyninterposeflush" title="Link to this heading"></a></h3>
<p>This can be used to simulate flush processing for asynOctet if the port driver doesn’t
provide support for flush. It just reads and discards characters until no more characters
arive before timeout seconds have occured. It is started by the shell command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asynInterposeFlushConfig</span> <span class="n">port</span> <span class="n">addr</span> <span class="n">timeout</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li><p>port is the name of the port.</p></li>
<li><p>addr is the address</p></li>
<li><p>timeout is the time to wait for more characters</p></li>
</ul>
<p>This command should appear immediately after the command that initializes a port.</p>
</section>
<section id="asyninterposecom">
<h3><a class="toc-backref" href="#id130" role="doc-backlink">asynInterposeCom</a><a class="headerlink" href="#asyninterposecom" title="Link to this heading"></a></h3>
<p>This provides the ability to configure serial ports on terminal servers using the
RFC 2117 protocol. It is not configured from the iocsh directly, but is rather configured
automatically by the drvAsynIPPort driver if the COM protocol is specified. It supports
the same options as drvAsynSerialPort, i.e. “baud”, “bits”, “parity”, “stop”, “crtscts”,
“ixon” and “break”.</p>
</section>
<section id="asyninterposedelay">
<h3><a class="toc-backref" href="#id131" role="doc-backlink">asynInterposeDelay</a><a class="headerlink" href="#asyninterposedelay" title="Link to this heading"></a></h3>
<p>This can be used to wait for a specified delay after sending each character before
sending the next. Some poorly designed devices require this. It is started by the
shell command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asynInterposeDelay</span> <span class="n">port</span> <span class="n">addr</span> <span class="n">delay</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li><p>port is the name of the port.</p></li>
<li><p>addr is the address</p></li>
<li><p>delay is the time to wait after sending each character</p></li>
</ul>
<p>This command should appear immediately after the command that initializes a port.
At run-time the delay can be examined or changed using the asyn option interface
with the <cite>delay</cite> option which is added by this interpose layer.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asynShowOption</span> <span class="n">port</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="s2">&quot;delay&quot;</span>
<span class="n">asynSetOption</span> <span class="n">port</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="s2">&quot;delay&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">(</span><span class="n">sec</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="asyninterposeecho">
<h3><a class="toc-backref" href="#id132" role="doc-backlink">asynInterposeEcho</a><a class="headerlink" href="#asyninterposeecho" title="Link to this heading"></a></h3>
<p>This can be used to wait for each character to be echoed by the device before sending
the next character. Some poorly designed devices require this. It is started by
the shell command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asynInterposeEcho</span> <span class="n">port</span> <span class="n">addr</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li><p>port is the name of the port.</p></li>
<li><p>addr is the address</p></li>
</ul>
<p>This command should appear immediately after the command that initializes a port.</p>
</section>
</section>
<section id="generic-device-support-for-epics-records">
<h2><a class="toc-backref" href="#id133" role="doc-backlink">Generic Device Support for EPICS records</a><a class="headerlink" href="#generic-device-support-for-epics-records" title="Link to this heading"></a></h2>
<p>Generic device support is provided for standard EPICS records. This support should
be usable for a large class of low level register based drivers. For complicated
devices other support is required. This release provides the following:</p>
<ul class="simple">
<li><p>devAsynInt32 - support for drivers that implement interface asynInt32</p></li>
<li><p>devAsynInt64 - support for drivers that implement interface asynInt64</p></li>
<li><p>devAsynInt32TimeSeries - waveform record support for drivers that implement callbacks
on interface asynInt32</p></li>
<li><p>devAsynInt64TimeSeries - waveform record support for drivers that implement callbacks
on interface asynInt64</p></li>
<li><p>devAsynInt8Array - support for drivers that implement interface asynInt8Array</p></li>
<li><p>devAsynInt16Array - support for drivers that implement interface asynInt16Array</p></li>
<li><p>devAsynInt32Array - support for drivers that implement interface asynInt32Array</p></li>
<li><p>devAsynInt64Array - support for drivers that implement interface asynInt64Array</p></li>
<li><p>devAsynUInt32Digital - support for drivers that implement interface asynUInt32Digital</p></li>
<li><p>devAsynFloat64 - support for drivers that implement interface asynFloat64</p></li>
<li><p>devAsynFloat64TimeSeries - waveform record support for drivers that implement
callbacks on interface asynFloat64</p></li>
<li><p>devAsynFloat32Array - support for drivers that implement interface asynFloat32Array</p></li>
<li><p>devAsynFloat64Array - support for drivers that implement interface asynFloat64Array</p></li>
<li><p>devAsynOctet - support for drivers that implement interface asynOctet</p></li>
<li><p>devEpics - This is just a single file devEpics.dbd that includes the dbd files
for the above support.</p></li>
<li><p>asynEpicsUtils.c - This provides utility functions. parseLink(), parseLinkMask()
and parseLinkFree() parse record the record INP and OUT links described below. asynStatusToEpicsAlarm()
converts asynStatus enum values to EPICS record STAT and SEVR values setting record
alarms.</p></li>
</ul>
<p>The support uses the following conventions for DTYP and INP. OUT fields are the
same as INP.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynXXX&quot;</span><span class="p">)</span>
<span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asyn(portName,addr,timeout)drvParams&quot;</span><span class="p">)</span>
 <span class="ow">or</span>
<span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asynMask(portName,addr,mask,timeout)drvParams&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li><p>XXX - The name of the type of interface supported.</p></li>
<li><p>portName - The name of the port.</p></li>
<li><p>addr - The address. If addr is not specified the default is 0.</p></li>
<li><p>mask - This is for devAsynUInt32Digital. It is also used by devAsynInt32 to specify
the number of bits of the hardware device for drivers that do not support getBounds().</p></li>
<li><p>timeout - The timeout value for asynUser.timeout. If not specified the default
is 1.0.</p></li>
<li><p>drvParams - This is passed to the low level driver via the asynDrvUser interface.
It is optional.</p></li>
</ul>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
<span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asyn(portA,0,.1)thisIsForDriver&quot;</span><span class="p">)</span>
</pre></div>
</div>
<section id="asynmanager-interrupts-and-epics-device-support">
<h3><a class="toc-backref" href="#id134" role="doc-backlink">asynManager interrupts and EPICS device support</a><a class="headerlink" href="#asynmanager-interrupts-and-epics-device-support" title="Link to this heading"></a></h3>
<p>All of the device support files can call registerInterruptUser for input records.
The callback is used in one of two ways:</p>
<ul>
<li><p>Input Records except Average and TimeSeries</p>
<p>It is used to support SCAN = “I/O Intr”.</p>
</li>
<li><p>Input records that are averaged, i.e. asynInt32Average or asynFloat64Average.</p>
<p>These records can be scanned either periodically or with SCAN=I/O Intr. The registerInterruptUser
callback is used to add the current value to the sum of values between record processing.</p>
<p>If the record is periodically processed, then the average is computed each time
the record processes. If the record is processed before new data have arrived (numAverage==0)
the record is set to UDF/INVALID, UDF is set to TRUE, and the value is left unchanged.</p>
<p>If the record has SCAN=I/O Intr then the average is computed and the record is processed
each time NumAverage callback readings have been received. The SVAL field in the
ai record is used to set NumAverage. This is rather a kluge, but there is not another
good way to communicate this value to the device support, while allowing it to be
changed at run-time. This means that simulation mode cannot be used with asynInt32Average
or asynFloat64Average device support if SCAN=I/O Intr. This is probably not a significant
limitation. Support for SCAN=I/O Intr was added in R4-34.</p>
</li>
<li><p>Input records that are waveform time series, i.e. asynInt32TimeSeries, asynInt64TimeSeries
or asynFloat64TimeSeries.</p>
<p>These records are normally scanned periodically. The registerInterruptUser callback
is used to append values to the time series.</p>
</li>
</ul>
</section>
<section id="initial-values-of-output-records">
<h3><a class="toc-backref" href="#id135" role="doc-backlink">Initial values of output records</a><a class="headerlink" href="#initial-values-of-output-records" title="Link to this heading"></a></h3>
<p>The device support for output records on register based interfaces (bo, mbbo, ao,
longout) does an initial read() of the value from the driver in init_record. If
this read() returns asynSuccess then the record value is set to the value returned
from read(). If read() returns anything other than asynSuccess then the record value
is not modified. This mechanism supports “bumpless reboots” where the initial value
of output records will match the current value of the hardware when the IOC starts.
Drivers should only return asynSuccess from the read() function if the value is
known to be valid. Note that this value read from the device will replace the value
in the database when iocInit begins. However, the value read from the device may
in turn be replaced by any value from save/restore, because the auto restore happens
later in iocInit.</p>
<p>Beginning in R4-30 devAsynOctet was changed to also support the initial readback
for stringout and waveform output records. The initial readback is only done if
the record in the database contains the following line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">(</span><span class="n">asyn</span><span class="p">:</span><span class="n">INITIAL_READBACK</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="enum-values-for-bi-bo-mbbi-and-mbbo-records">
<h3><a class="toc-backref" href="#id136" role="doc-backlink">Enum values for bi, bo, mbbi, and mbbo records</a><a class="headerlink" href="#enum-values-for-bi-bo-mbbi-and-mbbo-records" title="Link to this heading"></a></h3>
<p>Beginning in asyn R4-19 support was added for asyn port drivers to control the values
of the enum strings, enum values and enum severities in bi, bo, mbbi, and mbbo records.
This is implemented in the asynInt32 and asynUInt32Digital device support as follows:</p>
<ul class="simple">
<li><p>In the device support init_record function the device support attempts to find
the asynEnum interface in the driver. If it is found then the driver calls pasynEnumSyncIO-&gt;read()
to read the current values of the enums from the driver. If the read() returns asynSuccess
then the enum fields are set to the values returned by the driver. If the asynEnum
interface is not supported, or if read() returns anything except asynSuccess then
the enum fields are not modified.</p></li>
<li><p>Device support registers for callbacks on the asynEnum interface. Drivers can
make callbacks to dynamically change the values of enums at run-time. For example,
changing the gain of an ADC might change the allowed choices for the speed, etc.
Device support calls db_post_events(pr, &amp;pr-&gt;val, DBE_PROPERTY) when the
enum fields change. This notifies clients that the enum values have changed. Older
clients like medm and edm will not change the enum widgets until the window is closed
and reopened, but newer clients like CSS should dynamically change the enum widgets.</p></li>
</ul>
</section>
<section id="callback-updates-for-output-records">
<h3><a class="toc-backref" href="#id137" role="doc-backlink">Callback updates for output records</a><a class="headerlink" href="#callback-updates-for-output-records" title="Link to this heading"></a></h3>
<p>Beginning in asyn R4-26 support was added for updating output records from driver
interrupt callbacks. This feature allows output records to reflect changes in the
underlying hardware that are caused by manual front-panel operation, changes caused
by another output record, etc.</p>
<p>By default output records do not update when a driver does interrupt callbacks.
However, if the following info tag is added for a record in the database file then
callbacks will be enabled and the output record will be updated whenever the driver
does a callback for that value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">(</span><span class="n">asyn</span><span class="p">:</span><span class="n">READBACK</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If the value of the info tag is 0 or if the info tag is not present then updates
of output records on interrupt callbacks are disabled.</p>
</section>
<section id="buffering-of-driver-callbacks">
<h3><a class="toc-backref" href="#id138" role="doc-backlink">Buffering of driver callbacks</a><a class="headerlink" href="#buffering-of-driver-callbacks" title="Link to this heading"></a></h3>
<p>It is possible for the time between driver callbacks to be less than the time for
record processing. asyn device support provides a ring-buffer (FIFO) mechanism to
buffer values so that the record will process all callback values from a short burst
of callbacks. For all records except devAsynOctet (stringin, stringout, lsi, lso,
printf, sCalcout and waveform) records the default buffer size is 10 values. For
stringin, stringout, and waveform records the default buffer size is 0, i.e. there
is no buffering. For all record types the size of the buffer can be controlled by
the following info tag for a record in the database file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">(</span><span class="n">asyn</span><span class="p">:</span><span class="n">FIFO</span><span class="p">,</span> <span class="s2">&quot;20&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example the buffer size was set to 20. Ring buffer support was added in
asyn R4-10 for all records except stringin, stringout, and waveform. Waveform record
support for numeric arrays was added in asyn R4-25. asynOctet support for stringin,
stringout, and waveform records was added in asyn R4-26. In R4-35 a deadlock issue
with asyn:READBACK was found. To fix this with asynOctet output records a ring buffer
is required. Thus, a minimum ring buffer size of 1 is enforced in the driver for
these records if asyn:REABACK=1 even if asyn:FIFO is not specified. asyn:FIFO can
still be used to select a larger ring buffer size.</p>
</section>
<section id="time-stamps">
<h3><a class="toc-backref" href="#id139" role="doc-backlink">Time stamps</a><a class="headerlink" href="#time-stamps" title="Link to this heading"></a></h3>
<p>Beginning in asyn R4-20 support was added for asyn port drivers to set the TIME
field of input records. This is done by setting the TSE field of the record to “-2”
and setting the desired value into the timestamp field of the pasynUser structure
referred to in the device read method or interrupt callback.</p>
<p>Beginning in asyn R4-22 the timestamp support functions were added to asynManager
to update, get and set the most recent timestamp for the port in asynManager. Support
was also added for user-supplied timestamp source functions. Timestamp support was
also added to asynPortDriver for the base-class read functions and callback functions.</p>
</section>
<section id="asynint32-device-support">
<h3><a class="toc-backref" href="#id140" role="doc-backlink">asynInt32 device support</a><a class="headerlink" href="#asynint32-device-support" title="Link to this heading"></a></h3>
<p>The following support is available:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">device</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynAiInt32</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynAiInt32Average</span><span class="p">,</span><span class="s2">&quot;asynInt32Average&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">ao</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynAoInt32</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynBiInt32</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">bo</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynBoInt32</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">mbbi</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynMbbiInt32</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">mbbo</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynMbboInt32</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">longin</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynLiInt32</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">longout</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynLoInt32</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>devAsynInt32.c provides EPICS device support for drivers that implement interface
asynInt32.</p>
<p>For ai and ao records either of the following specifications for the INP and OUT
fields can be used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asyn(portName,addr,timeout) drvParams&quot;</span><span class="p">)</span>
  <span class="ow">or</span>
<span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asynMask(portName,addr,nbits,timeout) drvParams&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The asynMask format allows device support to work with drivers that cannot return
meaningful values from getBounds() because they do not know the range of the device.
This is true, for example, of Modbus ADCs. The nbits parameter is defined as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nbits</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="n">Device</span> <span class="ow">is</span> <span class="n">unipolar</span> <span class="k">with</span> <span class="n">a</span> <span class="nb">range</span> <span class="kn">from</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">2</span><span class="o">^</span><span class="n">nbits</span><span class="o">-</span><span class="mf">1.</span>  <span class="n">Values</span> <span class="n">will</span> <span class="n">be</span> <span class="n">masked</span> <span class="n">to</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">number</span> <span class="n">of</span> <span class="n">bits</span><span class="o">.</span>

<span class="n">nbits</span> <span class="o">&lt;</span> <span class="mi">0</span>  <span class="n">Device</span> <span class="ow">is</span> <span class="n">bipolar</span> <span class="k">with</span> <span class="n">a</span> <span class="nb">range</span> <span class="kn">from</span> <span class="o">-</span><span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">nbits</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">to</span> <span class="mi">2</span><span class="o">^</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">nbits</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
<p>Values read with the asynInt32 interface will be sign extended
using the sign bit (e.g. bit abs(nbits)-1 starting at bit 0).</p>
<ul>
<li><p>aiRecord</p>
<p>A value is given to rval. Linear conversions are supported if the driver implements
getBounds, or if nbits is specified as explained above.</p>
<ul class="simple">
<li><p>asynInt32</p>
<ul>
<li><p>SCAN “I/O Intr” is supported. If the record is “I/O Intr” scanned
then when the registerInterruptUser callback is called, it saves the value and calls
scanIoRequest. When the record is processed the saved value is put into rval.</p></li>
<li><p>If the record is not “I/O Intr” scanned then each time the record is processed, a new
value is read via a call to pasynInt32-&gt;read.</p></li>
</ul>
</li>
<li><p>asynInt32Average</p>
<ul>
<li><p>The registerInterruptUser callback adds the new value to a
sum and also increments the number of samples.</p></li>
<li><p>When the record is processed the average is computed and the sum and number of samples is set to zero.</p></li>
<li><p>If the record is processed before new data have arrived (numAverage==0) the record is set to UDF/INVALID,
UDF is set to TRUE, and the value is left unchanged.</p></li>
<li><p>The record can be scanned either periodically or with SCAN=I/O Intr.</p></li>
<li><p>If the record has SCAN=I/O Intr then the average is computed and the record is processed each time NumAverage callback readings have
been received.</p></li>
<li><p>The SVAL field in the ai record is used to set NumAverage.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>aoRecord</p>
<p>rval is written. Linear conversions are supported if the driver properly implements
getBounds, or if nbits is specified as explained above.</p>
</li>
<li><p>longinRecord</p>
<p>A value is given to val. Each time the record is processed a new value is read.
SCAN “I/O Intr” is supported similar to aiRecord.</p>
</li>
<li><p>longoutRecord</p>
<p>val is written.</p>
</li>
<li><p>biRecord</p>
<p>A value is given to rval. The mask field in the record is not used. Each time the
record is processed a new value is read. SCAN “I/O Intr” is supported similar to
aiRecord.</p>
</li>
<li><p>boRecord</p>
<p>rval is written. The mask field in the record is not used.</p>
</li>
<li><p>mbbiRecord</p>
<p>A value is given to rval. mask is computed from nobt and shft. Each time the record
is processed a new value is read. SCAN “I/O Intr” is supported similar to aiRecord.</p>
</li>
<li><p>mbboRecord</p>
<p>rval is written. mask is computed from nobt and shft.</p>
</li>
</ul>
<p>Analog Input Example Records</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">record</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span><span class="s2">&quot;aiInt32&quot;</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">field</span><span class="p">(</span><span class="n">SCAN</span><span class="p">,</span><span class="s2">&quot;I/O Intr&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asyn($(port),$(addr))&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">EGUF</span><span class="p">,</span><span class="s2">&quot;10.0&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">EGUL</span><span class="p">,</span><span class="s2">&quot;-10.0&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">PREC</span><span class="p">,</span><span class="s2">&quot;3&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1"># This record is for a 12-bit bipolar ADC for a driver that does not</span>
<span class="c1"># support getBounds()</span>
<span class="n">record</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span><span class="s2">&quot;aiInt32&quot;</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">field</span><span class="p">(</span><span class="n">SCAN</span><span class="p">,</span><span class="s2">&quot;I/O Intr&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asynMask($(port),$(addr),-12)&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">EGUF</span><span class="p">,</span><span class="s2">&quot;10.0&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">EGUL</span><span class="p">,</span><span class="s2">&quot;-10.0&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">PREC</span><span class="p">,</span><span class="s2">&quot;3&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">record</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span><span class="s2">&quot;aiInt32Average&quot;</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">field</span><span class="p">(</span><span class="n">SCAN</span><span class="p">,</span><span class="s2">&quot;10 second&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynInt32Average&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asyn($(port),$(addr))&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">EGUF</span><span class="p">,</span><span class="s2">&quot;10.0&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">EGUL</span><span class="p">,</span><span class="s2">&quot;-10.0&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">PREC</span><span class="p">,</span><span class="s2">&quot;3&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Analog Output Example Record</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="n">record</span><span class="p">(</span><span class="n">ao</span><span class="p">,</span><span class="s2">&quot;aoInt32&quot;</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">OUT</span><span class="p">,</span><span class="s2">&quot;@asyn($(port),$(addr))&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">EGUF</span><span class="p">,</span><span class="s2">&quot;10.0&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">EGUL</span><span class="p">,</span><span class="s2">&quot;-10.0&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">PREC</span><span class="p">,</span><span class="s2">&quot;3&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Long Input Example Records</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">record</span><span class="p">(</span><span class="n">longin</span><span class="p">,</span><span class="s2">&quot;liInt32&quot;</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">field</span><span class="p">(</span><span class="n">SCAN</span><span class="p">,</span><span class="s2">&quot;I/O Intr&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asyn($(port),$(addr))&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Long Output Example Record</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">record</span><span class="p">(</span><span class="n">longout</span><span class="p">,</span><span class="s2">&quot;loInt32&quot;</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">OUT</span><span class="p">,</span><span class="s2">&quot;@asyn($(port),$(addr))&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Multibit Binary Input Example Records</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">record</span><span class="p">(</span><span class="n">mbbi</span><span class="p">,</span><span class="s2">&quot;mbbiInt32&quot;</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">field</span><span class="p">(</span><span class="n">SCAN</span><span class="p">,</span><span class="s2">&quot;I/O Intr&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asyn($(port),$(addr))&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">NOBT</span><span class="p">,</span><span class="s2">&quot;2&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">SHFT</span><span class="p">,</span><span class="s2">&quot;2&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">ZRST</span><span class="p">,</span><span class="s2">&quot;zeroVal&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">ONST</span><span class="p">,</span><span class="s2">&quot;oneVal&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">TWST</span><span class="p">,</span><span class="s2">&quot;twoVal&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">THST</span><span class="p">,</span><span class="s2">&quot;threeVal&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Multibit Binary Output Example Record</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">record</span><span class="p">(</span><span class="n">mbbo</span><span class="p">,</span><span class="s2">&quot;mbboInt32&quot;</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynInt32&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">OUT</span><span class="p">,</span><span class="s2">&quot;@asyn($(port),$(addr))&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">NOBT</span><span class="p">,</span><span class="s2">&quot;2&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">SHFT</span><span class="p">,</span><span class="s2">&quot;16&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">ZRST</span><span class="p">,</span><span class="s2">&quot;zeroVal&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">ONST</span><span class="p">,</span><span class="s2">&quot;oneVal&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">TWST</span><span class="p">,</span><span class="s2">&quot;twoVal&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">THST</span><span class="p">,</span><span class="s2">&quot;threeVal&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="asynint64-device-support">
<h3><a class="toc-backref" href="#id141" role="doc-backlink">asynInt64 device support</a><a class="headerlink" href="#asynint64-device-support" title="Link to this heading"></a></h3>
<p>asynInt64 device support is available for the ao, ai, longout, and longin records
on all versions of EPICS base. The following support is available in devAsynInt64Misc.dbd.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">device</span><span class="p">(</span><span class="n">longin</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynLiInt64</span><span class="p">,</span><span class="s2">&quot;asynInt64&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">longout</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynLoInt64</span><span class="p">,</span><span class="s2">&quot;asynInt64&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynAiInt64</span><span class="p">,</span><span class="s2">&quot;asynInt64&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">ao</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynAoInt64</span><span class="p">,</span><span class="s2">&quot;asynInt64&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Support for the int64in, int64out, and waveform records is available in EPICS base
3.16.1 and later. That is when the int64in, int64out records were added, and when
the waveform record added support for FTVL=Int64. The following support is available
in devAsynInt64.dbd:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">device</span><span class="p">(</span><span class="n">int64in</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">Int64Out</span><span class="p">,</span><span class="s2">&quot;asynInt64&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">int64out</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">Int64Out</span><span class="p">,</span><span class="s2">&quot;asynInt64&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>devAsynInt64.c provides EPICS device support for drivers that implement interface
asynInt64.</p>
<ul>
<li><p>aiRecord</p>
<p>A 64-bit integer is read from the driver and converted to a 64-bit float. The 64-bit
float can exactly represent integers up to 52 bits. The value is read into the .VAL
field, not the .RVAL field. Linear conversion is limited to .EOFF and .ESLO. Each
time the record is processed a new value is read. SCAN “I/O Intr” is supported.</p>
</li>
<li><p>aoRecord</p>
<p>The 64-bit float .VAL is converted to a 64-bit integer and written to the driver.
The 64-bit float can exactly represent integers up to 52 bits. The value is read
from the .VAL field, not from the .RVAL field. Linear conversion is limited to .EOFF
and .ESLO.</p>
</li>
<li><p>longinRecord</p>
<p>A 64-bit integer is read from the driver and truncated to a 32-bit integer. Each
time the record is processed a new value is read. SCAN “I/O Intr” is supported.</p>
</li>
<li><p>longoutRecord</p>
<p>A 32-bit integer is written to the driver from the .VAL field.</p>
</li>
<li><p>int64inRecord</p>
<p>A value is given to .VAL. Each time the record is processed a new value is read.
SCAN “I/O Intr” is supported similar to aiRecord.</p>
</li>
<li><p>int64outRecord</p>
<p>.VAL is written.</p>
</li>
</ul>
<p>Int64 Input Example Records. The longin and ai records are the same except for the
record type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">record</span><span class="p">(</span><span class="n">int64in</span><span class="p">,</span><span class="s2">&quot;Int64In&quot;</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">field</span><span class="p">(</span><span class="n">SCAN</span><span class="p">,</span><span class="s2">&quot;I/O Intr&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynInt64&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asyn($(port),$(addr))&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Int64 Output Example Record. The longout and ao records are the same except for
the record type</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">record</span><span class="p">(</span><span class="n">int64out</span><span class="p">,</span><span class="s2">&quot;Int64Out&quot;</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynInt64&quot;</span><span class="p">)</span>
     <span class="n">field</span><span class="p">(</span><span class="n">OUT</span><span class="p">,</span><span class="s2">&quot;@asyn($(port),$(addr))&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="asynintxxxarray-device-support-xxx-8-16-32-or-64">
<h3><a class="toc-backref" href="#id142" role="doc-backlink">asynIntXXXArray device support (XXX=8, 16, 32, or 64)</a><a class="headerlink" href="#asynintxxxarray-device-support-xxx-8-16-32-or-64" title="Link to this heading"></a></h3>
<p>The following support is available:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">device</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynIntXXXArrayWfIn</span><span class="p">,</span><span class="s2">&quot;asynIntXXXArrayIn&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynIntXXXArrayWfOut</span><span class="p">,</span><span class="s2">&quot;asynIntXXXArrayOut&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>devAsynIntXXXArray.c provides EPICS device support for drivers that implement interface
asynIntXXXArray. It has support for both reading and writing a waveform. SCAN “I/O
Intr” is supported similar to the aiRecord in devAsynInt32 device support.</p>
</section>
<section id="asynxxxtimeseries-device-support-xxx-int32-int64-or-float64">
<h3><a class="toc-backref" href="#id143" role="doc-backlink">asynXXXTimeSeries device support (XXX=Int32, Int64, or Float64)</a><a class="headerlink" href="#asynxxxtimeseries-device-support-xxx-int32-int64-or-float64" title="Link to this heading"></a></h3>
<p>The following support is available:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">device</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynInt32TimeSeries</span><span class="p">,</span><span class="s2">&quot;asynInt32TimeSeries&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynInt64TimeSeries</span><span class="p">,</span><span class="s2">&quot;asynInt64TimeSeries&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynFloat64TimeSeries</span><span class="p">,</span><span class="s2">&quot;asynFloat64TimeSeries&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>devAsynXXXTimeSeries.c provides EPICS device support to collect a time series of
values into a waveform record. It works with drivers that implement callbacks on
the asynInt32, asynInt64, or asynFloat64 interfaces. This permits more rapid and
efficient acquisition of values from a driver than can be obtained using record
support and database operations. The waveform record RARM field is used to control
acquisition as follows:</p>
<ul class="simple">
<li><p>RARM=1 Erase and start acquisition, i.e. clear the waveform record to 0, set NORD=0,
BUSY=1 and enable callbacks.</p></li>
<li><p>RARM=2 Stop acquisition, set BUSY=0.</p></li>
<li><p>RARM=3 Start acquisition (set BUSY=1) without clearing the waveform or setting
NORD=0.</p></li>
</ul>
</section>
<section id="asynuint32digital-device-support">
<h3><a class="toc-backref" href="#id144" role="doc-backlink">asynUInt32Digital device support</a><a class="headerlink" href="#asynuint32digital-device-support" title="Link to this heading"></a></h3>
<p>The following support is available:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">device</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynBiUInt32Digital</span><span class="p">,</span><span class="s2">&quot;asynUInt32Digital&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">bo</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynBoUInt32Digital</span><span class="p">,</span><span class="s2">&quot;asynUInt32Digital&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">longin</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynLiUInt32Digital</span><span class="p">,</span><span class="s2">&quot;asynUInt32Digital&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">longout</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynLoUInt32Digital</span><span class="p">,</span><span class="s2">&quot;asynUInt32Digital&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">mbbi</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynMbbiUInt32Digital</span><span class="p">,</span><span class="s2">&quot;asynUInt32Digital&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">mbbo</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynMbboUInt32Digital</span><span class="p">,</span><span class="s2">&quot;asynUInt32Digital&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">mbbiDirect</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynMbbiDirectUInt32Digital</span><span class="p">,</span><span class="s2">&quot;asynUInt32Digital&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">mbboDirect</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynMbboDirectUInt32Digital</span><span class="p">,</span><span class="s2">&quot;asynUInt32Digital&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>devAsynUInt32Digital.c provides EPICS device support for drivers that implement
interface asynUInt32Digital. The INP or OUT field must define asynMask. The mask
specified in the argument to asynMask is used in the calls to asynUInt32Digital
methods. In addition it is used to set the mask fields in bi and bo records and
the mask and shft fields in mbbi, mbbo, mbbiDirect, and mbboDirect records.</p>
<ul>
<li><p>biRecord</p>
<p>A value is given to rval. asynInt32 - SCAN “I/O Intr” is supported. If the record
is “I/O Intr” scanned then when the registerInterruptUser callback is called, it
saves the value and calls scanIoRequest. When the record is processed the saved
value is put into rval. If the record is not “I/O Intr” scanned then each time the
record is processed, a new value is read via a call to pasynUInt32Digital-&gt;read.</p>
</li>
<li><p>boRecord</p>
<p>rval is written.</p>
</li>
<li><p>longinRecord</p>
<p>A value is given to val. Each time the record is processed a new value is read.
SCAN “I/O Intr” is supported similar to aiRecord.</p>
</li>
<li><p>longoutRecord</p>
<blockquote>
<div><p>val is written.</p>
</div></blockquote>
</li>
<li><p>mbbiRecord</p>
<p>A value is given to rval. Each time the record is processed a new value is read.
SCAN “I/O Intr” is supported similar to aiRecord.</p>
</li>
<li><p>mbboRecord</p>
<p>rval is written.</p>
</li>
<li><p>mbbiDirectRecord</p>
<p>A value is given to rval. Each time the record is processed a new value is read.
SCAN “I/O Intr” is supported similar to aiRecord.</p>
</li>
<li><p>mbboDirectRecord</p>
<p>rval is written.</p>
</li>
</ul>
<p>Binary Input Example Record</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">record</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span><span class="s2">&quot;biUInt32Bit0&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">field</span><span class="p">(</span><span class="n">SCAN</span><span class="p">,</span><span class="s2">&quot;I/O Intr&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynUInt32Digital&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asynMask( $(port) , 0, 0x1 , 1.0) &quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">ZNAM</span><span class="p">,</span><span class="s2">&quot;zero&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">ONAM</span><span class="p">,</span><span class="s2">&quot;one&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Binary Output Example Record</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">record</span><span class="p">(</span><span class="n">bo</span><span class="p">,</span><span class="s2">&quot;boUInt32Bit2&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynUInt32Digital&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">OUT</span><span class="p">,</span><span class="s2">&quot;@asynMask( $(port) , 0, 0x4 , 1.0) &quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">ZNAM</span><span class="p">,</span><span class="s2">&quot;zero&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">ONAM</span><span class="p">,</span><span class="s2">&quot;one&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Long Input Example Record</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">record</span><span class="p">(</span><span class="n">longin</span><span class="p">,</span><span class="s2">&quot;liUInt32&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">field</span><span class="p">(</span><span class="n">SCAN</span><span class="p">,</span><span class="s2">&quot;I/O Intr&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynUInt32Digital&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asynMask( $(port) , 0, 0xffffffff , 1.0) &quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Long Output Example Record</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">record</span><span class="p">(</span><span class="n">longout</span><span class="p">,</span><span class="s2">&quot;loUInt32&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynUInt32Digital&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">OUT</span><span class="p">,</span><span class="s2">&quot;@asynMask( $(port) , 0, 0xffffffff , 1.0) &quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Multibit Input Example Record</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">record</span><span class="p">(</span><span class="n">mbbi</span><span class="p">,</span><span class="s2">&quot;mbbiUInt32&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">field</span><span class="p">(</span><span class="n">SCAN</span><span class="p">,</span><span class="s2">&quot;I/O Intr&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynUInt32Digital&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asynMask( digital , 0, 0x3 , 1.0) &quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">ZRST</span><span class="p">,</span><span class="s2">&quot;zero&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">ONST</span><span class="p">,</span><span class="s2">&quot;one&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">TWST</span><span class="p">,</span><span class="s2">&quot;two&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">THST</span><span class="p">,</span><span class="s2">&quot;three&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">ZRVL</span><span class="p">,</span><span class="s2">&quot;0x0&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">ONVL</span><span class="p">,</span><span class="s2">&quot;0x1&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">TWVL</span><span class="p">,</span><span class="s2">&quot;0x2&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">THVL</span><span class="p">,</span><span class="s2">&quot;0x3&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Multibit Output Example Record</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">record</span><span class="p">(</span><span class="n">mbbo</span><span class="p">,</span><span class="s2">&quot;mbboUInt32&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">field</span><span class="p">(</span><span class="n">DTYP</span><span class="p">,</span><span class="s2">&quot;asynUInt32Digital&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">OUT</span><span class="p">,</span><span class="s2">&quot;@asynMask( digital , 0, 0x7 , 1.0) &quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">ZRST</span><span class="p">,</span><span class="s2">&quot;zero&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">ONST</span><span class="p">,</span><span class="s2">&quot;one&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">TWST</span><span class="p">,</span><span class="s2">&quot;two&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">THST</span><span class="p">,</span><span class="s2">&quot;three&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">FRST</span><span class="p">,</span><span class="s2">&quot;four&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">FVST</span><span class="p">,</span><span class="s2">&quot;five&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">SXST</span><span class="p">,</span><span class="s2">&quot;six&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">SVST</span><span class="p">,</span><span class="s2">&quot;seven&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">ZRVL</span><span class="p">,</span><span class="s2">&quot;0x0&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">ONVL</span><span class="p">,</span><span class="s2">&quot;0x1&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">TWVL</span><span class="p">,</span><span class="s2">&quot;0x2&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">THVL</span><span class="p">,</span><span class="s2">&quot;0x3&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">FRVL</span><span class="p">,</span><span class="s2">&quot;0x4&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">FVVL</span><span class="p">,</span><span class="s2">&quot;0x5&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">SXVL</span><span class="p">,</span><span class="s2">&quot;0x6&quot;</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="n">SVVL</span><span class="p">,</span><span class="s2">&quot;0x7&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="asynfloat64-device-support">
<h3><a class="toc-backref" href="#id145" role="doc-backlink">asynFloat64 device support</a><a class="headerlink" href="#asynfloat64-device-support" title="Link to this heading"></a></h3>
<p>The following support is available:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">device</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynAiFloat64</span><span class="p">,</span><span class="s2">&quot;asynFloat64&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynAiFloat64Average</span><span class="p">,</span><span class="s2">&quot;asynFloat64Average&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">ao</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynAoFloat64</span><span class="p">,</span><span class="s2">&quot;asynFloat64&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>devAsynFloat64.c provides EPICS device support for drivers that implement interface
asynFloat64.</p>
<ul>
<li><p>aiRecord</p>
<p>A value is given to val. Beginning with R4-33 scaling via the ASLO/AOFF record fields,
and smoothing via the SMOO field are supported.</p>
<blockquote>
<div><ul class="simple">
<li><p>asynFloat64</p>
<ul>
<li><p>SCAN “I/O Intr” is supported. If the record is “I/O Intr” scanned
then when the registerInterruptUser callback is called, it saves the value and calls
scanIoRequest. When the record is processed the saved value is put into val.</p></li>
<li><p>If the record is not “I/O Intr” scanned then each time the record is processed, a new
value is read via a call to pasynFloat64-&gt;read.</p></li>
</ul>
</li>
<li><p>asynFloat64Average</p>
<ul>
<li><p>The registerInterruptUser callback adds the new value to
a sum and also increments the number of samples.</p></li>
<li><p>When the record is processed the average is computed and the sum and number of samples is set to zero.</p></li>
<li><p>If the record is processed before new data have arrived (numAverage==0) the record is set to UDF/INVALID,
UDF is set to TRUE, and the value is left unchanged.</p></li>
<li><p>The record can be scanned either periodically or with SCAN=I/O Intr.</p></li>
<li><p>If the record has SCAN=I/O Intr then the average is computed and the record is processed each time NumAverage callback readings have
been received.</p></li>
<li><p>The SVAL field in the ai record is used to set NumAverage.</p></li>
</ul>
</li>
</ul>
</div></blockquote>
</li>
<li><p>aoRecord</p>
<p>val is written. Beginning with R4-33 scaling via the ASLO/AOFF record fields is
supported.</p>
</li>
</ul>
</section>
<section id="asynfloatxxxarray-device-support-xxx-32-or-64">
<h3><a class="toc-backref" href="#id146" role="doc-backlink">asynFloatXXXArray device support (XXX=32 or 64)</a><a class="headerlink" href="#asynfloatxxxarray-device-support-xxx-32-or-64" title="Link to this heading"></a></h3>
<p>The following support is available:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">device</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynFloatXXXArrayWfIn</span><span class="p">,</span><span class="s2">&quot;asynFloatXXXArrayIn&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynFloatXXXArrayWfOut</span><span class="p">,</span><span class="s2">&quot;asynFloatXXXArrayOut&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>devAsynFloatXXXArray.c provides EPICS device support for drivers that implement
interface asynFloatXXXArray. It has support for both reading and writing a waveform.
SCAN “I/O Intr” is supported similar to the aiRecord in devAsynInt32 device support.</p>
</section>
<section id="asynoctet-device-support">
<h3><a class="toc-backref" href="#id147" role="doc-backlink">asynOctet device support</a><a class="headerlink" href="#asynoctet-device-support" title="Link to this heading"></a></h3>
<p>The following support is available:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">device</span><span class="p">(</span><span class="n">stringin</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynSiOctetCmdResponse</span><span class="p">,</span><span class="s2">&quot;asynOctetCmdResponse&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">stringin</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynSiOctetWriteRead</span><span class="p">,</span><span class="s2">&quot;asynOctetWriteRead&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">stringin</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynSiOctetRead</span><span class="p">,</span><span class="s2">&quot;asynOctetRead&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">stringout</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynSoOctetWrite</span><span class="p">,</span><span class="s2">&quot;asynOctetWrite&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynWfOctetCmdResponse</span><span class="p">,</span><span class="s2">&quot;asynOctetCmdResponse&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynWfOctetWriteRead</span><span class="p">,</span><span class="s2">&quot;asynOctetWriteRead&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynWfOctetRead</span><span class="p">,</span><span class="s2">&quot;asynOctetRead&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynWfOctetWrite</span><span class="p">,</span><span class="s2">&quot;asynOctetWrite&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">waveform</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynWfOctetWriteBinary</span><span class="p">,</span><span class="s2">&quot;asynOctetWriteBinary&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">lsi</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynLsiOctetCmdResponse</span><span class="p">,</span><span class="s2">&quot;asynOctetCmdResponse&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">lsi</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynLsiOctetWriteRead</span><span class="p">,</span><span class="s2">&quot;asynOctetWriteRead&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">lsi</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynLsiOctetRead</span><span class="p">,</span><span class="s2">&quot;asynOctetRead&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">lso</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynLsoOctetWrite</span><span class="p">,</span><span class="s2">&quot;asynOctetWrite&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">printf</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynPfOctetWrite</span><span class="p">,</span><span class="s2">&quot;asynOctetWrite&quot;</span><span class="p">)</span>
<span class="n">device</span><span class="p">(</span><span class="n">scalcout</span><span class="p">,</span><span class="n">INST_IO</span><span class="p">,</span><span class="n">asynScalcoutOctetWrite</span><span class="p">,</span><span class="s2">&quot;asynOctetWrite&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Support for drivers that implement interface asynOctet. The support is for stringin/stringout
lsi/lso, printf, sCalcout, and waveform records. lsi, lso, and printf are only supported
on EPICS base 3.15 and higher. sCalcout is only supported if CALC module is defined
in configure/RELEASE. The waveform support is similar to the string support. The
waveform records must define FTVL to be CHAR or UCHAR, i.e. it must be an array
of octets. The waveform provides the following features not provided by the string
support:</p>
<ul class="simple">
<li><p>Unlimited size - string records hold a maximum of 40 characters.</p></li>
<li><p>Both string and binary data. Beginning in R4-30 asynWfWriteOctet calls strnlen()
to determine the length of the string, and passes this length to the driver, i.e.
does not include the trailing nil. This is consistent with the behavior of the devAsynOctet
for the stringout record. The asynOctetWriteBinary support added in R4-30 always
uses NORD as the length that it passes to the driver, and does not call strnlen().</p></li>
</ul>
<p>Four types of support are provided:</p>
<ul>
<li><p>CmdResponse The INP field is of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asyn(portName,addr,timeout) cmd&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>During record initialization, cmd is converted by dbTranslateEscape. The resultant
string is the command to send to the device. When the record is processed the command
is sent to the device and the response read into the record.</p>
</li>
<li><p>WriteRead The INP field is of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asyn(portName,addr,timeout) pvname&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>pvname must refer to a field in a record in the same IOC. During record initialization
the pvname is located. When the record is processed dbGet is called to read the
current value of pvname. This value is sent to the device. A read is then issued
and the result stored in the record. For asynSiOctetWriteRead, the value obtained
from pvname is passed through dbTranslateEscape before sending it. For asynWfOctetWriteRead
it is not passed through dbTranslateEscape.</p>
</li>
<li><p>Write The INP(OUT) field is of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asyn(portName,addr,timeout) drvUser&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>drvUser is information that is passed to the portDriver if it implements interface
asynDrvUser. When the record is processed the value stored in the record is sent
to the device.</p>
</li>
<li><p>Read The INP field is of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asyn(portName,addr,timeout) drvUser&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>drvUser is information that is passed to the portDriver if it implements interface
asynDrvUser. When the record is processed a read request is made. The result is
read into the record.</p>
</li>
</ul>
</section>
<section id="record-alarms">
<h3><a class="toc-backref" href="#id148" role="doc-backlink">Record alarms</a><a class="headerlink" href="#record-alarms" title="Link to this heading"></a></h3>
<p>The generic EPICS device support sets the record alarm status and severity when
errors occur. Beginning in R4-30 the alarmStatus and alarmSeverity fields were added
to the asynUser structure. Drivers can use these fields to explicitly control the
record STAT and SEVERITY fields, independent of the function return status or the
asynUser.auxStatus field.</p>
<p>If the pasynUser-&gt;alarmStatus or pasynUser-&gt;alarmSeverity field is zero then
the record alarm status or severity is controlled by the function return status
or the asynUser.auxStatus field. For records that do not use callbacks (not SCAN=I/O
Intr or asynXXXAverage or asynXXXTimeSeries) the status information is passed from
the driver to device support in the asynStatus return of the interface function
call, e.g. pasynInt32-&gt;read(). The driver maps the asynStatus values to the record
STAT and SEVR values using the function pasynEpicsUtils-&gt;asynUserToEpicsAlarm().
The SEVR field is currently always set to INVALID_ALARM for any error. The STAT
field is set using following mapping:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asynSuccess</span> <span class="o">=</span> <span class="n">epicsAlarmNone</span>
<span class="n">asynTimeout</span> <span class="o">=</span> <span class="n">epicsAlarmTimeout</span>
<span class="n">asynOverflow</span> <span class="o">=</span> <span class="n">epicsAlarmHWLimit</span>
<span class="n">asynError</span> <span class="o">=</span> <span class="n">epicsAlarmRead</span> <span class="ow">or</span> <span class="n">epicsAlarmWrite</span>
<span class="n">asynDisconnected</span> <span class="o">=</span> <span class="n">epicsAlarmComm</span>
<span class="n">asynDisabled</span> <span class="o">=</span> <span class="n">epicsAlarmDisable</span>
</pre></div>
</div>
<p>For records that use callbacks, the status information is passed from the driver
to device support using the pasynUser-&gt;auxStatus field in the pasynUser that
is passed in the callback. This feature was added in asyn R4-19. Prior to that release
it was not possible for drivers to control the alarm state of records that used
callbacks. Drivers should set pasynUser-&gt;auxStatus to asynSuccess for normal
operation and to another value to indicate a problem. The same mapping described
above is used to control the values of STAT and SEVR. If the pasynUser-&gt;alarmStatus
or pasynUser-&gt;alarmSeverity fields are non-zero then these values are used to
set the record STAT and SEVR fields, regardless of the value of asynUser.auxStatus.</p>
</section>
</section>
<section id="asynrecord-generic-epics-record-support">
<h2><a class="toc-backref" href="#id149" role="doc-backlink">asynRecord: Generic EPICS Record Support</a><a class="headerlink" href="#asynrecord-generic-epics-record-support" title="Link to this heading"></a></h2>
<p>A special record type asynRecord is provided. Details are described in <a class="reference external" href="asynRecord.html">asynRecord.html</a>.
This section provides a brief description of how to use it.</p>
<p>Each IOC can load one or more instances of asynRecord. An example is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dbLoadRecords</span><span class="p">(</span><span class="s2">&quot;$(ASYN)/db/asynRecord.db&quot;</span><span class="p">,</span><span class="s2">&quot;P=asyn,R=Test,PORT=L0,ADDR=15,IMAX=0,OMAX=0&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The example creates a record with name “asynTest” (formed from the concatenation
of the P and R macros) that will connect to port “L0” and addr 15. After the ioc
is started, it is possible to change PORT and/or ADDR. Thus, a single record can
be used to access all asyn devices connected to the IOC. Multiple records are only
needed if one or more devices need a dedicated record.</p>
<p>An medm display is available for accessing an asynRecord. It is started as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">&lt;</span><span class="n">asyn</span><span class="o">&gt;/</span><span class="n">medm</span>
<span class="n">medm</span> <span class="o">-</span><span class="n">x</span> <span class="o">-</span><span class="n">macro</span> <span class="s2">&quot;P=asyn,R=Test&quot;</span> <span class="n">asynRecord</span><span class="o">.</span><span class="n">adl</span>
</pre></div>
</div>
<p>The following medm display appears.</p>
<figure class="align-center" id="id44">
<img alt="_images/asynRecord.png" src="_images/asynRecord.png" />
<figcaption>
<p><span class="caption-text"><strong>asynRecord.adl</strong></span><a class="headerlink" href="#id44" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="asyngpib">
<h2><a class="toc-backref" href="#id150" role="doc-backlink">asynGpib</a><a class="headerlink" href="#asyngpib" title="Link to this heading"></a></h2>
<p>GPIB has additional features that are not supported by asynCommon and asynOctet.
asynGpib defines two interfaces.</p>
<ul>
<li><p>asynGpib - This is the interface that device support calls. It provides the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>A set of GPIB specific methods that device support can call.</p></li>
<li><p>Code that handles generic GPIB functions like SRQ polling.</p></li>
<li><p>A registerPort method which is called by GPIB port drivers.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>asynGpibPort - A set of methods implemented by GPIB drivers</p></li>
</ul>
<section id="asyngpibdriver-h">
<h3><a class="toc-backref" href="#id151" role="doc-backlink">asynGpibDriver.h</a><a class="headerlink" href="#asyngpibdriver-h" title="Link to this heading"></a></h3>
<p>asynGpibDriver.h contains the following definitions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">GPIB</span> <span class="n">Addressed</span> <span class="n">Commands</span><span class="o">*/</span>
<span class="c1">#define IBGTL &quot;\x01&quot;    /* Go to local */</span>
<span class="c1">#define IBSDC &quot;\x04&quot;    /* Selective Device Clear */</span>
<span class="c1">#define IBGET &quot;\x08&quot;    /* Group Execute Trigger */</span>
<span class="c1">#define IBTCT &quot;\x09&quot;    /* Take Control */</span>

<span class="o">/*</span> <span class="n">GPIB</span> <span class="n">Universal</span> <span class="n">Commands</span><span class="o">*/</span>
<span class="c1">#define IBDCL 0x14      /* Device Clear */</span>
<span class="c1">#define IBLLO 0x11      /* Local Lockout */</span>
<span class="c1">#define IBSPE 0x18      /* Serial Poll Enable */</span>
<span class="c1">#define IBSPD 0x19      /* Serial Poll Disable */</span>
<span class="c1">#define IBUNT 0x5f      /* Untalk */</span>
<span class="c1">#define IBUNL 0x3f      /* Unlisten */</span>

<span class="o">/*</span> <span class="n">Talk</span><span class="p">,</span> <span class="n">Listen</span><span class="p">,</span> <span class="n">Secondary</span> <span class="n">base</span> <span class="n">addresses</span> <span class="o">*/</span>
<span class="c1">#define TADBASE    0x40   /* offset to GPIB listen address 0 */</span>
<span class="c1">#define LADBASE    0x20   /* offset to GPIB talk address 0 */</span>
<span class="c1">#define SADBASE    0x60   /* offset to GPIB secondary address 0 */</span>

<span class="c1">#define NUM_GPIB_ADDRESSES    32</span>
<span class="c1">#include &quot;asynDriver.h&quot;</span>
<span class="c1">#include &quot;asynInt32.h&quot;</span>
<span class="c1">#define asynGpibType &quot;asynGpib&quot;</span>
<span class="o">/*</span> <span class="n">GPIB</span> <span class="n">drivers</span> <span class="o">*/</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynGpib</span> <span class="n">asynGpib</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">asynGpibPort</span> <span class="n">asynGpibPort</span><span class="p">;</span>
<span class="o">/*</span><span class="n">asynGpib</span> <span class="n">defines</span> <span class="n">methods</span> <span class="n">called</span> <span class="n">by</span> <span class="n">gpib</span> <span class="n">aware</span> <span class="n">users</span><span class="o">*/</span>
<span class="n">struct</span> <span class="n">asynGpib</span><span class="p">{</span>
    <span class="o">/*</span><span class="n">addressedCmd</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">ren</span> <span class="n">are</span> <span class="n">just</span> <span class="n">passed</span> <span class="n">to</span> <span class="n">device</span> <span class="n">handler</span><span class="o">*/</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">addressedCmd</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
        <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="nb">int</span> <span class="n">length</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">universalCmd</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span><span class="nb">int</span> <span class="n">cmd</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">ifc</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">ren</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="nb">int</span> <span class="n">onOff</span><span class="p">);</span>
    <span class="o">/*</span> <span class="n">The</span> <span class="n">following</span> <span class="n">are</span> <span class="n">implemented</span> <span class="n">by</span> <span class="n">asynGpib</span> <span class="o">*/</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">pollAddr</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="nb">int</span> <span class="n">onOff</span><span class="p">);</span>
    <span class="o">/*</span> <span class="n">The</span> <span class="n">following</span> <span class="n">are</span> <span class="n">called</span> <span class="n">by</span> <span class="n">low</span> <span class="n">level</span> <span class="n">gpib</span> <span class="n">drivers</span> <span class="o">*/</span>
    <span class="o">/*</span><span class="n">srqHappened</span> <span class="ow">is</span> <span class="n">passed</span> <span class="n">the</span> <span class="n">pointer</span> <span class="n">returned</span> <span class="n">by</span> <span class="n">registerPort</span><span class="o">*/</span>
    <span class="n">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">registerPort</span><span class="p">)(</span>
        <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">portName</span><span class="p">,</span>
        <span class="nb">int</span> <span class="n">attributes</span><span class="p">,</span><span class="nb">int</span> <span class="n">autoConnect</span><span class="p">,</span>
        <span class="n">asynGpibPort</span> <span class="o">*</span><span class="n">pasynGpibPort</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">asynGpibPortPvt</span><span class="p">,</span>
        <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">priority</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">stackSize</span><span class="p">);</span>
    <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">srqHappened</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">asynGpibPvt</span><span class="p">);</span>
<span class="p">};</span>
<span class="n">epicsShareExtern</span> <span class="n">asynGpib</span> <span class="o">*</span><span class="n">pasynGpib</span><span class="p">;</span>

<span class="n">struct</span> <span class="n">asynGpibPort</span> <span class="p">{</span>
    <span class="o">/*</span><span class="n">asynCommon</span> <span class="n">methods</span> <span class="o">*/</span>
    <span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">report</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">FILE</span> <span class="o">*</span><span class="n">fd</span><span class="p">,</span><span class="nb">int</span> <span class="n">details</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="o">/*</span><span class="n">asynOctet</span> <span class="n">methods</span> <span class="n">passed</span> <span class="n">through</span> <span class="kn">from</span> <span class="nn">asynGpib</span><span class="o">*/</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                      <span class="n">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="nb">int</span> <span class="n">maxchars</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">nbytesTransfered</span><span class="p">,</span>
                      <span class="nb">int</span> <span class="o">*</span><span class="n">eomReason</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                      <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="nb">int</span> <span class="n">numchars</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">nbytesTransfered</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">setEos</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">eos</span><span class="p">,</span><span class="nb">int</span> <span class="n">eoslen</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">getEos</span><span class="p">)(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                <span class="n">char</span> <span class="o">*</span><span class="n">eos</span><span class="p">,</span> <span class="nb">int</span> <span class="n">eossize</span><span class="p">,</span> <span class="nb">int</span> <span class="o">*</span><span class="n">eoslen</span><span class="p">);</span>
    <span class="o">/*</span><span class="n">asynGpib</span> <span class="n">methods</span> <span class="n">passed</span> <span class="n">thrtough</span> <span class="kn">from</span> <span class="nn">asynGpib</span><span class="o">*/</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">addressedCmd</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span>
                <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="nb">int</span> <span class="n">length</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">universalCmd</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cmd</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">ifc</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">ren</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="n">asynUser</span> <span class="o">*</span><span class="n">pasynUser</span><span class="p">,</span> <span class="nb">int</span> <span class="n">onOff</span><span class="p">);</span>
    <span class="o">/*</span><span class="n">asynGpibPort</span> <span class="n">specific</span> <span class="n">methods</span> <span class="o">*/</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">srqStatus</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">isSet</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">srqEnable</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="nb">int</span> <span class="n">onOff</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">serialPollBegin</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">serialPoll</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">,</span> <span class="nb">int</span> <span class="n">addr</span><span class="p">,</span> <span class="n">double</span> <span class="n">timeout</span><span class="p">,</span><span class="nb">int</span> <span class="o">*</span><span class="n">status</span><span class="p">);</span>
    <span class="n">asynStatus</span> <span class="p">(</span><span class="o">*</span><span class="n">serialPollEnd</span><span class="p">)</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">drvPvt</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id2">
<h3><a class="toc-backref" href="#id152" role="doc-backlink">asynGpib</a><a class="headerlink" href="#id2" title="Link to this heading"></a></h3>
<p>asynGpib describes the interface for device support code. It provides gpib specific
functions like SRQ handling. It makes calls to asynGpibPort. asynGpib.c implements
asynCommon and asynOctet. It supports asynInt32 by using the methods from asynInt32Base.
asynInt32 is the way asynGpib reports SRQs to asynUsers.</p>
<p>An asynUser that wishes to receive SRQs calls pasynInt32-&gt;registerInterruptUser
and must set asynUser.reason = ASYN_REASON_SIGNAL. Although most gpib controllers
are multidevice drivers, the VXI11 standard allows for a controller (VXI-11.2) that
attached to a single device, i.e. it is a single address port driver. For such controllers,
the use must specify addr = 0 in order to use SRQs. Also see the vxi support below
for more details.</p>
<table class="docutils align-default" id="id45">
<caption><span class="caption-text">asynGpib</span><a class="headerlink" href="#id45" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>addressedCmd</p></td>
<td><p>The request is passed to the low level driver.</p></td>
</tr>
<tr class="row-even"><td><p>universalCmd</p></td>
<td><p>The request is passed to the low level driver.</p></td>
</tr>
<tr class="row-odd"><td><p>ifc</p></td>
<td><p>The request is passed to the low level driver.</p></td>
</tr>
<tr class="row-even"><td><p>ren</p></td>
<td><p>The request is passed to the low level driver.</p></td>
</tr>
<tr class="row-odd"><td><p>pollAddr</p></td>
<td><p>Set SRQ polling on or off. onOff = (0,1) means (disable, enable) SRQ polling of
specified address.</p></td>
</tr>
<tr class="row-even"><td><p>registerPort</p></td>
<td><p>Register a port. When asynGpib receives this request, it calls asynManager.registerPort.</p></td>
</tr>
<tr class="row-odd"><td><p>srqHappened</p></td>
<td><p>Called by low level driver when it detects that a GPIB device issues an SRQ.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asyngpibport">
<h3><a class="toc-backref" href="#id153" role="doc-backlink">asynGpibPort</a><a class="headerlink" href="#asyngpibport" title="Link to this heading"></a></h3>
<p>asynGpibPort is the interface that is implemented by gpib drivers, e.g. the VXI-11.
It provides:</p>
<table class="docutils align-default" id="id46">
<caption><span class="caption-text">asynGpibPort</span><a class="headerlink" href="#id46" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>asynCommon methods</p></td>
<td><p>All the methods of asynCommon</p></td>
</tr>
<tr class="row-even"><td><p>asynOctet methods</p></td>
<td><p>All the methods of asynOctet</p></td>
</tr>
<tr class="row-odd"><td><p>addressedCmd</p></td>
<td><p>Issue a GPIB addressed command.</p></td>
</tr>
<tr class="row-even"><td><p>universalCmd</p></td>
<td><p>Issue a GPIB universal command.</p></td>
</tr>
<tr class="row-odd"><td><p>ifc</p></td>
<td><p>Issue a GPIB Interface Clear command.</p></td>
</tr>
<tr class="row-even"><td><p>ren</p></td>
<td><p>Issue a GPIB Remote Enable command</p></td>
</tr>
<tr class="row-odd"><td><p>srqStatus</p></td>
<td><p>If return is asynSuccess then isSet is (0,1) if SRQ (is not, is) active. Normally
only called by asynGpib.</p></td>
</tr>
<tr class="row-even"><td><p>srqEnable</p></td>
<td><p>Enable or disable SRQs. Normally only called by asynGpib.</p></td>
</tr>
<tr class="row-odd"><td><p>serialPollBegin</p></td>
<td><p>Start of serial poll. Normally only called by asynGpib.</p></td>
</tr>
<tr class="row-even"><td><p>serialPoll</p></td>
<td><p>Poll the specified address and set status to the response. Normally only called
by asynGpib.</p></td>
</tr>
<tr class="row-odd"><td><p>serialPollEnd</p></td>
<td><p>End of serial poll. Normally only called by asynGpib.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="port-drivers">
<h2><a class="toc-backref" href="#id154" role="doc-backlink">Port Drivers</a><a class="headerlink" href="#port-drivers" title="Link to this heading"></a></h2>
<section id="local-serial-port">
<h3><a class="toc-backref" href="#id155" role="doc-backlink">Local Serial Port</a><a class="headerlink" href="#local-serial-port" title="Link to this heading"></a></h3>
<p>The drvAsynSerialPort driver supports devices connected to serial ports on the IOC.</p>
<p>Serial ports are configured with the <code class="docutils literal notranslate"><span class="pre">drvAsynSerialPortConfigure</span></code> and <code class="docutils literal notranslate"><span class="pre">asynSetOption</span></code> commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">drvAsynSerialPortConfigure</span><span class="p">(</span><span class="s2">&quot;portName&quot;</span><span class="p">,</span><span class="s2">&quot;ttyName&quot;</span><span class="p">,</span><span class="n">priority</span><span class="p">,</span><span class="n">noAutoConnect</span><span class="p">,</span><span class="n">noProcessEosIn</span><span class="p">)</span>
<span class="n">asynSetOption</span><span class="p">(</span><span class="s2">&quot;portName&quot;</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="s2">&quot;key&quot;</span><span class="p">,</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>where the arguments are:</p>
<ul class="simple">
<li><p>portName</p>
<ul>
<li><p>The portName that is registered with asynGpib.</p></li>
</ul>
</li>
<li><p>ttyName</p>
<ul>
<li><p>The name of the local serial port (e.g. “/dev/ttyS0”, “COM1”).</p></li>
</ul>
</li>
<li><p>priority</p>
<ul>
<li><p>Priority at which the asyn I/O thread will run. If this is zero or
missing,then epicsThreadPriorityMedium is used.</p></li>
</ul>
</li>
<li><p>addr</p>
<ul>
<li><p>This argument is ignored since serial devices are configured with multiDevice=0.</p></li>
</ul>
</li>
<li><p>noAutoConnect</p>
<ul>
<li><p>Zero or missing indicates that portThread should automatically
connect. Non-zero if explicit connect command must be issued.</p></li>
</ul>
</li>
<li><p>noProcessEos</p>
<ul>
<li><p>If 0 then asynInterposeEosConfig is called specifying both processEosIn
and processEosOut.</p></li>
</ul>
</li>
</ul>
<p>The setEos and getEos methods have no effect and return asynError. The read method
blocks until at least one character has been received or until a timeout occurs.
The read method transfers as many characters as possible, limited by the specified
count. asynInterposeEos can be used to support EOS.</p>
<p>The following table summarizes the drvAsynSerialPort driver asynSetOption keys and
values. When a serial port connects the current values are fetched.</p>
<p>On some systems (e.g. Windows, Darwin) the driver accepts any numeric value for
the baud rate, which must, of course be supported by the system hardware. On Linux
the choices are limited to the values like B300, B9600, etc. which are defined in
/usr/include/bits/termios.h.</p>
<p>The clocal and crtscts parameter names are taken from the POSIX termios serial interface
definition. The clocal parameter controls whether the modem control lines (Data
Terminal Ready, Carrier Detect/Received Line Signal Detect) are used (clocal=N)
or ignored (clocal=Y). The crtscts parameter controls whether the hardware handshaking
lines (Request To Send, Clear To Send) are used (crtscts=Y) or ignored (crtscts=N).</p>
<p>The vxWorks sioLib serial support does not provide support for modem control lines.
It also uses clocal for what is actually crtscts. For vxWorks the standard serial
support accepts both clocal and crtscts for getOption and setOption. clocal=Y implies
crtscts=N and clocal=N implies crtscts=Y.</p>
<p>ixon controls XON/OFF flow control on output. If the IOC receives an XOFF character,
it suspends output until an XON character is received. This option is also supported
on ports communicating via the RFC 2217 Telnet protocol. In this case, as noted
in the standard, ixon implies both outbound and inbound flow control.</p>
<p>ixoff controls XON/OFF flow control on input. The IOC sends XOFF and XON characters
as necessary to prevent input from coming in faster than programs are reading it.
The external device sending the input data must respond to an XOFF character by
suspending transmission, and to an XON character by resuming transmission.</p>
<p>The ixany flag allows any input character to restart output when output has been
suspended with the XOFF character. Otherwise, only the XON character restarts output.
This flag is not available on all systems, including WIN32.</p>
<p>The rs485 options are only supported on Linux, only kernels &amp;ge; 2.6.35, and only
on hardware ports that support RS-485. The delay option units are integer milliseconds.</p>
<p>The break option should send a serial break state on supported systems (Linux,
Windows work, vxWorks does not). A numeric value should send a break for the
specified time, which is device depended (deci seconds, milli seconds, …).
A zero value means a default time. A value “on” should set the break state on
for a unlimited time and “off” should clear the break state.</p>
<p>vxWorks IOC serial ports may need to be set up using hardware-specific commands.
Once this is done, the standard drvAsynSerialPortConfigure and asynSetOption commands
can be issued. For example, the following example shows the configuration procedure
for a port on a GreenSprings octal UART Industry-Pack module on a GreenSprings VIP616-01
carrier.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ipacAddVIPC616_01</span><span class="p">(</span><span class="s2">&quot;0x6000,B0000000&quot;</span><span class="p">)</span>
<span class="n">tyGSOctalDrv</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">tyGSOctalModuleInit</span><span class="p">(</span><span class="s2">&quot;Mod0&quot;</span><span class="p">,</span><span class="s2">&quot;232&quot;</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">tyGSOctalDevCreate</span><span class="p">(</span><span class="s2">&quot;/tyGS/0/0&quot;</span><span class="p">,</span><span class="s2">&quot;Mod0&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">drvAsynSerialPortConfigure</span><span class="p">(</span><span class="s2">&quot;/tyGS/0/0&quot;</span><span class="p">,</span><span class="s2">&quot;/tyGS/0/0&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">asynSetOption</span><span class="p">(</span><span class="s2">&quot;/tyGS/0/0&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s2">&quot;baud&quot;</span><span class="p">,</span><span class="s2">&quot;9600&quot;</span><span class="p">)</span>

<span class="n">For</span> <span class="n">the</span> <span class="n">IP520</span><span class="p">:</span>

<span class="n">IP520Drv</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">IP520ModuleInit</span><span class="p">(</span><span class="s2">&quot;UART_0&quot;</span><span class="p">,</span> <span class="s2">&quot;232&quot;</span><span class="p">,</span> <span class="mh">0xC2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">IP520DevCreate</span><span class="p">(</span><span class="s2">&quot;A1&quot;</span><span class="p">,</span> <span class="s2">&quot;UART_0&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">drvAsynSerialPortConfigure</span><span class="p">(</span><span class="s2">&quot;A1&quot;</span><span class="p">,</span><span class="s2">&quot;A1&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">asynSetOption</span><span class="p">(</span><span class="s2">&quot;A1&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s2">&quot;baud&quot;</span><span class="p">,</span><span class="mi">9600</span><span class="p">)</span>
<span class="n">asynOctetSetInputEos</span><span class="p">(</span> <span class="s2">&quot;A1&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">asynOctetSetOutputEos</span><span class="p">(</span><span class="s2">&quot;A1&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="tcp-ip-or-udp-ip-port">
<h3><a class="toc-backref" href="#id156" role="doc-backlink">TCP/IP or UDP/IP Port</a><a class="headerlink" href="#tcp-ip-or-udp-ip-port" title="Link to this heading"></a></h3>
<p>The drvAsynIPPort driver supports devices which communicate over a TCP/IP or UDP/IP
connection. A typical example is a device connected through an Ethernet/Serial converter
box.</p>
<p>TCP/IP or UDP/IP connections are configured with the <code class="docutils literal notranslate"><span class="pre">drvAsynIPPortConfigure</span></code>
command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">drvAsynIPPortConfigure</span><span class="p">(</span><span class="s2">&quot;portName&quot;</span><span class="p">,</span><span class="s2">&quot;hostInfo&quot;</span><span class="p">,</span><span class="n">priority</span><span class="p">,</span><span class="n">noAutoConnect</span><span class="p">,</span><span class="n">noProcessEos</span><span class="p">)</span>
</pre></div>
</div>
<p>where the arguments are:</p>
<ul>
<li><p>portName</p>
<ul class="simple">
<li><p>The portName that is registered with asynManager.</p></li>
</ul>
</li>
<li><p>hostInfo</p>
<ul>
<li><p>The Internet host name, port number, optional local port number, and
optional IP protocol of the device. The format is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">host</span><span class="o">&gt;</span><span class="p">:</span><span class="o">&lt;</span><span class="n">port</span><span class="o">&gt;</span><span class="p">[:</span><span class="n">localPort</span><span class="p">]</span> <span class="p">[</span><span class="n">protocol</span><span class="p">]</span>
</pre></div>
</div>
<p>(e.g. “164.54.9.90:4002”, “164.54.9.90:4001:10101”, “serials8n3:4002”, “serials8n3:4002
TCP” or “164.54.17.43:5186 udp”). If no protocol is specified, TCP will be used.</p>
</li>
</ul>
</li>
</ul>
<p>Possible protocols are</p>
<ul class="simple">
<li><p>TCP</p></li>
<li><p>TCP&amp; – Like TCP but use the SO_REUSEPORT socket option.</p></li>
<li><p>UDP</p></li>
<li><p>UDP&amp; – Like UDP but use the SO_REUSEPORT socket option.</p></li>
<li><p>UDP* – Send UDP broadcasts. The address portion of the argument must be the network
broadcast address (e.g. “192.168.1.255:1234 UDP*”, or “255.255.255.255:1234 UDP*”, etc.)</p></li>
<li><p>UDP*&amp; – Like UDP* but use the SO_REUSEPORT socket option.</p></li>
<li><p>HTTP – Like TCP but for servers which close the connection after each transaction.</p></li>
<li><p>COM – For Ethernet/Serial adapters which use the TELNET RFC 2217 protocol. This
allows port parameters (speed, parity, etc.) to be set with subsequent asynSetOption
commands just as for local serial ports. The default parameters are 9600-8-N-1 with
no flow control.</p></li>
</ul>
<p>If the hostInfo argument begins with the characters <strong>unix://</strong> the remainder of the argument
is taken to be the name of a UNIX-domain stream socket.</p>
<p><a class="reference external" href="https://lwn.net/Articles/542629/">This article</a> explains the use of
the SO_REUSEPORT option for both TCP and UDP. The particular use case that motivated
the addition of the SO_REUSEPORT to this driver is discussed in
<a class="reference external" href="https://github.com/epics-modules/asyn/issues/108">this Github issue</a>.
On Windows and RTEMS SO_REUSEADDR is used instead of SO_RESUSEPORT, but it should have the same effect.</p>
<p>To receive UDP broadcasts the localPort is the port to listen on, for example:
<code class="docutils literal notranslate"><span class="pre">drvAsynIPPortConfigure(&quot;BD&quot;,&quot;255.255.255.255:1234:3956</span> <span class="pre">UDP*&quot;,0,0,0)</span></code>.
If the port is only to be used to receive broadcast messages then
the UDP protocol should be specified. If it is also to be used to send UDP broadcasts
then the UDP* protocol must be specified. In this case the broadcasts will be send
on port “port” and it will listen for broadcast messages on port “localPort”.
Note that the localPort should almost never be used for TCP ports because normally
the local host choses an unused random local port that it binds to and passes to
the server. However, there are some unusual servers that only accept a specific
local port or range of local ports, in which case localPort must be specified.
- priority - Priority at which the asyn I/O thread will run. If this is zero or
missing, then epicsThreadPriorityMedium is used.</p>
<ul class="simple">
<li><p>noAutoConnect</p>
<ul>
<li><p>Zero or missing indicates that portThread should automatically
connect.</p></li>
<li><p>Non-zero if explicit connect command must be issued.</p></li>
</ul>
</li>
<li><p>noProcessEos</p>
<ul>
<li><p>If 0 then asynInterposeEosConfig is called specifying both processEosIn
and processEosOut.</p></li>
</ul>
</li>
</ul>
<p>Only asynOctet methods write, read, and flush are implemented. Calling the other
methods will result in an error unless asynInterposeEos is used for the other asynOctet
methods. read blocks until at least one character has been received or until a timeout
occurs. read transfers as many characters as possible, limited by the specified
count.</p>
<p>The following table summarizes the drvAsynIPPort driver asynSetOption keys and values.</p>
<table class="docutils align-default" id="id47">
<caption><span class="caption-text">TCP/IP or UDP/IP Port</span><a class="headerlink" href="#id47" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>disconnectOnReadTimeout</p></td>
<td><p>N Y</p></td>
<td><p>Default=N. If Y then if a read operation times out the driver automatically disconnect
the IP port.</p></td>
</tr>
<tr class="row-odd"><td><p>hostInfo</p></td>
<td><p>&lt;host&gt;:&lt;port&gt;[:localPort] [protocol]</p></td>
<td><p>The IP port hostInfo specification using the same syntax as drvAsynIPPortConfigure.
This option allows changing at run time the Internet host and port to which this
asyn port is connected. The only restriction is that the setting of the COM (TELNET
RFC 2217) protocol cannot be changed from that specified with drvAsynIPPortConfigure.
This is because if COM is specified in the drvAsynIPPortConfigure command then asynOctet
and asynOption interpose interfaces are used, and asynManager does not support removing
interpose interfaces.</p></td>
</tr>
</tbody>
</table>
<p>In addition to these key/value pairs if the COM protocol is used then the drvAsynIPPort
driver uses the same key/value pairs as the drvAsynSerialPort driver for specifying
the serial parameters, i.e. “baud”, “bits”, etc.</p>
<p>asynInterposeEos and asynInterposeFlush can be used to provide additional functionality.</p>
</section>
<section id="tcp-ip-server">
<h3><a class="toc-backref" href="#id157" role="doc-backlink">TCP/IP Server</a><a class="headerlink" href="#tcp-ip-server" title="Link to this heading"></a></h3>
<p>The drvAsynIPServerPort driver supports asyn socket servers by listening for TCP/IP
or UDP connections from remote clients. The creates maxClients drvAsynIPPort port
drivers by calling drvAsynIPPortConfigure at initialization. These ports are named
portName:0, portName:1, etc. where portName is the name passed to drvAsynIPServerPortConfigure.</p>
<p>IP server listeners are configured with the <code class="docutils literal notranslate"><span class="pre">drvAsynIPServerPortConfigure</span></code>
command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">drvAsynIPServerPortConfigure</span><span class="p">(</span><span class="s2">&quot;portName&quot;</span><span class="p">,</span> <span class="s2">&quot;serverInfo&quot;</span><span class="p">,</span> <span class="n">maxClients</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="n">noAutoConnect</span><span class="p">,</span> <span class="n">noProcessEos</span><span class="p">);</span>
</pre></div>
</div>
<p>where the arguments are:</p>
<ul class="simple">
<li><p>portName</p>
<ul>
<li><p>The portName that is registered with asynManager.</p></li>
</ul>
</li>
<li><p>serverInfo</p>
<ul>
<li><p>The Internet host name and port number to listen for connections
on (e.g. “localhost:4002” for TCP, “localhost:4002 UDP” for UDP). This allows to
specify a host name or ip address for multi-homed machines. If you want to specify
<strong>*any*</strong> interface, use the example “localhost:port”, an empty host
“:port” or the any address “0.0.0.0:port”. The address has to
be an existing interface on the host. If the name cannot be resolved, the call will
complain and fail. If you need the loopback interface, use “127.0.0.1:port”.</p></li>
</ul>
</li>
<li><p>maxClients</p>
<ul>
<li><p>The maximum number of IP clients that can be simultaneously connected
on this port. Additional connect requests will fail.</p></li>
</ul>
</li>
<li><p>priority</p>
<ul>
<li><p>Priority at which the listener thread and any asyn I/O ports it creates
will run. If this is zero or missing, then epicsThreadPriorityMedium is used.</p></li>
</ul>
</li>
<li><p>noAutoConnect</p>
<ul>
<li><p>Zero or missing indicates that the listener port should automatically
connect. Non-zero if explicit connect command must be issued. Note that all asyn
I/O ports that the listener thread creates will be created with noAutoConnect=1,
but this is transparent to socket server applications, because the listener thread
does the explicit connection for them.</p></li>
</ul>
</li>
<li><p>noProcessEos is passed to drvAsynIPPortConfigure when new asyn I/O ports are created.
If 0 then asynInterposeEosConfig is called specifying both processEosIn and processEosOut.</p></li>
</ul>
<p>This driver implements the asynOctet interface. For TCP connections the only methods
it supports are registerInterruptUser and cancelInterruptUser. Calling the other
asynOctet methods will result in an error. For UDP it implements asynOctet-&gt;read().
The following happens when a new connection is received on the port specified in
drvAsynIPServerPortConfigure:</p>
<ul class="simple">
<li><p>The list of drvAsynIPPort ports that this listener thread has created is searched
to see if there is a drvAsynIPPort that is currently disconnected because there
is no remote IP client connected.</p></li>
<li><p>If there is a disconnected port, then it is connected with the file descriptor
from the new IP connection.</p></li>
<li><p>If there are no disconnected ports then the incoming connection will be immediately closed.</p></li>
<li><p>The asynTraceMask and asynTraceIOMask of the newly connected port are set to the
current values of the listener thread port. This makes it possible to trace the
early stages of execution of the callbacks to the registered clients, before one
could enable tracing at iocsh.</p></li>
<li><p>All registered asyn clients (who have called registerInterruptUser on the asynOctet
interface of the listener port) are called back with the name of the newly connected
port.</p></li>
</ul>
</section>
<section id="vxi-11">
<h3><a class="toc-backref" href="#id158" role="doc-backlink">VXI-11</a><a class="headerlink" href="#vxi-11" title="Link to this heading"></a></h3>
<p>VXI-11 is a TCP/IP protocol for communicating with IEEE 488.2 devices. It is an
RPC based protocol. In addition to the VXI-11 standard, three additional standards
are defined.</p>
<ul class="simple">
<li><p>VXI-11.1 - A standard for communicating with VXIbus devices. These controllers
have a vxiName that starts with “vxi” and can control multiple devices, i.e. the
port driver will be a multiaddress driver.</p></li>
<li><p>VXI-11.2 - A standard for communicating with a IEEE 488.1 device. This means that
the TCP/IP connection is talking to a GPIB controller that is talking to a GPIB
bus. These devices have an vxiName that starts with “gpib”. Note that the Agilent
E2050A does not follow the standard. For it the vxiName must be “hpib”</p></li>
<li><p>VXI-11.3 - A standard for communicating with IEEE 488.2 devices. This means that
the TCP/IP connection is talking directly with an device. These devices have an
vxiName that starts with “inst”. These controllers can control only a single device,
i.e. the port driver will be a single address driver</p></li>
</ul>
<p><em>NOTES</em></p>
<ul>
<li><p>No VXI-11.1 controller has been tested.</p></li>
<li><p>The following VXI-11.2 controllers have been tested: Agilent E2050 and E5810</p></li>
<li><p>The following VXI-11.3 instruments have been tested:</p>
<ul>
<li><p>Tektronix TDS3054B scope.</p>
<blockquote>
<div><p>SRQs do not work. Do not know why</p>
</div></blockquote>
</li>
<li><p>Tektronix TDS5054B scope.</p>
<blockquote>
<div><p>SRQs do work. The asynUser MUST specify addr = 0. Also do NOT set bit 0x40 of Service
Request Enable register, i.e. cause SRQ when device has output available. This did
not work and can cause infinite set of SRQs</p>
</div></blockquote>
</li>
</ul>
</li>
</ul>
<p>Consult the following documents (available on-line) for details.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">VMEbus</span> <span class="n">Extensions</span> <span class="k">for</span> <span class="n">Instrumentation</span>
<span class="n">VXI</span><span class="o">-</span><span class="mi">11</span>   <span class="n">TCP</span><span class="o">/</span><span class="n">IP</span> <span class="n">Instrument</span> <span class="n">Protocol</span> <span class="n">Specification</span>
<span class="n">VXI</span><span class="o">-</span><span class="mf">11.1</span> <span class="n">TCP</span><span class="o">/</span><span class="n">IP</span><span class="o">-</span><span class="n">VXIbus</span> <span class="n">Interface</span> <span class="n">Specification</span>
<span class="n">VXI</span><span class="o">-</span><span class="mf">11.2</span> <span class="n">TCP</span><span class="o">/</span><span class="n">IP</span><span class="o">-</span><span class="n">IEEE</span> <span class="mf">488.1</span> <span class="n">Interface</span> <span class="n">Specification</span>
<span class="n">VXI</span><span class="o">-</span><span class="mf">11.3</span> <span class="n">TCP</span><span class="o">/</span><span class="n">IP</span><span class="o">-</span><span class="n">IEEE</span> <span class="mf">488.2</span> <span class="n">Instrument</span> <span class="n">Interface</span> <span class="n">Specification</span>
</pre></div>
</div>
<p>The following commands may be specified in the st.cmd file</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">E2050Reboot</span><span class="p">(</span><span class="s2">&quot;inet_addr&quot;</span><span class="p">)</span>
<span class="n">E5810Reboot</span><span class="p">(</span><span class="s2">&quot;inet_addr&quot;</span><span class="p">,</span><span class="s2">&quot;password&quot;</span><span class="p">)</span>
<span class="n">vxi11Configure</span><span class="p">(</span><span class="s2">&quot;portName&quot;</span><span class="p">,</span><span class="s2">&quot;inet_addr&quot;</span><span class="p">,</span><span class="n">flags</span><span class="p">,</span><span class="s2">&quot;timeout&quot;</span><span class="p">,</span><span class="s2">&quot;vxiName&quot;</span><span class="p">,</span><span class="n">priority</span><span class="p">,</span><span class="n">noAutoConnect</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<ul>
<li><p>inet_addr - Internet Address</p></li>
<li><p>password - password. If given as 0 the default E5810 is used.</p></li>
<li><p>portName - The portName that is registered with asynGib.</p></li>
<li><p>flags - Bitmap</p>
<blockquote>
<div><ul class="simple">
<li><p>Bit 0 (0x1) recoverWithIFC - (0,1) =&gt; (don’t, do) issue IFC when error occurs.</p></li>
<li><p>Bit 1 (0x2) lockDevices - (0,1 ) =&gt; (don’t, do) lock devices when creating
the link.</p></li>
<li><p>Bit 2 (0x4) noSRQ - (0,1 ) =&gt; (do, don’t) set up a VXI-11 SRQ channel.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>timeout</p>
<ul class="simple">
<li><p>I/O operation timeout in seconds as a string. Prior to release R4-16
this was a double, but was changed to a string because it is not safe to pass doubles
on the vxWorks shell. If “0.0”, then a default is assigned.</p></li>
</ul>
</li>
<li><p>vxiName</p>
<ul class="simple">
<li><p>Must be chosen as specified above. NOTE: For the Agilent E2050 vxiName
must be “hpib”. For the Agilent E5810 use the name “gpib0”. For an instrument that
supports VXI11 try “inst0”.</p></li>
</ul>
</li>
<li><p>priority</p>
<ul class="simple">
<li><p>Priority at which the asyn I/O thread will run. If this is zero or
missing, then epicsThreadPriorityMedium is used.</p></li>
</ul>
</li>
<li><p>noAutoConnect</p>
<ul class="simple">
<li><p>Zero or missing indicates that portThread should automatically
connect. Non-zero if explicit connect command must be issued.</p></li>
</ul>
</li>
</ul>
<p>The vxi11 driver implements two timeouts: ioTimeout and rpcTimeout (Remote Procedure
Call timeout). The ioTimeout is taken from asynUser:timeout. The rpcTimeout is handled
internally for each port. It has a default of 4 seconds but can be changed by calling
setOptions. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asynSetOption</span> <span class="n">L0</span> <span class="o">-</span><span class="mi">1</span> <span class="n">rpctimeout</span> <span class="mf">.1</span>
</pre></div>
</div>
<p>Will change the rpcTimeout for port L0 to .1 seconds.</p>
</section>
<section id="drvprologixgpib">
<h3><a class="toc-backref" href="#id159" role="doc-backlink">drvPrologixGPIB</a><a class="headerlink" href="#drvprologixgpib" title="Link to this heading"></a></h3>
<p>The drvPrologixGPIB port driver was written to support
<a class="reference external" href="https://prologix.biz/gpib-ethernet-controller.html">the Prologix GPIB-Ethernet controller</a>.</p>
<p>Configuration command is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prologixGPIBConfigure</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">host</span><span class="p">,</span><span class="n">priority</span><span class="p">,</span><span class="n">noAutoConnect</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li><p>portName</p>
<ul>
<li><p>An ascii string specifying the port name that will be registered with
asynDriver.</p></li>
</ul>
</li>
<li><p>host</p>
<ul>
<li><p>The IP address or IP name and port number of the Prologix GPIB-Ethernet
controller. The port number is factory assigned to 1234.</p></li>
</ul>
</li>
<li><p>priority</p>
<ul>
<li><p>An integer specifying the priority of the port thread. A value of 0
will result in a default value being assigned.</p></li>
</ul>
</li>
<li><p>noAutoConnect</p>
<ul>
<li><p>Non-zero indicates that portThread should automatically connect.</p></li>
<li><p>Zero means explicit connect command must be issued.</p></li>
</ul>
</li>
</ul>
<p>An example is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prologixGPIBConfigure</span><span class="p">(</span><span class="s2">&quot;L0&quot;</span><span class="p">,</span><span class="s2">&quot;gse-prologix:1234&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>NOTES</strong>
The Prologix GPIB-Ethernet is a simple device that does not support many GPIB functions.</p>
<ul class="simple">
<li><p>SRQ is not supported.</p></li>
<li><p>SerialPoll is not supported.</p></li>
<li><p>AddressedCMD is not supported.</p></li>
<li><p>UniversalCMD is not supported.</p></li>
<li><p>REN (remote enable) is not supported.</p></li>
</ul>
</section>
<section id="linux-gpib">
<h3><a class="toc-backref" href="#id160" role="doc-backlink">Linux-Gpib</a><a class="headerlink" href="#linux-gpib" title="Link to this heading"></a></h3>
<p>The linux-gpib port driver was written to support
<a class="reference external" href="https://sourceforge.net/projects/linux-gpib/">the Linux GPIB Package library</a>.</p>
<p>In order to build this support the Linux GPIB Package must be installed. Also in
configure/RELEASE the statement:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LINUX_GPIB</span><span class="o">=</span><span class="n">NO</span>
</pre></div>
</div>
<p>must be changed to</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LINUX_GPIB</span><span class="o">=</span><span class="n">YES</span>
</pre></div>
</div>
<p>Configuration command is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">GpibBoardDriverConfig</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">autoConnect</span><span class="p">,</span><span class="n">BoardIndex</span><span class="p">,</span><span class="n">timeout</span><span class="p">,</span><span class="n">priority</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li><p>portName</p>
<ul>
<li><p>An ascii string specifying the port name that will be registered with
asynDriver.</p></li>
</ul>
</li>
<li><p>noAutoConnect</p>
<ul>
<li><p>Non-zero indicates that portThread should automatically connect.</p></li>
<li><p>Zero means explicit connect command must be issued.</p></li>
</ul>
</li>
<li><p>boardIndex</p>
<ul>
<li><p>Integer containing index of board (0 means /dev/gpib0). Normally it
is 0. This must be the same as in gpib.conf file (minor number - board index) of
driver configuration.</p></li>
</ul>
</li>
<li><p>timeout</p>
<ul>
<li><p>Time in seconds in which an i/o operation must complete. Zero means
disabled. This is “general” timeout for every call to low level drivers. For actual
read/write operations timeout must be defined in device support. Both timeouts are
converted into integers 0-17 which represents disabled to 1000 seconds.</p></li>
</ul>
</li>
<li><p>priority</p>
<ul>
<li><p>An integer specifying the priority of the port thread. A value of 0
will result in a default value being assigned.</p></li>
</ul>
</li>
</ul>
<p>An example is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">GpibBoardDriverConfig</span><span class="p">(</span><span class="s2">&quot;L0&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>NOTES:</strong></p>
<ul class="simple">
<li><p>AsynOption Interface is supported. Key (hexadecimal) and val (integer) arguments
to setPortOptions function must be appropriate values represented as character arrays.
See GPIB library documentation for details.</p></li>
<li><p>pgpibCmd type GPIBREADW and GPIBEFASTIW were not tested.</p></li>
<li><p>The linux-port driver was tested with PC104-GPIB board from Measurement Computing.</p></li>
</ul>
</section>
<section id="green-springs-ip488">
<h3><a class="toc-backref" href="#id161" role="doc-backlink">Green Springs IP488</a><a class="headerlink" href="#green-springs-ip488" title="Link to this heading"></a></h3>
<p>This is support for the Green Springs Industry Pack GPIB carrier. The configuration
command is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gsIP488Configure</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">carrier</span><span class="p">,</span><span class="n">module</span><span class="p">,</span><span class="n">intVec</span><span class="p">,</span><span class="n">priority</span><span class="p">,</span><span class="n">noAutoConnect</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li><p>portName</p>
<ul>
<li><p>An ascii string specifying the port name that will be registered with
asynDriver.</p></li>
</ul>
</li>
<li><p>carrier</p>
<ul>
<li><p>An integer identifying the Industry Pack Carrier</p></li>
</ul>
</li>
<li><p>module</p>
<ul>
<li><p>An integer identifying the module on the carrier</p></li>
</ul>
</li>
<li><p>intVec</p>
<ul>
<li><p>An integer specifying the interrupt vector</p></li>
</ul>
</li>
<li><p>priority</p>
<ul>
<li><p>An integer specifying the priority of the portThread. A value of 0
will result in a defalt value being assigned</p></li>
</ul>
</li>
<li><p>noAutoConnect</p>
<ul>
<li><p>Zero or missing indicates that portThread should automatically connect.</p></li>
<li><p>Non-zero if explicit connect command must be issued.</p></li>
</ul>
</li>
</ul>
<p>An example is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#The following is for the Greensprings IP488 on an MV162</span>
<span class="n">ipacAddMVME162</span><span class="p">(</span><span class="s2">&quot;A:l=3,3 m=0xe0000000,64&quot;</span><span class="p">)</span>
<span class="n">gsIP488Configure</span><span class="p">(</span><span class="s2">&quot;L0&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mh">0x61</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>WARNING:</strong></p>
<p>This module includes code that implement a 6 microsecond delay because the gpib
interface chip requires it. The first time gsIP488Configure is executed code is
run to determine a variable used by the delay routine. It assumes that there is
no higher priority thread running that consumes lots of cpu cycles.</p>
</section>
<section id="national-instruments-gpib-1014d">
<h3><a class="toc-backref" href="#id162" role="doc-backlink">National Instruments GPIB-1014D</a><a class="headerlink" href="#national-instruments-gpib-1014d" title="Link to this heading"></a></h3>
<p>This is support for a National Instruments VME GPIB interface. The configuration
command is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ni1014Config</span><span class="p">(</span><span class="n">portNameA</span><span class="p">,</span><span class="n">portNameB</span><span class="p">,</span><span class="n">base</span><span class="p">,</span><span class="n">vector</span><span class="p">,</span><span class="n">level</span><span class="p">,</span><span class="n">priority</span><span class="p">,</span><span class="n">noAutoConnect</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li><p>portNameA</p>
<ul>
<li><p>An ascii string specifying the port name that will be registered with
asynDriver for portA.</p></li>
</ul>
</li>
<li><p>portNameB</p>
<ul>
<li><p>An ascii string specifying the port name that will be registered with
asynDriver for portB. If only one port should be registered, then leave this as
a null string. The support should also work for a single port NI1014 but has not
been tested.</p></li>
</ul>
</li>
<li><p>base</p>
<ul>
<li><p>VME A16 base address.</p></li>
</ul>
</li>
<li><p>vector</p>
<ul>
<li><p>VME interrupt vector.</p></li>
</ul>
</li>
<li><p>level</p>
<ul>
<li><p>An integer specifying the interrupt level.</p></li>
</ul>
</li>
<li><p>priority</p>
<ul>
<li><p>In integer specifying the priority of the portThread. A value of 0
will result in a defalt value being assigned</p></li>
</ul>
</li>
<li><p>noAutoConnect</p>
<ul>
<li><p>Zero or missing indicates that portThread should automatically
connect. Non-zero if explicit connect command must be issued.</p></li>
</ul>
</li>
</ul>
<p>An example is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ni1014Config</span><span class="p">(</span><span class="s2">&quot;L0&quot;</span><span class="p">,</span><span class="s2">&quot;L1&quot;</span><span class="p">,</span><span class="mh">0x5000</span><span class="p">,</span><span class="mh">0x64</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>NOTES:</strong></p>
<ul class="simple">
<li><p>Ports A and B are almost but not quite the same. Thus the code for connecting
to port A is slightly different than the code for portB.</p></li>
<li><p>In order to disconnect and reconnect either port, BOTH ports must be disconnected
and reconnected.</p></li>
<li><p>When the ports are connected, portA MUST be connected before port B.</p></li>
<li><p>Programmed I/O, via interrupts, rather than DMA is implemented. Thus no A24 address
space is required.</p></li>
</ul>
<p><strong>WARNING:</strong></p>
<p>This module includes code that implement a 6 microsecond delay because the gpib
interface chip requires it. The first time ni1014Config is executed code is run
to determine a variable used by the delay routine. It assumes that there is no higher
priority thread running that consumes lots of cpu cycles.</p>
</section>
<section id="usb-tmc-test-and-measurement-class-driver">
<h3><a class="toc-backref" href="#id163" role="doc-backlink">USB TMC (Test and Measurement Class) driver</a><a class="headerlink" href="#usb-tmc-test-and-measurement-class-driver" title="Link to this heading"></a></h3>
<p>Configure each instance of the driver in the application startup script:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">usbtmcConfigure</span><span class="p">(</span><span class="s2">&quot;asynPort&quot;</span><span class="p">,</span> <span class="n">vendorId</span><span class="p">,</span> <span class="n">productId</span><span class="p">,</span> <span class="s2">&quot;serialNumber&quot;</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">asynPort</span></code> and <code class="docutils literal notranslate"><span class="pre">serialNumber</span></code> arguments are strings and the other
arguments are integers. A missing or 0 <code class="docutils literal notranslate"><span class="pre">vendorId</span></code> or <code class="docutils literal notranslate"><span class="pre">productId</span></code> matches
any value and a missing or empty <code class="docutils literal notranslate"><span class="pre">serialNumber</span></code> string matches any value.
Thus the command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">usbtmcConfigure</span><span class="p">(</span><span class="s2">&quot;usbtmc1&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>will associate ASYN port usbtmc1 with the first USB TMC device discovered. A missing
or 0 priority will set the worker thread priority to its default value of 50 (<code class="docutils literal notranslate"><span class="pre">epicsThreadPriorityMedium</span></code>).</p>
<p>A missing flags argument is taken to be 0. As of now only one bit is used: Bit 0
(0x1) Disable/enable (1/0) automatic port connection.</p>
<section id="non-octet-records">
<h4><a class="toc-backref" href="#id164" role="doc-backlink">Non-octet records</a><a class="headerlink" href="#non-octet-records" title="Link to this heading"></a></h4>
<p>In addition to the asynOctet stream this support module provides some values for
records with DTYP=asynInt32. Since the port is a single-address device the subaddress
field of the INP or OUT ‘&#64;asyn()’ descriptor can not be used. Instead the ‘drvUser’
string at the end of the INP or OUT field is used to distinguish the parameter to
be read or written.</p>
</section>
<section id="service-request-srq-handling">
<h4><a class="toc-backref" href="#id165" role="doc-backlink">Service Request (SRQ) handling</a><a class="headerlink" href="#service-request-srq-handling" title="Link to this heading"></a></h4>
<p>The presence of one or more records with INP=”&#64;asyn(port, 0, 0) SRQ”) will cause
the driver to create an extra thread to read from the device Interrupt-In endpoint.
The SCAN field must be “I/O Intr”. Record processing will occur when the device
sends a service request message on the Interrupt-In endpoint and the value will
be the device status byte sent as part of the service request message. Typically
the record type will be longin or mbbiDirect.</p>
</section>
<section id="device-status-byte-stb">
<h4><a class="toc-backref" href="#id166" role="doc-backlink">Device Status Byte (STB)</a><a class="headerlink" href="#device-status-byte-stb" title="Link to this heading"></a></h4>
<p>The USBTMC/USB488 device status byte is read by a record with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INP</span><span class="o">=</span><span class="s2">&quot;@asyn(port, 0, 0) STB&quot;</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>Typically the record type will be longin or mbbiDirect.</p>
</section>
<section id="remote-enable-ren">
<h4><a class="toc-backref" href="#id167" role="doc-backlink">Remote Enable (REN)</a><a class="headerlink" href="#remote-enable-ren" title="Link to this heading"></a></h4>
<p>The device remote enable is written by a record with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OUT</span><span class="o">=</span><span class="s2">&quot;@asyn(port, 0, 0) REN&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Typically the record type will be bo but writing any non-zero value enables remote
operation.</p>
</section>
<section id="local-lockout-llo">
<h4><a class="toc-backref" href="#id168" role="doc-backlink">Local Lockout (LLO)</a><a class="headerlink" href="#local-lockout-llo" title="Link to this heading"></a></h4>
<p>The IEEE-488 local lockout command is sent by processing a record with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OUT</span><span class="o">=</span><span class="s2">&quot;@asyn(port, 0, 0) LLO&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Typically the record type will be bo. The value written is ignored.</p>
</section>
<section id="go-to-local-gtl">
<h4><a class="toc-backref" href="#id169" role="doc-backlink">Go To Local (GTL)</a><a class="headerlink" href="#go-to-local-gtl" title="Link to this heading"></a></h4>
<p>The IEEE-488 go to local command is sent by processing a record with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OUT</span><span class="o">=</span><span class="s2">&quot;@asyn(port, 0, 0) GTL&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Typically the record type will be bo. The value written is ignored.</p>
</section>
<section id="linux-udev-configuration">
<h4><a class="toc-backref" href="#id170" role="doc-backlink">Linux udev configuration</a><a class="headerlink" href="#linux-udev-configuration" title="Link to this heading"></a></h4>
<p>If attempts to communicate with a device result in error messages of the form “Access
denied (insufficient permissions)” you must add udev entries to allow access. In
the /etc/udev/rules.d directory create a file, 55-usbtmc.rules for example, with
a line for each device of interest.</p>
<p>To allow everyone in the “usbtmc” group access to a device with vendor code 1BFA
(hexadecimal) and product code 0498 (hexadecimal) the line would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SUBSYSTEM</span><span class="o">==</span><span class="s2">&quot;usb&quot;</span><span class="p">,</span> <span class="n">ATTRS</span><span class="p">{</span><span class="n">idVendor</span><span class="p">}</span><span class="o">==</span><span class="s2">&quot;1BFA&quot;</span><span class="p">,</span> <span class="n">ATTRS</span><span class="p">{</span><span class="n">idProduct</span><span class="p">}</span><span class="o">==</span><span class="s2">&quot;0498&quot;</span><span class="p">,</span> <span class="n">GROUP</span><span class="o">=</span><span class="s2">&quot;usbtmc&quot;</span><span class="p">,</span> <span class="n">MODE</span><span class="o">=</span><span class="s2">&quot;0660&quot;</span>
</pre></div>
</div>
<p>To allow everyone access the line would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SUBSYSTEM</span><span class="o">==</span><span class="s2">&quot;usb&quot;</span><span class="p">,</span> <span class="n">ATTRS</span><span class="p">{</span><span class="n">idVendor</span><span class="p">}</span><span class="o">==</span><span class="s2">&quot;1BFA&quot;</span><span class="p">,</span> <span class="n">ATTRS</span><span class="p">{</span><span class="n">idProduct</span><span class="p">}</span><span class="o">==</span><span class="s2">&quot;0498&quot;</span><span class="p">,</span> <span class="n">MODE</span><span class="o">=</span><span class="s2">&quot;0666&quot;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">{idVendor}</span></code> and <code class="docutils literal notranslate"><span class="pre">{idProduct}</span></code> values must match those of the
device with which you wish to communicate.</p>
</section>
<section id="streamdevice-exception-handlers">
<h4><a class="toc-backref" href="#id171" role="doc-backlink">StreamDevice Exception Handlers</a><a class="headerlink" href="#streamdevice-exception-handlers" title="Link to this heading"></a></h4>
<p>The USBTMC driver attempts to take correct action when it detects that the device
has been unplugged or become unresponsive. The effectiveness of this depends somewhat
on the level of support provided by the underlying operating system so it is good
practice to also specify the following StreamDevice global exception handlers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@mismatch</span> <span class="p">{</span> <span class="n">disconnect</span><span class="p">;</span> <span class="p">}</span>
<span class="nd">@writetimeout</span> <span class="p">{</span> <span class="n">disconnect</span><span class="p">;</span> <span class="p">}</span>
<span class="nd">@readtimeout</span> <span class="p">{</span> <span class="n">disconnect</span><span class="p">;</span> <span class="p">}</span>
<span class="nd">@replyTimeout</span> <span class="p">{</span> <span class="n">disconnect</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="ftdi-port">
<h3><a class="toc-backref" href="#id172" role="doc-backlink">FTDI Port</a><a class="headerlink" href="#ftdi-port" title="Link to this heading"></a></h3>
<p>The drvAsynFTDIPort driver supports devices connected via FTDI adapters.</p>
<p>FTDI ports are configured with the <code class="docutils literal notranslate"><span class="pre">drvAsynFTDIPortConfigure</span></code> and <code class="docutils literal notranslate"><span class="pre">asynSetOption</span></code>
commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">drvAsynFTDIPortConfigure</span><span class="p">(</span><span class="s2">&quot;portName&quot;</span><span class="p">,</span><span class="n">vendor</span><span class="p">,</span><span class="n">product</span><span class="p">,</span><span class="n">baudrate</span><span class="p">,</span><span class="n">latency</span><span class="p">,</span><span class="n">priority</span><span class="p">,</span><span class="n">noAutoConnect</span><span class="p">,</span><span class="n">noProcessEos</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
<span class="n">asynSetOption</span><span class="p">(</span><span class="s2">&quot;portName&quot;</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="s2">&quot;key&quot;</span><span class="p">,</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>where the arguments are:</p>
<ul class="simple">
<li><p>portName</p>
<ul>
<li><p>The portName that is registered with asyn.</p></li>
</ul>
</li>
<li><p>vendor</p>
<ul>
<li><p>The USB vendor number associated with the FTDI device.</p></li>
</ul>
</li>
<li><p>product</p>
<ul>
<li><p>The USB product number associated with the FTDI device.</p></li>
</ul>
</li>
<li><p>baudrate</p>
<ul>
<li><p>The baudrate to be used with the FTDI device.</p></li>
</ul>
</li>
<li><p>latency</p>
<ul>
<li><p>The latency timer after which non-full FTDI buffers are sent.</p></li>
</ul>
</li>
<li><p>priority</p>
<ul>
<li><p>Priority at which the asyn I/O thread will run. If this is zero or
missing,then epicsThreadPriorityMedium is used.</p></li>
</ul>
</li>
<li><p>noAutoConnect</p>
<ul>
<li><p>Zero or missing indicates that portThread should automatically connect.</p></li>
<li><p>Non-zero if explicit connect command must be issued.</p></li>
</ul>
</li>
<li><p>noProcessEos</p>
<ul>
<li><p>If 0 then asynInterposeEosConfig is called specifying both processEosIn
and processEosOut.</p></li>
</ul>
</li>
<li><p>mode:</p>
<ul>
<li><p>0 = UART;</p></li>
<li><p>1 = FTDI initialized in binary SPI mode.</p></li>
</ul>
</li>
</ul>
<p>The setEos and getEos methods have no effect and return asynError. The read method
blocks until at least one character has been received or until a timeout occurs.
The read method transfers as many characters as possible, limited by the specified
count. asynInterposeEos can be used to support EOS.</p>
<p>The following table summarizes the drvAsynFTDIPort driver asynSetOption keys and
values. Reasonable defaults are used at first.</p>
<table class="docutils align-default" id="id48">
<caption><span class="caption-text">FTDI driver</span><a class="headerlink" href="#id48" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Note</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>baud</p></td>
<td><p>50 75 110 134 150 200 300 600 1200 2400 9600 …</p></td>
<td><p>Any numeric value. Check chip datasheet for actual supported baud rates.</p></td>
</tr>
<tr class="row-odd"><td><p>bits</p></td>
<td><p>8 7</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>parity</p></td>
<td><p>none even odd mark space</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>stop</p></td>
<td><p>1 1.5 2</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>break</p></td>
<td><p>off on</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>flow</p></td>
<td><p>rts_cts dtr_dsr xon_xoff</p></td>
<td><p>Values can be OR’ed together, e.g., <code class="docutils literal notranslate"><span class="pre">rts_cts|dtr_dsr</span></code></p></td>
</tr>
</tbody>
</table>
<p>The FTDI SPI interface was developed for control of evaluation board, EVAL-AD9915,
via Adafruit FT232H. During initial SPI learning it is sufficient to short circuit,
(loop-back), FTDI D1(MOSI) - D2(MISO) pins and read back written values. (Note the
SPI is synchronous interface, not asynchronous.)</p>
<p>AD9915 provides basic control for RF amplitude and phase. In order to use the Adafruit
as USB - SPI converter for EVAL-AD9915 the following pins need to be connected:</p>
<table class="docutils align-default" id="id49">
<caption><span class="caption-text">Adafruit FT232H EVAL-AD9915 connections</span><a class="headerlink" href="#id49" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Adafruit FT232H</p></th>
<th class="head"><p>EVAL-AD9915</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>D0 (SPI Clock, SK)</p></td>
<td><p>SCLK-BUF</p></td>
</tr>
<tr class="row-odd"><td><p>D1 (Data Out, MOSI)</p></td>
<td><p>SDIO</p></td>
</tr>
<tr class="row-even"><td><p>D2 (Data In, MISO)</p></td>
<td><p>SDO</p></td>
</tr>
<tr class="row-odd"><td><p>D3 (Chip Select, CS)</p></td>
<td><p>CSB</p></td>
</tr>
<tr class="row-even"><td><p>D4</p></td>
<td><p>IOUPDATE-BUF</p></td>
</tr>
<tr class="row-odd"><td><p>D5</p></td>
<td><p>SYNC_IO</p></td>
</tr>
<tr class="row-even"><td><p>D6</p></td>
<td><p>RESET</p></td>
</tr>
</tbody>
</table>
<p>On EVAL-AD9915 board:</p>
<ol class="arabic simple">
<li><p>The on-board USB-SPI converter, (lacking open source driver),
should be disabled by jumpers P203-P205.</p></li>
<li><p>The following jumpers need to be configured:
EXTPDCTL=GND; PS0-BUF=GND; PS1-BUF=GND; PS2-BUF=GND; IOCFG=+5V; IOCFG1…3=GND.</p></li>
</ol>
<p>The FTDI SPI driver supports raw 32-bit integer reads/writes. MPSSE instruction
codes, pin controls, data lengths are currently hard coded in the stream protocol:
(WRite Digital Output, WRite PIN, ReaD Digital Input):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>WRDO {
# MPSSE_DO_WRITE | MPSSE_WRITE_NEG | MPSSE_DO_READ = 0x31
# Length = 0x04 bytes after the instruction code and 2 length bytes:
out 0x31 0x04 0x00 $1 &quot;%.4r&quot;;
}

WRPIN {
# SK = 0x01
# DO = 0x02
# DI = 0x04
# CS = 0x08
# IO_UPD = 0x10
# SYNCIO = 0x20
# RESET  = 0x40
# PINDIR = 0x7B
# SET_BITS_LOW = 0x80
out 0x80 &quot;%r&quot; 0x7B;
}

RDDI {
# MPSSE_DO_WRITE | MPSSE_WRITE_NEG | MPSSE_DO_READ = 0x31
# Length = 0x04 bytes after the instruction code and 2 length bytes:
# Input is clocked in while the 0 bytes are clocked out:
out 0x31 0x04 0x00 $1 0x00 0x00 0x00 0x00;
in &quot;%5r&quot;;
}
</pre></div>
</div>
<p>The sequences are controlled by EPICS database. For further details refer to the
respective technical manuals.</p>
</section>
</section>
<section id="asynportdriver-c-base-class">
<h2><a class="toc-backref" href="#id173" role="doc-backlink">asynPortDriver C++ base class</a><a class="headerlink" href="#asynportdriver-c-base-class" title="Link to this heading"></a></h2>
<p>A C++ base class called asynPortDriver is available. This is a base class from which
real asyn port drivers can be derived. It greatly simplifies the job of writing
an asyn port driver, because it takes care of all of the tasks like registering
the port, registering the interfaces, and calling interrupt clients. It is documented
separately in <a class="reference external" href="asynPortDriver.html">asynPortDriver</a>.</p>
</section>
<section id="asynportclient-c-classes">
<h2><a class="toc-backref" href="#id174" role="doc-backlink">asynPortClient C++ classes</a><a class="headerlink" href="#asynportclient-c-classes" title="Link to this heading"></a></h2>
<p>asynPortClient is a set of C++ classes that are designed to simplify the task of
writing a client that directly communicates with an asyn port driver, without running
an EPICS IOC. They handle the details of connecting to the driver, finding the required
interfaces, etc. They only uses the synchronous interfaces, so all calls are blocking.
If clients need asynchronous operation then they can use the normal C interface
with pasynManager-&gt;queueRequest. It is documented separately in <a class="reference external" href="asynPortClient.html">asynPortClient</a>.</p>
</section>
<section id="diagnostic-aids">
<h2><a class="toc-backref" href="#id175" role="doc-backlink">Diagnostic Aids</a><a class="headerlink" href="#diagnostic-aids" title="Link to this heading"></a></h2>
<section id="iocsh-commands">
<h3><a class="toc-backref" href="#id176" role="doc-backlink">iocsh Commands</a><a class="headerlink" href="#iocsh-commands" title="Link to this heading"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asynReport</span><span class="p">(</span><span class="n">level</span><span class="p">,</span><span class="n">portName</span><span class="p">)</span>
<span class="n">asynInterposeFlushConfig</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">timeout</span><span class="p">)</span>
<span class="n">asynInterposeEosConfig</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">processIn</span><span class="p">,</span><span class="n">processOut</span><span class="p">)</span>
<span class="n">asynSetTraceMask</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span>
<span class="n">asynSetTraceIOMask</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span>
<span class="n">asynSetTraceInfoMask</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span>
<span class="n">asynSetTraceFile</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">filename</span><span class="p">)</span>
<span class="n">asynSetTraceIOTruncateSize</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">size</span><span class="p">)</span>
<span class="n">asynSetOption</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">)</span>
<span class="n">asynShowOption</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">key</span><span class="p">)</span>
<span class="n">asynAutoConnect</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">yesNo</span><span class="p">)</span>
<span class="n">asynSetAutoConnectTimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
<span class="n">asynWaitConnect</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
<span class="n">asynEnable</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">yesNo</span><span class="p">)</span>
<span class="n">asynOctetConnect</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">timeout</span><span class="p">,</span><span class="n">buffer_len</span><span class="p">,</span><span class="n">drvInfo</span><span class="p">)</span>
<span class="n">asynOctetRead</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span><span class="n">nread</span><span class="p">)</span>
<span class="n">asynOctetWrite</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>
<span class="n">asynOctetWriteRead</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span><span class="n">output</span><span class="p">,</span><span class="n">nread</span><span class="p">)</span>
<span class="n">asynOctetFlush</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
<span class="n">asynOctetSetInputEos</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">eos</span><span class="p">,</span><span class="n">drvInfo</span><span class="p">)</span>
<span class="n">asynOctetGetInputEos</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">drvInfo</span><span class="p">)</span>
<span class="n">asynOctetSetOutputEos</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">eos</span><span class="p">,</span><span class="n">drvInfo</span><span class="p">)</span>
<span class="n">asynOctetGetOutputEos</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">addr</span><span class="p">,</span><span class="n">drvInfo</span><span class="p">)</span>
<span class="n">asynRegisterTimeStampSource</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">functionName</span><span class="p">);</span>
<span class="n">asynUnregisterTimeStampSource</span><span class="p">(</span><span class="n">portName</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">asynReport</span></code> calls <code class="docutils literal notranslate"><span class="pre">asynCommon:report</span></code> for a specific port
if portName is specified, or for all registered drivers and interposeInterface if
portName is not specified.</p>
<p><code class="docutils literal notranslate"><span class="pre">asynInterposeFlushConfig</span></code> is a generic interposeInterface that implements
flush for low level drivers that don’t implement flush. It just issues read requests
until no bytes are left to read. The timeout is used for the read requests.</p>
<p><code class="docutils literal notranslate"><span class="pre">asynInterposeEosConfig</span></code> is a generic interposeInterface that implements
End of String processing for low level drivers that don’t.</p>
<p><code class="docutils literal notranslate"><span class="pre">asynSetTraceMask</span></code> calls <code class="docutils literal notranslate"><span class="pre">asynTrace:setTraceMask</span></code> for the
specified port and address. If portName is zero length then the global trace mask
is set. The mask bit definitions are documented in the
<a class="reference external" href="#asyntrace">traceMask definitions</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">asynSetTraceIOMask</span></code> calls <code class="docutils literal notranslate"><span class="pre">asynTrace:setTraceIOMask</span></code> for
the specified port and address. If portName is zero length then the global traceIO
mask is set. The mask bit definitions are documented in the
<a class="reference external" href="#asyntrace">traceIO mask definitions</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">asynSetTraceInfoMask</span></code> calls <code class="docutils literal notranslate"><span class="pre">asynTrace:setTraceInfoMask</span></code>
for the specified port and address. If portName is zero length then the global traceInfo
mask is set. The mask bit definitions are documented in the
<a class="reference external" href="#asyntrace">traceInfo mask definitions</a>.</p>
<p>Beginning with asyn R4-35 the mask argument of asynSetTraceMask, asynSetTraceIOMask,
and asynSetTraceInfoMask can be specified either as an integer (previous behavior)
or as symbolic names connected with + or |. Spaces are allowed but require quotes.
The symbolic names are like the macro names in asyn.h, but are not case sensitive
and the prefixes ASYN_, TRACE_, TRACEIO_, and TRACEINFO_ are optional. Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asynSetTraceMask</span> <span class="n">port</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">ASYN_TRACE_ERROR</span>
<span class="n">asynSetTraceIOMask</span> <span class="n">port</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">ascii</span><span class="o">+</span><span class="n">escape</span>
<span class="n">asynSetTraceInfoMask</span> <span class="n">port</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">+</span><span class="n">port</span><span class="o">+</span><span class="n">TRACEINFO_SOURCE</span><span class="o">|</span><span class="n">ASYN_TRACEINFO_THREAD</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">asynSetTraceFile</span></code> calls <code class="docutils literal notranslate"><span class="pre">asynTrace:setTraceFile</span></code>. The filename
is handled as follows:</p>
<ul class="simple">
<li><p>Not specified - A NULL pointer is passed to setTraceFile. Subsequent messages
are sent to errlog.</p></li>
<li><p>An empty string (“”) or “stderr” - stderr is passed to setTraceFile.</p></li>
<li><p>“stdout” - stdout is passed to setTraceFile.</p></li>
<li><p>Any other string - The specified file is opened with an option of “w” and the
file pointer is passed to setTraceFile.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">asynSetTraceIOTruncateSize</span></code> calls <code class="docutils literal notranslate"><span class="pre">asynTrace:setTraceIOTruncateSize</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">asynSetOption</span></code> calls <code class="docutils literal notranslate"><span class="pre">asynCommon:setOption</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">asynShowOption</span></code> calls <code class="docutils literal notranslate"><span class="pre">asynCommon:getOption</span></code>.</p>
<p>The asynOctetXXX commands provide shell access to asynOctetSyncIO methods. The entry
is a character string constant that identifies the port,addr.</p>
<p>The other arguments are as follows:</p>
<table class="docutils align-default" id="id50">
<caption><span class="caption-text">asynOctetXXX command arguments</span><a class="headerlink" href="#id50" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Argument name</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>filename</p></td>
<td><p>An ascii string naming a file. If null or a null string, then the output
is sent to <code class="docutils literal notranslate"><span class="pre">stdout.</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>level</p></td>
<td><p>The report level.</p></td>
</tr>
<tr class="row-even"><td><p>portName</p></td>
<td><p>An ascii string specifying the portName of the driver.</p></td>
</tr>
<tr class="row-odd"><td><p>addr</p></td>
<td><p>An integer specifying the address of the device. For multiDevice ports
a value of -1 means the port itself. For ports that support a single device, addr
is ignored.</p></td>
</tr>
<tr class="row-even"><td><p>mask</p></td>
<td><p>The mask value to set. See the mask bit definitions in asynDriver.h</p></td>
</tr>
<tr class="row-odd"><td><p>key</p></td>
<td><p>The key for the option desired.</p></td>
</tr>
<tr class="row-even"><td><p>val</p></td>
<td><p>The value for the option.</p></td>
</tr>
<tr class="row-odd"><td><p>yesNo</p></td>
<td><p>The value (0,1) means (no,yes).</p></td>
</tr>
<tr class="row-even"><td><p>entry</p></td>
<td><p>A character string that identifies the asynOctetConnect request.</p></td>
</tr>
<tr class="row-odd"><td><p>timeout</p></td>
<td><p>timeout as an integer in milliseconds. The default is 1.</p></td>
</tr>
<tr class="row-even"><td><p>buffer_len</p></td>
<td><p>length of buffer for I/O. Default=160. NOTE: output strings passed
to asynOctetWrite can have escape characters. The buffer_len must be large enough
to handle escape characters. For example if x02 appears in an output string it
counts as four characters.</p></td>
</tr>
<tr class="row-odd"><td><p>drvInfo</p></td>
<td><p>A string to pass to the driver via interface asynDrvUser.</p></td>
</tr>
<tr class="row-even"><td><p>nread</p></td>
<td><p>max number of bytes to read. Default=buffer_len.</p></td>
</tr>
<tr class="row-odd"><td><p>flush</p></td>
<td><p>(0,1) means (don’t, do) flush before reading. Default=0.</p></td>
</tr>
<tr class="row-even"><td><p>output</p></td>
<td><p>output string.</p></td>
</tr>
</tbody>
</table>
<p>The commands asynOctetConnect, asynOctetDisconnect, asynOctetRead, asynOctetWrite,
asynOctetWriteRead, asynOctetFlush allow I/O to a device from the ioc shell. Examples
are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">asynOctetConnect</span><span class="p">(</span><span class="s2">&quot;myid&quot;</span><span class="p">,</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
<span class="n">asynOctetWrite</span><span class="p">(</span><span class="s2">&quot;myid&quot;</span><span class="p">,</span><span class="s2">&quot;testnew&quot;</span><span class="p">)</span>
<span class="n">asynOctetRead</span><span class="p">(</span><span class="s2">&quot;myid&quot;</span><span class="p">)</span>
<span class="n">testnew</span>\<span class="n">n</span>
<span class="n">asynOctetWriteRead</span><span class="p">(</span><span class="s2">&quot;myid&quot;</span><span class="p">,</span><span class="s2">&quot;this is test&quot;</span><span class="p">)</span>
<span class="n">this</span> <span class="ow">is</span> <span class="n">test</span>\<span class="n">n</span>
<span class="n">asynOctetDisconnect</span><span class="p">(</span><span class="s2">&quot;myid&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">asynRegisterTimeStampSource</span></code> calls <code class="docutils literal notranslate"><span class="pre">pasynManager-&gt;registerTimeStampSource</span></code>
for the specified port. The time stamp source function must be defined as a “function”
in the application dbd file.</p>
<p><code class="docutils literal notranslate"><span class="pre">asynUnregisterTimeStampSource</span></code> calls <code class="docutils literal notranslate"><span class="pre">pasynManager-&gt;runegisterTimeStampSource</span></code>
for the specified port. This reverts to the default timestamp source function in
asynManager.</p>
</section>
</section>
<section id="example-client">
<h2><a class="toc-backref" href="#id177" role="doc-backlink">Example Client</a><a class="headerlink" href="#example-client" title="Link to this heading"></a></h2>
<p>The following is an example of an asyn client that reads from an asyn driver via
octet messages:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#include &lt;asynDriver.h&gt;
...
#define BUFFER_SIZE 80
typedef struct myData {
    epicsEventId done;
    asynOctet    *pasynOctet;
    void         *drvPvt;
    char         buffer[BUFFER_SIZE];
}myData;

static void queueCallback(asynUser *pasynUser) {
    myData     *pmydata = (myData *)pasynUser-&gt;userPvt;
    asynOctet  *pasynOctet = pmydata-&gt;pasynOctet;
    void       *drvPvt = pmydata-&gt;drvPvt;
    asynStatus status;
    int        writeBytes,readBytes;
    int        eomReason;

    asynPrint(pasynUser,ASYN_TRACE_FLOW,&quot;queueCallback entered\n&quot;);
    status = pasynOctet-&gt;write(drvPvt,pasynUser,pmydata-&gt;buffer,
              strlen(pmydata-&gt;buffer),&amp;amp;writeBytes);
    if(status!=asynSuccess) {
        asynPrint(pasynUser,ASYN_TRACE_ERROR,
            &quot;queueCallback write failed %s\n&quot;,pasynUser-&gt;errorMessage);
    } else {
        asynPrintIO(pasynUser,ASYN_TRACEIO_DEVICE,
            pmydata-&gt;buffer,strlen(pmydata-&gt;buffer),
            &quot;queueCallback write sent %d bytes\n&quot;,writeBytes);
    }
    status = pasynOctet-&gt;read(drvPvt,pasynUser,pmydata-&gt;buffer,
         BUFFER_SIZE,&amp;amp;readBytes,&amp;amp;eomReason);
    if(status!=asynSuccess) {
        asynPrint(pasynUser,ASYN_TRACE_ERROR,
            &quot;queueCallback read failed %s\n&quot;,pasynUser-&gt;errorMessage);
    } else {
        asynPrintIO(pasynUser,ASYN_TRACEIO_DEVICE,
            pmydata-&gt;buffer,BUFFER_SIZE,
            &quot;queueCallback read returned: retlen %d eomReason 0x%x data %s\n&quot;,
            readBytes,eomReason,pmydata-&gt;buffer);
    }
    epicsEventSignal(pmydata-&gt;done);
}

static void asynExample(const char *port,int addr,const char *message)
{
    myData        *pmyData;
    asynUser      *pasynUser;
    asynStatus    status;
    asynInterface *pasynInterface;

    pmyData = (myData *)pasynManager-&gt;memMalloc(sizeof(myData));
    memset(pmyData,0,sizeof(myData));
    strcpy(pmyData-&gt;buffer,message);
    pasynUser = pasynManager-&gt;createAsynUser(queueCallback,0);
    pasynUser-&gt;userPvt = pmyData;
    status = pasynManager-&gt;connectDevice(pasynUser,port,addr);
    if(status!=asynSuccess) {
        printf(&quot;can&#39;t connect to serialPort1 %s\n&quot;,pasynUser-&gt;errorMessage);
        exit(1);
    }
    pasynInterface = pasynManager-&gt;findInterface(
        pasynUser,asynOctetType,1);
    if(!pasynInterface) {
        printf(&quot;%s driver not supported\n&quot;,asynOctetType);
        exit(-1);
    }
    pmyData-&gt;pasynOctet = (asynOctet *)pasynInterface-&gt;pinterface;
    pmyData-&gt;drvPvt = pasynInterface-&gt;drvPvt;
    pmyData-&gt;done = epicsEventCreate(epicsEventEmpty);
    status = pasynManager-&gt;queueRequest(pasynUser,asynQueuePriorityLow, 0.0);
    if(status) {
        asynPrint(pasynUser,ASYN_TRACE_ERROR,
            &quot;queueRequest failed %s\n&quot;,pasynUser-&gt;errorMessage);
    }
    epicsEventWait(pmyData-&gt;done);
    status = pasynManager-&gt;freeAsynUser(pasynUser);
    if(status) {
        asynPrint(pasynUser,ASYN_TRACE_ERROR,
            &quot;freeAsynUser failed %s\n&quot;,pasynUser-&gt;errorMessage);
    }
    epicsEventDestroy(pmyData-&gt;done);
    pasynManager-&gt;memFree(pasynUser-&gt;userPvt,sizeof(myData));
}
</pre></div>
</div>
<p>The flow of control is as follows:
#. A port driver calls registerPort. This step is not shown in the above example.
#. asynExample allocates myData and an asynUser.
#. asynExample connects to a device and to the asynOctet interface for the port driver.
#. When it is ready to communicate with the driver it calls queueRequest.
#. queueCallback is called. It calls the port driver’s write and read methods.</p>
</section>
<section id="test-applications">
<h2><a class="toc-backref" href="#id178" role="doc-backlink">Test Applications</a><a class="headerlink" href="#test-applications" title="Link to this heading"></a></h2>
<p>The asynDriver distribution includes several test applications to test asynDriver
and device support.</p>
<section id="testapp">
<h3><a class="toc-backref" href="#id179" role="doc-backlink">testApp</a><a class="headerlink" href="#testapp" title="Link to this heading"></a></h3>
<p>This is an example of how to interface to asynManager. The example resides in &lt;top&gt;/testApp
and contains the following components:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Db</span><span class="o">/</span>
   <span class="n">test</span><span class="o">.</span><span class="n">db</span>
   <span class="n">testBlock</span><span class="o">.</span><span class="n">db</span>
<span class="n">adl</span><span class="o">/</span>
   <span class="n">test</span><span class="o">.</span><span class="n">adl</span>
<span class="n">src</span><span class="o">/</span>
   <span class="n">devTestBlock</span><span class="o">.</span><span class="n">dbd</span>
   <span class="n">echoDriver</span><span class="o">.</span><span class="n">c</span>
   <span class="n">addrChangeDriver</span><span class="o">.</span><span class="n">c</span>
   <span class="n">devTestBlock</span><span class="o">.</span><span class="n">c</span>
   <span class="n">interposeInterface</span><span class="o">.</span><span class="n">c</span>
</pre></div>
</div>
<p>echoDriver is a port driver that echos messages it receives. It implements asynCommon
and asynOctet. When asynOctet:write is called it saves the message. When asynOctet:read
is called, the saved message is returned and the message is flushed. echoDriverInit
has an argument that determines if it acts like a multiDevice or a single device
port driver.</p>
<p>An instance of echoDriver is started via the iocsh command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">echoDriverInit</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">delay</span><span class="p">,</span><span class="n">noAutoConnect</span><span class="p">,</span><span class="n">multiDevice</span><span class="p">)</span>
</pre></div>
</div>
<p>where the arguments are:</p>
<table class="docutils align-default" id="id51">
<caption><span class="caption-text">echoDriverInit command arguments</span><a class="headerlink" href="#id51" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Argument name</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>portName</p></td>
<td><p>the port name for this instance.</p></td>
</tr>
<tr class="row-odd"><td><p>delay</p></td>
<td><p>The time to delay after a read or write. If delay is 0 then echoDriver
registers as a synchronous port driver, i.e. bit ASYN_CANBLOCK of attributes is
not set. If delay&gt;0 then ASYN_CANBLOCK is set.</p></td>
</tr>
<tr class="row-even"><td><p>noAutoConnect</p></td>
<td><p>Determines initial setting for port.</p></td>
</tr>
<tr class="row-odd"><td><p>multiDevice</p></td>
<td><p>If true then it supports two devices with addresses 0 and 1. If
false it does not set ASYN_MULTIDEVICE, i.e. it only supports a single device.</p></td>
</tr>
</tbody>
</table>
<p>addrChangeDriver is a multidevice driver that is an asynUser of another port driver.
In the example application it connects to echoDriver. An example where this technique
might be used is a port driver for mult-drop serial that connects to a standard
serial port.</p>
<p>An instance of addrChangeDriver is started via the iocsh command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">addrChangeDriverInit</span><span class="p">(</span><span class="n">portName</span><span class="p">,</span><span class="n">lowerPort</span><span class="p">,</span><span class="n">addr</span><span class="p">)</span>
</pre></div>
</div>
<p>where the arguments are:</p>
<table class="docutils align-default" id="id52">
<caption><span class="caption-text">echoDriverInit command arguments</span><a class="headerlink" href="#id52" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Argument name</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>portName</p></td>
<td><p>the port name for this instance.</p></td>
</tr>
<tr class="row-odd"><td><p>lowerPort</p></td>
<td><p>the port to which addrChangeDriver connects</p></td>
</tr>
<tr class="row-even"><td><p>addr</p></td>
<td><p>The address to which addrChangeDriver connects</p></td>
</tr>
</tbody>
</table>
<p>devTestBlock is device support that tests blockProcessCallback. It has device support
for stringin records. The INP field has the syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">field</span><span class="p">(</span><span class="n">INP</span><span class="p">,</span><span class="s2">&quot;@asyn(port,addr,timeout) pvname)</span>
</pre></div>
</div>
<p>where:
- asyn(port,addr,timeout) is same as for devEpics support.
- pvname - The name of a record in the same ioc.</p>
<p>When the stringin record is processed the following occurs.</p>
<ul>
<li><p>When process is called and PACT is :</p>
<blockquote>
<div><ul class="simple">
<li><p>TRUE - then it just returns to record support.</p></li>
<li><p>FALSE - It does what follows.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>When processing starts the state is stateIdle.</p></li>
<li><p>blockProcessCallback is called.</p></li>
<li><p>callbackRequestDelayed is called (.1 second delay). The callback calls queueRequest.</p></li>
<li><p>When processCallback is called it does the following:</p>
<blockquote>
<div><ul>
<li><p>calls unblockProcessCallback</p></li>
<li><p>If state is stateIdle</p>
<blockquote>
<div><ul class="simple">
<li><p>Calls dbGet to get a string value from pvname</p></li>
<li><p>calls pasynOctet-&gt;write to send the string</p></li>
<li><p>sets state to stateWrite</p></li>
<li><p>Calls blockProcessCallback</p></li>
<li><p>callbackRequestDelayed is called The callback calls queueRequest.</p></li>
<li><p>completes. processCallback will be called again</p></li>
</ul>
</div></blockquote>
</li>
<li><p>If state is stateWrite</p>
<blockquote>
<div><ul class="simple">
<li><p>calls pasynOctet-&gt;read and puts the value in VAL.</p></li>
<li><p>Sets state = stateIdle</p></li>
<li><p>requests the the record be processed. This time PACT will be TRUE</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
<p>test.db is a template containing three records: a calc record, which forward links
to a stringout record which forward links to a stringin record. The stringOut record
attaches to the device support supplied by asynOctetWriteRead.c. When the calcRecord
is processed the following happens:</p>
<ul class="simple">
<li><p>The calcRecord acts as a counter that overflows when the count reaches 10. After
counting to forward links ti the stringIn record.</p></li>
<li><p>The string in record gets the current value of the counter converted to s character
string and forward links to the stringOut record.</p></li>
<li><p>The stringOut record gets the value from the stringIn record an calls queueRequest.
The record is left with PACT true.</p></li>
<li><p>The processCallback calls pasynOctet-&gt;write passing the value obtained from
the stringIn record. The then does does a pasynOctet-&gt;read. When this completes
it asks for the record to complete processing.</p></li>
<li><p>The stringOut record completes processing.</p></li>
</ul>
<p>testBlock.db is a template similar to test.db except that it attached to device
support testBlock instead of asynOctetWriteRead.</p>
<p>Executing “medm -x test.adl” produces the display:</p>
<figure class="align-center" id="id53">
<img alt="_images/asynTest.png" src="_images/asynTest.png" />
<figcaption>
<p><span class="caption-text"><strong>asynTest.png</strong></span><a class="headerlink" href="#id53" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>It assumes that an ioc has been started via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">&lt;</span><span class="n">top</span><span class="o">&gt;/</span><span class="n">iocBoot</span><span class="o">/</span><span class="n">ioctest</span>
<span class="o">../../</span><span class="nb">bin</span><span class="o">/</span><span class="n">linux</span><span class="o">-</span><span class="n">x86_64</span><span class="o">/</span><span class="n">test</span> <span class="n">st</span><span class="o">.</span><span class="n">cmd</span>
</pre></div>
</div>
<p>This starts two versions of echoDriver as port “A” and “B”. port A acts as single
device port. port B acts as a multiDevice port that has two devices. For each of
the three possible devices, the st.cmd file starts up two sets of records from test.db
The st.cmd file also loads a set of records from asynTest.db for port A and for
port B and for each of the two devices attached to port B. It also loads a set of
records from asynRecord.db. It starts one version of addrChangeDriver which connects
to port A.</p>
<p>It loads six versions of test.db and four versions of testBlock.db The test.adl
file attaches to these database records.</p>
</section>
<section id="testarrayringbufferapp">
<h3><a class="toc-backref" href="#id180" role="doc-backlink">testArrayRingBufferApp</a><a class="headerlink" href="#testarrayringbufferapp" title="Link to this heading"></a></h3>
<p>This tests ring buffers for callbacks with arrays. The example resides in &lt;top&gt;/testArrayRingBufferApp.</p>
<p>Executing “medm -x testArrayRingBufferTop.adl” produces a top-level display from
which this display can be opened:</p>
<figure class="align-center" id="id54">
<img alt="_images/asynTestArrayRingBuffer.png" src="_images/asynTestArrayRingBuffer.png" />
<figcaption>
<p><span class="caption-text"><strong>asynTestArrayRingBuffer.png</strong></span><a class="headerlink" href="#id54" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>It assumes that an ioc has been started via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">&lt;</span><span class="n">top</span><span class="o">&gt;/</span><span class="n">iocBoot</span><span class="o">/</span><span class="n">ioctestArrayRingBuffer</span>
<span class="o">../../</span><span class="nb">bin</span><span class="o">/</span><span class="n">linux</span><span class="o">-</span><span class="n">x86_64</span><span class="o">/</span><span class="n">testArrayRingBuffer</span> <span class="n">st</span><span class="o">.</span><span class="n">cmd</span>
</pre></div>
</div>
</section>
<section id="testasynportclientapp">
<h3><a class="toc-backref" href="#id181" role="doc-backlink">testAsynPortClientApp</a><a class="headerlink" href="#testasynportclientapp" title="Link to this heading"></a></h3>
<p>This is a test program that demonstrates how to write C++ program that instantiates
both an asyn port driver and an asynPortClient object. It uses the asynPortClient
object to communicate with the asyn port driver directly over the asyn interfaces
without running an EPICS IOC. It creates an asynIPPort driver and an asynPortClient,
and uses the command line arguments to set the hostInfo string, a single command
string to send to the server, and optionally the input and output EOS. It then prints
out the response from the server. There are 3 example shell scipts provided that
show how to use testAsynIPPortClient to communicate with a Web server, a Newport
XPS motor controller, and a telnet host respectively.</p>
<p>Usage: testAsynIPPortClient hostInfo outputString [outputEos] [inputEos]</p>
<p>Example: testAsynIPPortClient cars.uchicago.edu:80 “GET / HTTP/1.0” “nn”</p>
<p>The example resides in &lt;top&gt;/testAsynPortClientApp.</p>
<p>testAsynPortDriverApp&lt;/h3&gt;</p>
<p>This test demonstrates how to write a driver using the asynPortDriver C++ class.
It consists of a simple digital oscilloscope simulator. When the vertical gain changes
the driver does callbacks on the enum choices for the vertical volts/division. This
requires closing and re-opening the display in medm, because Channel Access does
not do monitors on enum value changes.</p>
<p>The example resides in &lt;top&gt;/testAsynPortDriverApp.</p>
<p>Executing “medm -x testAsynPortDriverTop.adl” produces a top-level display from
which this display can be opened:</p>
<figure class="align-center" id="id55">
<img alt="_images/testAsynPortDriver.png" src="_images/testAsynPortDriver.png" />
<figcaption>
<p><span class="caption-text"><strong>testAsynPortDriver.png</strong></span><a class="headerlink" href="#id55" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>It assumes that an ioc has been started via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">&lt;</span><span class="n">top</span><span class="o">&gt;/</span><span class="n">iocBoot</span><span class="o">/</span><span class="n">ioctestAsynPortDriver</span>
<span class="o">../../</span><span class="nb">bin</span><span class="o">/</span><span class="n">linux</span><span class="o">-</span><span class="n">x86_64</span><span class="o">/</span><span class="n">testAsynPortDriver</span> <span class="n">st</span><span class="o">.</span><span class="n">cmd</span>
</pre></div>
</div>
</section>
<section id="testbroadcastapp">
<h3><a class="toc-backref" href="#id182" role="doc-backlink">testBroadcastApp</a><a class="headerlink" href="#testbroadcastapp" title="Link to this heading"></a></h3>
<p>This application contains 3 test programs that use UDP IP broadcast messages.</p>
<section id="testbroadcastasyn-c">
<h4><a class="toc-backref" href="#id183" role="doc-backlink">testBroadcastAsyn.c</a><a class="headerlink" href="#testbroadcastasyn-c" title="Link to this heading"></a></h4>
<blockquote>
<div><p>This program uses drvAsynIPPort to send UDP broadcast messages on port 37747. The
message is “in”. It then listens for any responses. If there are NSLS electrometers
on the network they should respond.</p>
</div></blockquote>
</section>
<section id="testbroadcastnoasyn-c">
<h4><a class="toc-backref" href="#id184" role="doc-backlink">testBroadcastNoAsyn.c</a><a class="headerlink" href="#testbroadcastnoasyn-c" title="Link to this heading"></a></h4>
<blockquote>
<div><p>This program does the same as testBroadcastAsyn.c but uses native socket calls rather
than drvAsynIPort.</p>
</div></blockquote>
</section>
<section id="testbroadcastburst-c">
<h4><a class="toc-backref" href="#id185" role="doc-backlink">testBroadcastBurst.c</a><a class="headerlink" href="#testbroadcastburst-c" title="Link to this heading"></a></h4>
<blockquote>
<div><p>This program is used to test the behavior of devices in the presence of large amounts
of broadcast traffic. It should be used with caution, since it can send a large
number of broadcast messages very quickly. It sends numBroadcast messages with no
delay. The messages is “testr”. It does this in a loop of numLoops with a delay
of delayTime seconds at the end of each loop. delayTime is floating point value,
so can be less than 1 second.&lt;br /&gt;
Usage: testBroadcastBurst broadcastAddress broadcastPort numBroadcast numLoops delayTime</p>
</div></blockquote>
<p>The code resides in &lt;top&gt;/testBroadcastApp.</p>
</section>
</section>
<section id="testconnectapp">
<h3><a class="toc-backref" href="#id186" role="doc-backlink">testConnectApp</a><a class="headerlink" href="#testconnectapp" title="Link to this heading"></a></h3>
<p>This application can be used to test connection management. It connects to a device
with drvAsynIPPort and periodically writes to it in a background thread. Depending
on whether the device is connected error messages will be printed. The device can
be connected and disconnected by power-cycling or removing the network cable to
test the behavior.</p>
<p>The example resides in &lt;top&gt;/testConnectApp.</p>
<p>The test ioc can be started via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">&lt;</span><span class="n">top</span><span class="o">&gt;/</span><span class="n">iocBoot</span><span class="o">/</span><span class="n">ioctestConnect</span>
<span class="o">../../</span><span class="nb">bin</span><span class="o">/</span><span class="n">linux</span><span class="o">-</span><span class="n">x86_64</span><span class="o">/</span><span class="n">testConnect</span> <span class="n">st</span><span class="o">.</span><span class="n">cmd</span>
</pre></div>
</div>
<p>The st.cmd file can be edited to select devices which will or will not ever connect.
There is no medm screen for this test.</p>
</section>
<section id="testepicsapp">
<h3><a class="toc-backref" href="#id187" role="doc-backlink">testEpicsApp</a><a class="headerlink" href="#testepicsapp" title="Link to this heading"></a></h3>
<p>This test includes example asyn port drivers for the asynInt32 and asynUInt32Digital
interfaces. Both drivers also implement the asynFloat64 interface for controlling
the update rate. The testEpicsApp application also uses the asynOctet echoDriver
from <a class="reference external" href="#testapp">testApp</a>.</p>
<p>The example resides in &lt;top&gt;/testEpicsApp.</p>
<p>Executing “medm -x *.adl” from the &lt;top&gt;/testEpicsApp/adl directory opens
the followings displays.</p>
<figure class="align-center" id="id56">
<img alt="_images/testInt32.png" src="_images/testInt32.png" />
<figcaption>
<p><span class="caption-text"><strong>testInt32</strong></span><a class="headerlink" href="#id56" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id57">
<img alt="_images/testDigital.png" src="_images/testDigital.png" />
<figcaption>
<p><span class="caption-text"><strong>testDigital</strong></span><a class="headerlink" href="#id57" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id58">
<img alt="_images/testOctet.png" src="_images/testOctet.png" />
<figcaption>
<p><span class="caption-text"><strong>testOctet</strong></span><a class="headerlink" href="#id58" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>From the testInt32.adl screen the following time-series screen can be opened.</p>
<figure class="align-center" id="id59">
<img alt="_images/asynTimeSeries.png" src="_images/asynTimeSeries.png" />
<figcaption>
<p><span class="caption-text"><strong>asynTimeSeries</strong></span><a class="headerlink" href="#id59" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>It assumes that an ioc has been started via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">&lt;</span><span class="n">top</span><span class="o">&gt;/</span><span class="n">iocBoot</span><span class="o">/</span><span class="n">ioctestEpics</span>
<span class="o">../../</span><span class="nb">bin</span><span class="o">/</span><span class="n">linux</span><span class="o">-</span><span class="n">x86_64</span><span class="o">/</span><span class="n">testEpics</span> <span class="n">st</span><span class="o">.</span><span class="n">cmd</span>
</pre></div>
</div>
</section>
<section id="testerrorsapp">
<h3><a class="toc-backref" href="#id188" role="doc-backlink">testErrorsApp</a><a class="headerlink" href="#testerrorsapp" title="Link to this heading"></a></h3>
<p>This tests error handling in standard asyn device support. The user can control
the status and severity for write operations, read operations, and interrupt callbacks.
It tests all of the interfaces (asynInt32, asynInt64, asynUInt32Digital, asynFloat64,
asynOctet, asynEnum, asynXXXArray (XXX=Int8, Int16, Int32, Int64, Float32, Float64).
It tests output records both with an without the info tag asyn:READBACK. By editing
options in the st.cmd file it also tests:</p>
<ul class="simple">
<li><p>Synchronous and asynchronous driver operation (ASYN_CANBLOCK unset or set)</p></li>
<li><p>String and waveform records with or without ring buffer support(asyn:FIFO=0 or 5)</p></li>
<li><p>Record .TSE field 0 (default timestamp support) or -2 (records get their timestamps
from the driver)</p></li>
<li><p>Periodic or I/O Intr scanning of input records.</p></li>
</ul>
<p>The example resides in &lt;top&gt;/testEpicsApp.</p>
<p>Executing “medm -x testErrorsTop.adl” from the &lt;top&gt;/testEerrorsApp/adl directory
produces a top-level display from which this display can be opened:</p>
<figure class="align-center" id="id60">
<img alt="_images/testErrors.png" src="_images/testErrors.png" />
<figcaption>
<p><span class="caption-text"><strong>testErrors</strong></span><a class="headerlink" href="#id60" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>It assumes that an ioc has been started via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">&lt;</span><span class="n">top</span><span class="o">&gt;/</span><span class="n">iocBoot</span><span class="o">/</span><span class="n">ioctestErrors</span>
<span class="o">../../</span><span class="nb">bin</span><span class="o">/</span><span class="n">linux</span><span class="o">-</span><span class="n">x86_64</span><span class="o">/</span><span class="n">testErrors</span> <span class="n">st</span><span class="o">.</span><span class="n">cmd</span>
</pre></div>
</div>
</section>
</section>
<section id="install-and-build">
<h2><a class="toc-backref" href="#id189" role="doc-backlink">Install and Build</a><a class="headerlink" href="#install-and-build" title="Link to this heading"></a></h2>
<section id="install-and-build-asyndriver">
<h3><a class="toc-backref" href="#id190" role="doc-backlink">Install and Build asynDriver</a><a class="headerlink" href="#install-and-build-asyndriver" title="Link to this heading"></a></h3>
<p>After obtaining a copy of the distribution, it must be installed and built for use
at your site. These steps only need to be performed once for the site (unless versions
of the module running under different releases of EPICS and/or the other required
modules are needed).</p>
<ol class="arabic">
<li><p>Create an installation directory for the module, usually this will end with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">.../</span><span class="n">support</span><span class="o">/</span><span class="n">asyn</span><span class="o">/</span>
</pre></div>
</div>
</li>
<li><p>Place the distribution file in this directory. Then issue the commands (Unix style)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tar</span> <span class="n">xvzf</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span>
</pre></div>
</div>
</li>
<li><p>This creates a support &lt;top&gt;.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">.../</span><span class="n">support</span><span class="o">/</span><span class="n">asyn</span><span class="o">/</span><span class="n">X</span><span class="o">-</span><span class="n">Y</span>
<span class="n">where</span> <span class="n">X</span><span class="o">-</span><span class="n">Y</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">release</span> <span class="n">number</span><span class="o">.</span> <span class="n">For</span> <span class="n">example</span><span class="p">:</span>
<span class="o">.../</span><span class="n">support</span><span class="o">/</span><span class="n">asyn</span><span class="o">/</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</li>
<li><p>Edit the <code class="docutils literal notranslate"><span class="pre">config/RELEASE</span></code> file and set the paths to your installation of
EPICS_BASE and IPAC. IPAC is only needed if you are building for vxWorks.</p></li>
<li><p>Run <code class="docutils literal notranslate"><span class="pre">make</span></code> in the top level directory and check for any compilation errors.</p></li>
</ol>
</section>
<section id="using-asyndriver-components-with-an-epics-ioccore-application">
<h3><a class="toc-backref" href="#id191" role="doc-backlink">Using asynDriver Components with an EPICS iocCore Application</a><a class="headerlink" href="#using-asyndriver-components-with-an-epics-ioccore-application" title="Link to this heading"></a></h3>
<p>Since asynDriver does NOT provide support for specific devices an application must
obtain device specific support elsewhere. This section only explains how to include
asynDriver components.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">configure/RELEASE</span></code> file add definitions for <code class="docutils literal notranslate"><span class="pre">IPAC</span></code>,
<code class="docutils literal notranslate"><span class="pre">ASYN</span></code>, and <code class="docutils literal notranslate"><span class="pre">EPICS_BASE</span></code>.</p>
<p>In the src directory where the application is built:</p>
<ul>
<li><p>Add the following to <code class="docutils literal notranslate"><span class="pre">Makefile</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">app</span><span class="o">&gt;</span><span class="n">_LIBS</span> <span class="o">+=</span> <span class="n">asyn</span>
</pre></div>
</div>
</li>
</ul>
<p>The application database definition file must include the database definition
files for the stream package and for any needed ASYN drivers. There are two ways
that this can be done:</p>
<p>If you are building your application database definition file from the application
Makefile you specify the aditional database definitions there (uncomment the lines
appropriate to your application):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">include</span> <span class="s2">&quot;asyn.dbd&quot;</span>
<span class="c1">#include &quot;drvAsynSerialPort.dbd&quot;</span>
<span class="c1">#include &quot;drvAsynIPPort.dbd&quot;</span>
<span class="c1">#include &quot;drvVxi11.dbd&quot;</span>
<span class="c1">#include &quot;drvGsIP488.dbd&quot;</span>
<span class="c1">#include &quot;drvIpac.dbd&quot;</span>
<span class="c1">#include &quot;drvUSBTMC.dbd&quot;</span>
</pre></div>
</div>
<p>If you are building your application database definition file from the application
Makefile you specify the aditional database definitions there (again, uncomment
the lines appropriate to your application):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xxx_DBD</span> <span class="o">+=</span> <span class="n">asyn</span><span class="o">.</span><span class="n">dbd</span>
<span class="c1">#xxx_DBD += drvAsynSerialPort.dbd</span>
<span class="c1">#xxx_DBD += drvAsynIPPort.dbd</span>
<span class="c1">#xxx_DBD += drvVxi11.dbd</span>
<span class="c1">#xxx_DBD += drvGsIP488.dbd</span>
<span class="c1">#xxx_DBD += drvIpac.dbd</span>
<span class="c1">#xxx_DBD += drvUSBTMC.dbd</span>
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">st.cmd</span></code> file add:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dbLoadRecords</span><span class="p">(</span><span class="s2">&quot;db/asynRecord.db&quot;</span><span class="p">,</span> <span class="s2">&quot;P=&lt;ioc&gt;, R=&lt;record&gt;, PORT=&lt;port&gt;, ADDR=&lt;addr&gt;, OMAX=&lt;omax&gt;, IMAX=&lt;imax&gt;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>You must provide values for &lt;ioc&gt;, &lt;record&gt;, &lt;port&gt;, &lt;addr&gt;, &lt;omax&gt;, and &lt;imax&gt;.</p>
<p>Once the application is running, medm displays for an ioc can be started by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">medm</span> <span class="o">-</span><span class="n">x</span> <span class="o">-</span><span class="n">macro</span> <span class="s2">&quot;P=&lt;ioc&gt;,R=&lt;record&gt;&quot;</span> <span class="o">&lt;</span><span class="n">asyntop</span><span class="o">&gt;/</span><span class="n">medm</span><span class="o">/</span><span class="n">asynRecord</span><span class="o">.</span><span class="n">adl</span> <span class="o">&amp;</span>
</pre></div>
</div>
<p>You must provide correct values for &lt;ioc&gt; and &lt;record&gt;. Once asynRecord
is started, it can be connected to different devices.</p>
</section>
</section>
<section id="id3">
<h2><a class="toc-backref" href="#id192" role="doc-backlink">License Agreement</a><a class="headerlink" href="#id3" title="Link to this heading"></a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Copyright</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="mi">2002</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Chicago</span> <span class="n">All</span> <span class="n">rights</span> <span class="n">reserved</span><span class="o">.</span>
<span class="n">asynDriver</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">subject</span> <span class="n">to</span> <span class="n">the</span> <span class="n">following</span> <span class="n">license</span> <span class="n">conditions</span><span class="p">:</span>

<span class="n">SOFTWARE</span> <span class="n">LICENSE</span> <span class="n">AGREEMENT</span>
<span class="n">Software</span><span class="p">:</span> <span class="n">asynDriver</span>

 <span class="mf">1.</span> <span class="n">The</span> <span class="s2">&quot;Software&quot;</span><span class="p">,</span> <span class="n">below</span><span class="p">,</span> <span class="n">refers</span> <span class="n">to</span> <span class="n">asynDriver</span> <span class="p">(</span><span class="ow">in</span> <span class="n">either</span> <span class="n">source</span> <span class="n">code</span><span class="p">,</span> <span class="ow">or</span>
    <span class="n">binary</span> <span class="n">form</span> <span class="ow">and</span> <span class="n">accompanying</span> <span class="n">documentation</span><span class="p">)</span><span class="o">.</span> <span class="n">Each</span> <span class="n">licensee</span> <span class="ow">is</span>
    <span class="n">addressed</span> <span class="k">as</span> <span class="s2">&quot;you&quot;</span> <span class="ow">or</span> <span class="s2">&quot;Licensee.&quot;</span>

 <span class="mf">2.</span> <span class="n">The</span> <span class="n">copyright</span> <span class="n">holders</span> <span class="n">shown</span> <span class="n">above</span> <span class="ow">and</span> <span class="n">their</span> <span class="n">third</span><span class="o">-</span><span class="n">party</span> <span class="n">licensors</span>
    <span class="n">hereby</span> <span class="n">grant</span> <span class="n">Licensee</span> <span class="n">a</span> <span class="n">royalty</span><span class="o">-</span><span class="n">free</span> <span class="n">nonexclusive</span> <span class="n">license</span><span class="p">,</span> <span class="n">subject</span> <span class="n">to</span>
    <span class="n">the</span> <span class="n">limitations</span> <span class="n">stated</span> <span class="n">herein</span> <span class="ow">and</span> <span class="n">U</span><span class="o">.</span><span class="n">S</span><span class="o">.</span> <span class="n">Government</span> <span class="n">license</span> <span class="n">rights</span><span class="o">.</span>

 <span class="mf">3.</span> <span class="n">You</span> <span class="n">may</span> <span class="n">modify</span> <span class="ow">and</span> <span class="n">make</span> <span class="n">a</span> <span class="n">copy</span> <span class="ow">or</span> <span class="n">copies</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Software</span> <span class="k">for</span> <span class="n">use</span>
    <span class="n">within</span> <span class="n">your</span> <span class="n">organization</span><span class="p">,</span> <span class="k">if</span> <span class="n">you</span> <span class="n">meet</span> <span class="n">the</span> <span class="n">following</span> <span class="n">conditions</span><span class="p">:</span>
      <span class="n">a</span><span class="o">.</span> <span class="n">Copies</span> <span class="ow">in</span> <span class="n">source</span> <span class="n">code</span> <span class="n">must</span> <span class="n">include</span> <span class="n">the</span> <span class="n">copyright</span> <span class="n">notice</span> <span class="ow">and</span> <span class="n">this</span>
         <span class="n">Software</span> <span class="n">License</span> <span class="n">Agreement</span><span class="o">.</span>
      <span class="n">b</span><span class="o">.</span> <span class="n">Copies</span> <span class="ow">in</span> <span class="n">binary</span> <span class="n">form</span> <span class="n">must</span> <span class="n">include</span> <span class="n">the</span> <span class="n">copyright</span> <span class="n">notice</span> <span class="ow">and</span> <span class="n">this</span>
         <span class="n">Software</span> <span class="n">License</span> <span class="n">Agreement</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">documentation</span> <span class="ow">and</span><span class="o">/</span><span class="ow">or</span> <span class="n">other</span>
         <span class="n">materials</span> <span class="n">provided</span> <span class="k">with</span> <span class="n">the</span> <span class="n">copy</span><span class="o">.</span>

 <span class="mf">4.</span> <span class="n">You</span> <span class="n">may</span> <span class="n">modify</span> <span class="n">a</span> <span class="n">copy</span> <span class="ow">or</span> <span class="n">copies</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Software</span> <span class="ow">or</span> <span class="nb">any</span> <span class="n">portion</span> <span class="n">of</span> <span class="n">it</span><span class="p">,</span>
    <span class="n">thus</span> <span class="n">forming</span> <span class="n">a</span> <span class="n">work</span> <span class="n">based</span> <span class="n">on</span> <span class="n">the</span> <span class="n">Software</span><span class="p">,</span> <span class="ow">and</span> <span class="n">distribute</span> <span class="n">copies</span> <span class="n">of</span>
    <span class="n">such</span> <span class="n">work</span> <span class="n">outside</span> <span class="n">your</span> <span class="n">organization</span><span class="p">,</span> <span class="k">if</span> <span class="n">you</span> <span class="n">meet</span> <span class="nb">all</span> <span class="n">of</span> <span class="n">the</span> <span class="n">following</span>
    <span class="n">conditions</span><span class="p">:</span>
      <span class="n">a</span><span class="o">.</span> <span class="n">Copies</span> <span class="ow">in</span> <span class="n">source</span> <span class="n">code</span> <span class="n">must</span> <span class="n">include</span> <span class="n">the</span> <span class="n">copyright</span> <span class="n">notice</span> <span class="ow">and</span> <span class="n">this</span>
         <span class="n">Software</span> <span class="n">License</span> <span class="n">Agreement</span><span class="p">;</span>
      <span class="n">b</span><span class="o">.</span> <span class="n">Copies</span> <span class="ow">in</span> <span class="n">binary</span> <span class="n">form</span> <span class="n">must</span> <span class="n">include</span> <span class="n">the</span> <span class="n">copyright</span> <span class="n">notice</span> <span class="ow">and</span> <span class="n">this</span>
         <span class="n">Software</span> <span class="n">License</span> <span class="n">Agreement</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">documentation</span> <span class="ow">and</span><span class="o">/</span><span class="ow">or</span> <span class="n">other</span>
         <span class="n">materials</span> <span class="n">provided</span> <span class="k">with</span> <span class="n">the</span> <span class="n">copy</span><span class="p">;</span>
      <span class="n">c</span><span class="o">.</span> <span class="n">Modified</span> <span class="n">copies</span> <span class="ow">and</span> <span class="n">works</span> <span class="n">based</span> <span class="n">on</span> <span class="n">the</span> <span class="n">Software</span> <span class="n">must</span> <span class="n">carry</span>
         <span class="n">prominent</span> <span class="n">notices</span> <span class="n">stating</span> <span class="n">that</span> <span class="n">you</span> <span class="n">changed</span> <span class="n">specified</span> <span class="n">portions</span> <span class="n">of</span>
         <span class="n">the</span> <span class="n">Software</span><span class="o">.</span>

 <span class="mf">5.</span> <span class="n">Portions</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Software</span> <span class="n">resulted</span> <span class="kn">from</span> <span class="nn">work</span> <span class="n">developed</span> <span class="n">under</span> <span class="n">a</span> <span class="n">U</span><span class="o">.</span><span class="n">S</span><span class="o">.</span>
    <span class="n">Government</span> <span class="n">contract</span> <span class="ow">and</span> <span class="n">are</span> <span class="n">subject</span> <span class="n">to</span> <span class="n">the</span> <span class="n">following</span> <span class="n">license</span><span class="p">:</span> <span class="n">the</span>
    <span class="n">Government</span> <span class="ow">is</span> <span class="n">granted</span> <span class="k">for</span> <span class="n">itself</span> <span class="ow">and</span> <span class="n">others</span> <span class="n">acting</span> <span class="n">on</span> <span class="n">its</span> <span class="n">behalf</span> <span class="n">a</span>
    <span class="n">paid</span><span class="o">-</span><span class="n">up</span><span class="p">,</span> <span class="n">nonexclusive</span><span class="p">,</span> <span class="n">irrevocable</span> <span class="n">worldwide</span> <span class="n">license</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">computer</span>
    <span class="n">software</span> <span class="n">to</span> <span class="n">reproduce</span><span class="p">,</span> <span class="n">prepare</span> <span class="n">derivative</span> <span class="n">works</span><span class="p">,</span> <span class="ow">and</span> <span class="n">perform</span> <span class="n">publicly</span>
    <span class="ow">and</span> <span class="n">display</span> <span class="n">publicly</span><span class="o">.</span>

 <span class="mf">6.</span> <span class="n">WARRANTY</span> <span class="n">DISCLAIMER</span><span class="o">.</span> <span class="n">THE</span> <span class="n">SOFTWARE</span> <span class="n">IS</span> <span class="n">SUPPLIED</span> <span class="s2">&quot;AS IS&quot;</span> <span class="n">WITHOUT</span> <span class="n">WARRANTY</span>
    <span class="n">OF</span> <span class="n">ANY</span> <span class="n">KIND</span><span class="o">.</span> <span class="n">THE</span> <span class="n">COPYRIGHT</span> <span class="n">HOLDERS</span><span class="p">,</span> <span class="n">THEIR</span> <span class="n">THIRD</span> <span class="n">PARTY</span> <span class="n">LICENSORS</span><span class="p">,</span> <span class="n">THE</span>
    <span class="n">UNITED</span> <span class="n">STATES</span><span class="p">,</span> <span class="n">THE</span> <span class="n">UNITED</span> <span class="n">STATES</span> <span class="n">DEPARTMENT</span> <span class="n">OF</span> <span class="n">ENERGY</span><span class="p">,</span> <span class="n">AND</span> <span class="n">THEIR</span>
    <span class="n">EMPLOYEES</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">DISCLAIM</span> <span class="n">ANY</span> <span class="n">WARRANTIES</span><span class="p">,</span> <span class="n">EXPRESS</span> <span class="n">OR</span> <span class="n">IMPLIED</span><span class="p">,</span> <span class="n">INCLUDING</span>
    <span class="n">BUT</span> <span class="n">NOT</span> <span class="n">LIMITED</span> <span class="n">TO</span> <span class="n">ANY</span> <span class="n">IMPLIED</span> <span class="n">WARRANTIES</span> <span class="n">OF</span> <span class="n">MERCHANTABILITY</span><span class="p">,</span> <span class="n">FITNESS</span>
    <span class="n">FOR</span> <span class="n">A</span> <span class="n">PARTICULAR</span> <span class="n">PURPOSE</span><span class="p">,</span> <span class="n">TITLE</span> <span class="n">OR</span> <span class="n">NON</span><span class="o">-</span><span class="n">INFRINGEMENT</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">DO</span> <span class="n">NOT</span> <span class="n">ASSUME</span>
    <span class="n">ANY</span> <span class="n">LEGAL</span> <span class="n">LIABILITY</span> <span class="n">OR</span> <span class="n">RESPONSIBILITY</span> <span class="n">FOR</span> <span class="n">THE</span> <span class="n">ACCURACY</span><span class="p">,</span> <span class="n">COMPLETENESS</span><span class="p">,</span>
    <span class="n">OR</span> <span class="n">USEFULNESS</span> <span class="n">OF</span> <span class="n">THE</span> <span class="n">SOFTWARE</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">DO</span> <span class="n">NOT</span> <span class="n">REPRESENT</span> <span class="n">THAT</span> <span class="n">USE</span> <span class="n">OF</span> <span class="n">THE</span>
    <span class="n">SOFTWARE</span> <span class="n">WOULD</span> <span class="n">NOT</span> <span class="n">INFRINGE</span> <span class="n">PRIVATELY</span> <span class="n">OWNED</span> <span class="n">RIGHTS</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">DO</span> <span class="n">NOT</span> <span class="n">WARRANT</span>
    <span class="n">THAT</span> <span class="n">THE</span> <span class="n">SOFTWARE</span> <span class="n">WILL</span> <span class="n">FUNCTION</span> <span class="n">UNINTERRUPTED</span><span class="p">,</span> <span class="n">THAT</span> <span class="n">IT</span> <span class="n">IS</span> <span class="n">ERROR</span><span class="o">-</span><span class="n">FREE</span>
    <span class="n">OR</span> <span class="n">THAT</span> <span class="n">ANY</span> <span class="n">ERRORS</span> <span class="n">WILL</span> <span class="n">BE</span> <span class="n">CORRECTED</span><span class="o">.</span>

 <span class="mf">7.</span> <span class="n">LIMITATION</span> <span class="n">OF</span> <span class="n">LIABILITY</span><span class="o">.</span> <span class="n">IN</span> <span class="n">NO</span> <span class="n">EVENT</span> <span class="n">WILL</span> <span class="n">THE</span> <span class="n">COPYRIGHT</span> <span class="n">HOLDERS</span><span class="p">,</span> <span class="n">THEIR</span>
    <span class="n">THIRD</span> <span class="n">PARTY</span> <span class="n">LICENSORS</span><span class="p">,</span> <span class="n">THE</span> <span class="n">UNITED</span> <span class="n">STATES</span><span class="p">,</span> <span class="n">THE</span> <span class="n">UNITED</span> <span class="n">STATES</span> <span class="n">DEPARTMENT</span>
    <span class="n">OF</span> <span class="n">ENERGY</span><span class="p">,</span> <span class="n">OR</span> <span class="n">THEIR</span> <span class="n">EMPLOYEES</span><span class="p">:</span> <span class="n">BE</span> <span class="n">LIABLE</span> <span class="n">FOR</span> <span class="n">ANY</span> <span class="n">INDIRECT</span><span class="p">,</span> <span class="n">INCIDENTAL</span><span class="p">,</span>
    <span class="n">CONSEQUENTIAL</span><span class="p">,</span> <span class="n">SPECIAL</span> <span class="n">OR</span> <span class="n">PUNITIVE</span> <span class="n">DAMAGES</span> <span class="n">OF</span> <span class="n">ANY</span> <span class="n">KIND</span> <span class="n">OR</span> <span class="n">NATURE</span><span class="p">,</span>
    <span class="n">INCLUDING</span> <span class="n">BUT</span> <span class="n">NOT</span> <span class="n">LIMITED</span> <span class="n">TO</span> <span class="n">LOSS</span> <span class="n">OF</span> <span class="n">PROFITS</span> <span class="n">OR</span> <span class="n">LOSS</span> <span class="n">OF</span> <span class="n">DATA</span><span class="p">,</span> <span class="n">FOR</span> <span class="n">ANY</span>
    <span class="n">REASON</span> <span class="n">WHATSOEVER</span><span class="p">,</span> <span class="n">WHETHER</span> <span class="n">SUCH</span> <span class="n">LIABILITY</span> <span class="n">IS</span> <span class="n">ASSERTED</span> <span class="n">ON</span> <span class="n">THE</span> <span class="n">BASIS</span> <span class="n">OF</span>
    <span class="n">CONTRACT</span><span class="p">,</span> <span class="n">TORT</span> <span class="p">(</span><span class="n">INCLUDING</span> <span class="n">NEGLIGENCE</span> <span class="n">OR</span> <span class="n">STRICT</span> <span class="n">LIABILITY</span><span class="p">),</span> <span class="n">OR</span>
    <span class="n">OTHERWISE</span><span class="p">,</span> <span class="n">EVEN</span> <span class="n">IF</span> <span class="n">ANY</span> <span class="n">OF</span> <span class="n">SAID</span> <span class="n">PARTIES</span> <span class="n">HAS</span> <span class="n">BEEN</span> <span class="n">WARNED</span> <span class="n">OF</span> <span class="n">THE</span>
    <span class="n">POSSIBILITY</span> <span class="n">OF</span> <span class="n">SUCH</span> <span class="n">LOSS</span> <span class="n">OR</span> <span class="n">DAMAGES</span><span class="o">.</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="asyn" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="asynPortDriver.html" class="btn btn-neutral float-right" title="asynPortDriver" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Mark Rivers.
      <span class="lastupdated">Last updated on 2023-September-20.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>