<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0058)http://cars9.uchicago.edu/software/epics/serialRecord.html -->
<HTML><HEAD><TITLE>serial - Generic Serial Record</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="Microsoft FrontPage 4.0" name=GENERATOR></HEAD>
<BODY>
<H1>asynOctet Record</H1>
<ADDRESS>Mark Rivers</ADDRESS>
<HR>

<H2>Contents</H2>
<UL>
  <LI><A 
  href="http://cars9.uchicago.edu/software/epics/serialRecord.html#Overview">Overview</A> 

  <LI><A 
  href="http://cars9.uchicago.edu/software/epics/serialRecord.html#Fields">Field 
  Descriptions</A> 
  <LI><A 
  href="http://cars9.uchicago.edu/software/epics/serialRecord.html#Files">Files</A> 

  <LI><A 
  href="http://cars9.uchicago.edu/software/epics/serialRecord.html#Restrictions">Restrictions</A> 

  <LI><A 
  href="http://cars9.uchicago.edu/software/epics/serialRecord.html#Release">Release 
  Notes</A> 
  <LI><A 
  href="http://cars9.uchicago.edu/software/epics/serialRecord.html#Example">Example</A> 
  </LI></UL><A name=Overview>
<H2>Overview</H2></A>
<P>The asynOctet record is designed to perform generic I/O to any device that
the asyn module supports. It is intended to allow EPICS to communicate with a new
device without rebooting the IOC, i.e. without writing any C code or 
changing the database. The asynOctet record is thus very useful for allowing 
Channel Access clients to communicate with devices for which no EPICS 
device support exists. In combination with the scalcout record to format output
strings and to parse response strings, it can actually eliminate the need for C
device support code in many applications. It is also useful for diagnostics. The
asyn device &quot;port&quot; and &quot;address&quot; can be dynamically changed
in the record, so a single asynOctet record can be switched from talking to one
device to another at run time. It provides access to asynTrace for the device,
controlling debugging output at the shell.
<P>There are two output fields, AOUT (ASCII Output) and BOUT (Byte Output). The
OFMT (Output Format) field is used to select one of these fields or the other as
the output source to the serial device. Similarly, there are two input fields,
AINP (ASCII Input) and BINP (Byte Input). The IFMT (Input Format) field is used
to select one or the other as the destination of data sent from the serial
device. The ASCII fields are type DBF_STRING, and are very convenient for
typical communication with many serial devices. They permit, for example, <code>medm</code>
screens where the user can type a string and observe the response from the
instrument. The ASCII fields, however are limited to 40 characters in length,
and cannot be used to read or write binary data. The binary input and output
fields are DBF_CHAR arrays, and can be used to transfer large blocks of
arbitrary data, either ASCII or binary.<P>For local serial ports the baud 
rate, parity, etc. can be controlled by fields in the record.&nbsp; For GPIB
devices the GPIB address can be changed, and global and addressed commands can
be executed.&nbsp; asyn socket ports can be dynamically created at run time.<P>&nbsp;
      <TABLE>
        <TR>
          <TD colSpan=3>Note: In the Access columns in the field description
            tables: </TD>
        <TR vAlign=top>
          <TD>R</TD>
          <TD>Read only
          <TD></TD>
        <TR vAlign=top>
          <TD>R/W</TD>
          <TD>Read and write are allowed</TD></TR>
        <TR vAlign=top>
          <TD>R/W*</TD>
          <TD>Read and write are allowed; write triggers record processing if 
            the record's SCAN field is set to "Passive".</TD></TR>
        <TR vAlign=top>
          <TD>N</TD>
          <TD>No access allowed</TD></TR></TABLE><P>&nbsp;
<HR>

<h2 align="center">Input/Output Control Fields</h2>

<TABLE cellPadding=5 border=1>
  <TR>
    <TH>Name</TH>
    <TH>Access</TH>
    <TH>Prompt</TH>
    <TH>Data type</TH>
    <TH>Description</TH></TR>
  <TR vAlign=top>
    <TD>VAL</TD>
    <TD>R/W</TD>
    <TD>"Value field (unused)"</TD>
    <TD>DBF_STRING</TD>
    <TD>This field is unused. The functions normally assigned to the VAL field 
      in many records are performed by the AOUT, BOUT, AINP, and BINP fields in 
      the asynOctet record.</TD></TR>
  <TR vAlign=top>
    <TD>TMOD</TD>
    <TD>R/W</TD>
    <TD>"Transaction mode"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The type of I/O transaction to perform when the record is processed. The choices are: 
      <TABLE>
        <TBODY>
        <TR vAlign=top>
          <TD>"Write/Read" (default)</TD>
        </TR>
        <TR vAlign=top>
          <TD>"Write"</TD>
        </TR>
        <TR vAlign=top>
          <TD>"Read"</TD>
        </TR>
        <TR vAlign=top>
          <TD>&quot;Flush&quot;</TD>
        </TR></TBODY></TABLE></TD></TR>
  <tr>
    <TD>TMOT</TD>
    <TD>R/W</TD>
    <TD>"Timeout (sec)&quot;</TD>
    <TD>DBF_DOUBLE</TD>
    <TD>The timeout value for read and write operations in seconds. If a 
      response is not received from the device within this time then the record 
      sets a major alarm. -1.0 means wait forever, no timeour. Default=1.0</TD>
  </tr>
</TABLE>
&nbsp;
<p>The TMOD field controls what type of I/O is performed when the record
processes.</p>
      <TABLE>
        <TR vAlign=top>
          <TD>"Write/Read" (default)</TD>
          <TD>The output source (AOUT or BOUT as selected by OFMT) is sent to 
            the device. A response is then read back into AINP or BINP 
            (as selected by IFMT). The response must be received within the time 
            specified by TMOT. The input buffer is flushed before the write operation, so that any characters received prior to the write 
            operation are discarded.</TD></TR>
        <TR vAlign=top>
          <TD>"Write"</TD>
          <TD>The output source (AOUT or BOUT as selected by OFMT) is sent to 
            the device. No response is read back.</TD></TR>
        <TR vAlign=top>
          <TD>"Read"</TD>
          <TD>Data is read from the device into the input field (AINP 
            or BINP as selected by IFMT). The response must be received within 
            the time specified by TMOT. No output is sent to the device prior to 
            the read operation.</TD></TR>
        <TR vAlign=top>
          <TD>&quot;Flush&quot;</TD>
          <TD>The input buffer is flushed.&nbsp; Nothing is sent to the device
            or read from the device.</TD></TR></TABLE>

<p>&nbsp;</p>
<HR>

<h2 align="center">Output Control Fields</h2>

<TABLE cellPadding=5 border=1>
  <TR>
    <TH>Name</TH>
    <TH>Access</TH>
    <TH>Prompt</TH>
    <TH>Data type</TH>
    <TH>Description</TH></TR>
  <TR vAlign=top>
    <TD>AOUT</TD>
    <TD>R/W*</TD>
    <TD>"Output string"</TD>
    <TD>DBF_STRING</TD>
    <TD>The output string which is sent to the device if OFMT="ASCII". The 
      number of bytes sent to the device will be <CODE>strlen(AOUT)</CODE>  plus <CODE>strlen(OEOS)</CODE>.</TD></TR>
  <TR vAlign=top>
    <TD>BOUT</TD>
    <TD>R/W*</TD>
    <TD>"Output byte data"</TD>
    <TD>DBF_CHAR (array)</TD>
    <TD>The output data which is sent to the device if OFMT=&quot;Binary&quot;
      or&nbsp; &quot;Hybrid&quot;. The 
      maximum length of this field is controlled by OMAX. The actual number of 
      bytes to be sent to the device when OFMT=&quot;Hybrid&quot; will be&nbsp; <CODE>strlen(AOUT)</CODE> 
      plus <CODE>strlen(OEOS). </CODE> The actual number of 
      bytes to be sent to the device when OFMP=&quot;Binary&quot; will be NOWT.</TD></TR>
  <TR vAlign=top>
    <TD>OEOS</TD>
    <TD>R/W</TD>
    <TD>"Output terminator&quot;</TD>
    <TD>DBF_STRING</TD>
    <TD>A character string that is appended to the output before 
      transmission to the device. This field is ignored if OFMT=&quot;Binary&quot;.
      Set this field to &quot;&quot; to suppress transmission 
      of a terminator. Commonly used values are &quot;\r&quot; (the default),
      &quot;\n&quot;, and &quot;\r\n&quot;.</TD></TR>
  <TR vAlign=top>
    <TD>OMAX</TD>
    <TD>R</TD>
    <TD>"Max. size of output array"</TD>
    <TD>DBF_LONG</TD>
    <TD>The allocated length of the BOUT array. This value cannot be changed 
      after IOC initialization. Default=512.</TD></TR>
  <TR vAlign=top>
    <TD>NOWT</TD>
    <TD>R/W</TD>
    <TD>"Number of bytes to write"</TD>
    <TD>DBF_LONG</TD>
    <TD>The actual number of bytes to send from the BOUT array to the serial 
      device if OFMT=&quot;Binary&quot;. This value must be less than or equal to OMAX. 
  Default=512.</TD></TR>
  <TR vAlign=top>
    <TD>OFMT</TD>
    <TD>R/W</TD>
    <TD>"Output format"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The output format. The choices are: 
      <TABLE>
        <TBODY>
        <TR vAlign=top>
          <TD>"ASCII (default)"</TD>
          <TD>The data sent to the device will be taken from the AOUT 
        field.</TD></TR>
        <TR vAlign=top>
          <TD>&quot;Hybrid&quot;</TD>
          <TD>The data sent to the device will be taken from the BOUT 
        field.</TD></TR>
        <TR vAlign=top>
          <TD>"Binary"</TD>
          <TD>The data sent to the device will be taken from the BOUT 
        field.</TD></TR></TBODY></TABLE></TD></TR>
</TABLE>
<P>There are two output fields, AOUT (ASCII Output) and BOUT (Binary Output). 
The OFMT (Output Format) field is used to select one of these fields or the 
other as the output source to the device.&nbsp; 
<P>If OFMT=&quot;ASCII&quot; then the AOUT fields and OEOS fields are processed
with dbTranslateEscape() to convert control characters (e.g. &quot;\r&quot;,
&quot;\021&quot;) to bytes, these fields are combined into a single buffer, the
length of the output is determined with strlen(), and the string is sent to the
device. 
<P>If OFMT=&quot;Hybrid&quot; then the BOUT fields and OEOS fields are processed
with dbTranslateEscape() to convert control characters (e.g. &quot;\r&quot;,
&quot;\021&quot;) to bytes, these fields are combined into a single buffer, the
length of the output is determined with strlen(), and the string is sent to the
device.<P>If OFMT=&quot;Binary&quot; then the NOWT bytes from the BOUT field are
sent to the device.&nbsp; The OEOS field is ignored, and dbTranslateEscape() is
not called.

<p>&nbsp;</p>
<HR>

<h2 align="center">Input Control Fields</h2>

<TABLE cellPadding=5 border=1>
  <TR>
    <TH>Name</TH>
    <TH>Access</TH>
    <TH>Prompt</TH>
    <TH>Data type</TH>
    <TH>Description</TH></TR>
  <TR vAlign=top>
    <TD>AINP</TD>
    <TD>R</TD>
    <TD>"Input string"</TD>
    <TD>DBF_STRING</TD>
    <TD>The input string which is read from the device if IFMT="ASCII". The 
      string will be null terminated. Note that due to the maximum size of a 
      string in EPICS, the input string must be less than 40 characters. If 
      longer strings are required then set IFMT=&quot;Hybrid&quot; and read into the BINP 
      field.</TD></TR>
  <TR vAlign=top>
    <TD>BINP</TD>
    <TD>R</TD>
    <TD>"Input byte data"</TD>
    <TD>DBF_CHAR (array)</TD>
    <TD>The input data which is read from the device if IFMT=&quot;Hybrid&quot;
      or IFMT=&quot;Binary&quot;. The 
      maximum length of this field is controlled by IMAX. The actual number of 
      bytes read from the device is given by NORD.</TD></TR>
  <TR vAlign=top>
    <TD>IEOS</TD>
    <TD>R/W</TD>
    <TD>"Input terminator&quot;</TD>
    <TD>DBF_STRING</TD>
    <TD>A string that indicates the end of a message on input. Set this 
      field to &quot;&quot;&quot; if no input terminator should be used. This field is ignored if
      IFMT=&quot;Binary&quot;. Commonly used values are &quot;\r&quot; (the default),
      &quot;\n&quot;, and &quot;\r\n&quot;. The 
      input terminator is removed from the input buffer after the read.</TD></TR>
  <TR vAlign=top>
    <TD>IMAX</TD>
    <TD>R</TD>
    <TD>"Max. size of input array"</TD>
    <TD>DBF_LONG</TD>
    <TD>The allocated length of the BINP array. This value cannot be changed 
      after IOC initialization. Default=512.</TD></TR>
  <TR vAlign=top>
    <TD>NRRD</TD>
    <TD>R/W</TD>
    <TD>"Number of bytes to read"</TD>
    <TD>DBF_LONG</TD>
    <TD>The requested number of bytes to read. This field is valid for all IFMT
      modes. If this field is &lt;= 0, then the 
      requested number of bytes to read will be the EPICS defined 
      MAX_STRING_SIZE=40 (if IFMT="ASCII") or IMAX (if IFMT=&quot;Hybrid&quot;
      or &quot;Binary&quot;). 
    Default=0.</TD></TR>
  <TR vAlign=top>
    <TD>NORD</TD>
    <TD>R</TD>
    <TD>"Number of bytes read"</TD>
    <TD>DBF_LONG</TD>
    <TD>The actual number of bytes read in the last read operation. This field 
      is valid for IFMT modes. This number includes 
      the input terminator, if any.</TD></TR>
  <TR vAlign=top>
    <TD>IFMT</TD>
    <TD>R/W</TD>
    <TD>"Input format"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The input format. The choices are: 
      <TABLE>
        <TBODY>
        <TR vAlign=top>
          <TD>"ASCII" (default)</TD>
          <TD>The data read from the device will be placed in the AINP 
          field.</TD></TR>
        <TR vAlign=top>
          <TD>&quot;Hybrid&quot;</TD>
          <TD>The data read from the device will be placed in the BINP field.</TD></TR>
        <TR vAlign=top>
          <TD>"Binary"</TD>
          <TD>The data read from the device will be placed in the BINP 
          field.</TD></TR></TBODY></TABLE></TD></TR>
</TABLE>
<P>There are two input 
fields, AINP (ASCII Input) and BINP (Byte Input). The IFMT (Input Format) 
field is used to select one or the other as the destination of data sent from 
the serial device. 
<P>A read operation on input continues until 1 of the following 4 conditions is 
met: 
<OL>
  <LI>The input terminator (IEOS) is found
  <LI>EOI asserted (GPIB only) 
  <LI>The desired number of input characters (NRRD) are received 
  <LI>The timeout (TMOT) expires </LI></OL>
<P>If IFMT=&quot;ASCII&quot; then the IEOS field is processed
with dbTranslateEscape() to convert control characters (e.g. &quot;\r&quot;,
&quot;\021&quot;) to bytes, and the asyn input terminator is set to this
string.&nbsp; The input is read into the AINP field. The input terminator
string, if present, is removed from AINP after the read, and AINP will be null
terminated. 
<P>If IFMT=&quot;Hybrid&quot; then the IEOS field is processed
with dbTranslateEscape() to convert control characters (e.g. &quot;\r&quot;,
&quot;\021&quot;) to bytes, and the asyn input terminator is set to this
string.&nbsp; The input is read into the BINP field. The input terminator
string, if present, is removed from BINP after the read, and BINP will be null
terminated. 
<P>If IFMT=&quot;Binary&quot; then the IEOS field is ignored, and no asyn input
terminator is used.&nbsp; The input is read into the BINP field. BINP will be
null terminated.
<p>&nbsp;</p>
<HR>

<h2 align="center">Serial Control Fields</h2>

<TABLE cellPadding=5 border=1>
  <TR vAlign=top>
    <TD>BAUD</TD>
    <TD>R/W</TD>
    <TD>"Baud rate"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The baud rate for the port. Choices are "300", "600", "1200", "2400", 
      "4800", "9600", "19200", and "38400". Default="9600".</TD></TR>
  <TR vAlign=top>
    <TD>PRTY</TD>
    <TD>R/W</TD>
    <TD>"Parity"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The device parity. Choices are "None", "Even", and "Odd". 
      Default="None".</TD></TR>
  <TR vAlign=top>
    <TD>DBIT</TD>
    <TD>R/W</TD>
    <TD>"Data bits"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The number of data bits. Choices are "5", "6", "7", and "8". 
      Default="8".</TD></TR>
  <TR vAlign=top>
    <TD>SBIT</TD>
    <TD>R/W</TD>
    <TD>"Stop bits"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The number of stop bits. Choices are "1" and "2". Default="1".</TD></TR>
  <TR vAlign=top>
    <TD>FCTL</TD>
    <TD>R/W</TD>
    <TD>"Flow control"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The flow control. Choices are "None" and "Hardware". 
  Default="None".</TD></TR>
</TABLE>
<P>
 The above fields are used to set the serial port 
      parameters. A write to any of these fields causes the port parameters to 
      be changed immediately, but does not cause the record to process.&nbsp;
The port parameters can currently be set only for local serial ports, including
IP-Octal on vxWorks.&nbsp; They cannot currently be set for Ethernet/serial
adapters like the Moxa units. 
<P>
&nbsp;
<HR>

<TABLE cellPadding=5 border=1><A name=Fields>
  <CAPTION>
  <H2>Record Field Descriptions</H2></CAPTION></A>
  <TBODY>
  <TR>
    <TH>Name</TH>
    <TH>Access</TH>
    <TH>Prompt</TH>
    <TH>Data type</TH>
    <TH>Description</TH></TR>
  <TR vAlign=top>
    <TH colSpan=5>Special Fields</TH></TR>
  <TR vAlign=top>
    <TD colSpan=5>Note: The following fields are used to set the serial port 
      parameters. A write to any of these fields causes the port parameters to 
      be changed immediately, but does not cause the record to process.</TD></TR>
  <TR vAlign=top>
    <TH colSpan=5>Private Fields</TH></TR>
  <TR vAlign=top>
    <TD>IPTR</TD>
    <TD>N</TD>
    <TD>"Input buffer pointer"</TD>
    <TD>DBF_NOACCESS</TD>
    <TD>The pointer to the buffer for the BINP field.</TD></TR>
  <TR vAlign=top>
    <TD>OPTR</TD>
    <TD>N</TD>
    <TD>"Output buffer pointer"</TD>
    <TD>DBF_NOACCESS</TD>
    <TD>The pointer to the buffer for the BOUT field.</TD></TR>
  <TR vAlign=top>
    <TD align=left colSpan=5>
      <TABLE>
        <TBODY>
        <TR>
          <TD colSpan=3>Note: In the Access column above: </TD>
        <TR vAlign=top>
          <TD>R</TD>
          <TD>Read only
          <TD></TD>
        <TR vAlign=top>
          <TD>R/W</TD>
          <TD>Read and write are allowed</TD></TR>
        <TR vAlign=top>
          <TD>R/W*</TD>
          <TD>Read and write are allowed; write triggers record processing if 
            the record's SCAN field is set to "Passive".</TD></TR>
        <TR vAlign=top>
          <TD>N</TD>
          <TD>No access allowed</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<HR>

<P><A name=Files>
<H2>Files</H2></A>The following table briefly describes all of the files 
required to implement the asynOctet record. The reader is assumed to be familiar 
with the <A 
href="http://www.aps.anl.gov/asd/controls/epics/EpicsDocumentation/AppDevManuals/iocAppBuildSRcontrol.html">EPICS 
Application Source/Release Control document</A> which describes how to build an 
EPICS application tree into which these files are to be placed, and how to run 
"gnumake" to build the record support. These files can all be obtained in a <A 
href="http://cars9.uchicago.edu/software/epics/pub/serial_record.tar.Z">compressed 
tar file</A>. This file should be untarred in a <CODE>&lt;top&gt;/xxxApp/</CODE> 
directory. 
<P>
<TABLE cellPadding=5 border=1>
  <TBODY>
  <TR>
    <TH colSpan=2>Files to be placed in <CODE>&lt;top&gt;/xxxApp/src/</CODE> 
    </TH></TR>
  <TR vAlign=top>
    <TD>serialRecord.c</TD>
    <TD>The source file for the record</TD></TR>
  <TR>
    <TD>serialRecord.dbd</TD>
    <TD>The database definition file for the record</TD></TR>
  <TR>
    <TD>devSerial.cc</TD>
    <TD>The Hideos device support code for the record</TD></TR>
  <TR vAlign=top>
    <TD>Makefile.Vx</TD>
    <TD>This file is not included in the distribution. However, the user must 
      edit this file and add lines similar to the following: <PRE>RECTYPES += serialRecord.h
SRCS.c   += ../serialRecord.c 
SRCS.c   += ../devSerial.cc
LIBOBJS  += serialRecord.o
LIBOBJS  += devSerial.o
USR_INCLUDES += -I$(HIDEOS_DIR)/include

</PRE></TD></TR>
  <TR>
    <TH colSpan=2>Files to be placed in 
      <CODE>&lt;top&gt;/xxxApp/op/adl/</CODE> </TH></TR>
  <TR vAlign=top>
    <TD>asynOctet_IO.adl</TD>
    <TD>This file builds an <CODE>medm</CODE> screen to access the asynOctet record. The <CODE>medm</CODE> screen is most useful for communicating with 
      serial devices in ASCII. To use it from the command line, type the 
      following: <PRE>cars&gt; medm -x -macro REC=my_serial_record Serial_IO.adl
</PRE>
      <P>where <CODE>my_serial_record</CODE> is the name of a asynOctet record in 
      an IOC. 
      <P>This file can also be used as a related display from other 
      <CODE>medm</CODE> screens by passing the argument 
      <CODE>REC=my_serial_record</CODE>. </P></TD></TR></TBODY></TABLE>
<HR>
<A name=Restrictions>
<H2>Restrictions</H2></A>There should be a way to optionally force the input 
ring buffer to be flushed on a "Read" operation, as it is on "Write/Read". This 
may be added in the future.
<p>The HiDEOS device support permits I/O Event Scanning (SCAN="I/O Intr&quot;) when 
the transfer mode (TMOD) is "Read". In this case the record will be processed 
whenever a complete message is received. A complete message is defined by the 
input delimiter (IDEL) and/or the requested number of input characters (NRRD), 
being received. The timeout field (TMOT) does not apply when SCAN="I/O Intr&quot;. 
For more information see the note under <A 
href="http://cars9.uchicago.edu/software/epics/serialRecord.html#Restrictions">Restrictions</A> 
below.</p>
<P>There are two bugs in the HiDEOS device support when using I/O Event 
Scanning. If the SCAN field is changed from "I/O Intr" to any other value then 
the record will "hang-up" until at least one more input message is received. The 
reason for this is that "I/O Intr" scanning is implemented by passing a HiDEOS 
"Read" request with infinite time out. There is presently no way to abort this 
request, and the HiDEOS task will wait until the request is satisfied. The 
second bug is that specifying an infinite timeout actually does not work, so the 
record actually requests 10^9 milliseconds = 1 million seconds. Thus, in I/O 
Event Scanning mode the record will actually time out about every 10 days if the 
device does not send any messages. Both of these bugs should be fixed in the 
near future. 
<P>The HiDEOS input ring buffer is limited to 500 characters. This is thus an 
upper limit on the maximum message size which can be received. If a device sends 
a larger message it will need to be read by processing the record multiple 
times. This will probably require using flow control. 
<HR>
<A name=Release>
<H2>Release Notes</H2></A>
<UL>
  <LI>Version 1.0, March 1996. Initial release for R3.12 by Mark Rivers. 
  <LI>Version 1.1, December 1997. Conversion to EPICS R3.13 by Tim Mooney. 
</LI></UL>
<HR>
<A name=Example>
<H2>Example</H2></A>The following is an IDL program which demonstrates the use 
of the asynOctet record. It transfers data in both ASCII and binary formats. <PRE>; This IDL program demonstrates the use of the EPICS asynOctet record.
; The program uses 2 serial records.  The ports corresponding to these
; 2 records are connected with a null-modem cable
; Record 1 sends a message to record 2 in ASCII.
; Record 2 sends a message back to record 1 in binary.

; Record names
rec1 = 'test_serial1'
rec2 = 'test_serial2'
recs = [rec1, rec2] ; Array with both record names
; Set up port parameters for both records:
;   19,200 baud, 8 data bits, 1 stop bit, no parity, no flow control
;   Timeout=1 second
castartgroup
for i=0, 1 do begin
    rec = recs(i)
    t = caput(rec+'.BAUD', '19200')
    t = caput(rec+'.DBIT', '8')
    t = caput(rec+'.SBIT', '1')
    t = caput(rec+'.PRTY', 'None')
    t = caput(rec+'.FCTL', 'None')
    t = caput(rec+'.TMOT', 1000)
endfor

; Put record 1 in ASCII output mode, &lt;CR&gt; output delimiter,
;   binary input mode, no input delimiter
t = caput(rec1+'.OFMT', 'ASCII')
t = caput(rec1+'.ODEL', 13)
t = caput(rec1+'.IFMT', 'Binary')
t = caput(rec1+'.IDEL', -1)
; Put a monitor on record 1 Binary input field
t = casetmonitor(rec1+'.BINP')

; Put record 2 in Binary output mode, no output delimiter
;   ASCII input mode, &lt;CR&gt; input delimiter
t = caput(rec2+'.OFMT', 'Binary')
t = caput(rec2+'.ODEL', -1)
t = caput(rec2+'.IFMT', 'ASCII')
t = caput(rec2+'.IDEL', 13)

; Put record 2 in read transfer mode
t = caput(rec2+'.TMOD', 'Read')
; Put a monitor on record2 ASCII input field
t = casetmonitor(rec2+'.AINP')
; Process record 2; this will cause it to wait for data
t = caput(rec2+'.PROC', 1)

; Put record 1 in write transfer mode
t = caput(rec1+'.TMOD', 'Write')
; Send a message to port 2
message = 'Request data: '+string(systime())
print, 'Record 1 sent message: ' + message
t = caput(rec1+'.AOUT', message)
; End the group - this causes all of the above channel access
; commands to actually be sent to the IOC
t = caendgroup()


; Wait for monitor on record2 ASCII input field
while (not cacheckmonitor(rec2+'.AINP')) do wait, .1
; Read data from record 2
t = caget(rec2+'.AINP', input)
print, 'Got a message from record 1: ', input

castartgroup
size=256
; Put record 1 in read mode, expect &quot;size&quot; byte input
t = caput(rec1+'.TMOD', 'Read')
t = caput(rec1+'.NRRD', size)
; Process record 1; this will cause it to wait for data
t = caput(rec1+'.PROC', '1')

; Put record 2 in write mode
t = caput(rec2+'.TMOD', 'Write')
; Send an 8 bit binary sin wave, &quot;size&quot; points long from
; port 2 to port 1
send_data = byte(sin(findgen(size)/5)*126 + 127)
t = caput(rec2+'.NOWT', size)
t = caput(rec2+'.BOUT', send_data)
t = caendgroup()

; Wait for monitor on channel 1 binary input
while (not cacheckmonitor(rec1+'.BINP')) do wait, .1

; Record 1 should have received &quot;size&quot; bytes. Make sure NORD=size
t = caget(rec1+'.NORD', nord)
if (nord eq size) then $
    print, 'Read array data OK' $
else $
    print, 'Error reading array data!'

; Read data from record 1
t = caget(rec1+'.BINP', rec_data, max=nord)

; Plot it
plot, rec_data

end
</PRE>
<HR>

<ADDRESS>Suggestions and comments to: <A 
href="mailto:rivers@cars.uchicago.edu">Mark Rivers </A>: 
(rivers@cars.uchicago.edu) <BR>Last modified: December 14, 1997 
</ADDRESS></BODY></HTML>
