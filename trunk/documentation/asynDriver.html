<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <title>asynDriver</title>
  <meta name="GENERATOR" content="amaya 5.1" />
</head>

<body>

<center>
<h1>Asynchronous Driver Support</h1>

<p>Marty Kraimer, Benjamin Franksen, Pete Owens, Eric Norum, and Dirk
Zimoch</p>

<p>July 18, 2003</p>
</center>

<center>
<h2>Goal</h2>
</center>

<p><span style="font-weight: bold">asynDriver is a general purpose
facility</span><span style="font-weight: bold">for interfacing device
specific code to low level communication drivers</span>.</p>

<p>A primary target for asynDriver is EPICS IOC device support but, other
than using libCom, it is independent of EPICS IOC support.</p>

<p>The plan is:</p>
<ul>
  <li>Provide a facility that could be used by gpibCore, streams,
    devAscii/drvAscii, devOnrl, and mpfSerial. 
    <ul>
      <li>Each would have to be modified so that the device support component
        is compatible with existing uses but replace the driver part with
        asynDriver.</li>
      <li>The benefit is that all could share the same set of low level
        drivers.</li>
    </ul>
  </li>
  <li>Initially support the following communication protocals 
    <ul>
      <li>gpib</li>
      <li>vxi11</li>
      <li>serial, i.e. RS232,, etc.</li>
    </ul>
  </li>
  <li>In the future support other protocals especially for ethernet based
    devices.</li>
</ul>

<h3>NOTES:</h3>
<ul>
  <li>gpibCore is the Operating System Independent version of the
    Winans/Franksen gpib support.</li>
  <li>streams is the protocal file based support for serial/gpib/can from
    Dirk Zimoch.</li>
  <li>devAscii/drvAscii is support from KECK Observatory.</li>
  <li>devOnrl is the support from John Sinclair at Oak Ridge National
  Lab.</li>
  <li>mpfSerial is the serial support provided with MPF (Message Passing
    Facility)</li>
</ul>

<h3>Statement</h3>

<p>At the present time each of the systems mentioned above are used at EPICS
facilities for accessing gpib and/or serial devices. Because lots of existing
device support and thousands of database records use the above support, users
will not be easily persuaded to switch from their existing solution. Thus
what is proposed is to implement a framework below the device support level
that can be used by all of the above systems so that all can share the same
drivers.</p>

<center>
<h2>Overview of asynDriver support</h2>
</center>

<p>Multiple layers can exist between the asynchronous driver support and an
actual low level driver. For drivers that register directly with the
asynQueueManager, a process module can be registered with the queue manager.
Just like a driver a process module implements interfaces. The queue manager
findDriver method looks first for process module interfaces and then for
driver interfaces. A process module normally calls drivers as part of it's
processing. For more complicated protocals additional layers can be created.
For example gpib support is implemented as a gpibDriverUser interface which
is called by user code and a gpibDriver interface which is called by
gpibDriverUser.</p>

<p>A driver can implement multiple interfaces. For example gpib implements
asynDriver, octetDriver, and gpibDriverUser.</p>

<p>Asynchronous driver support uses the Operating System Independent features
of EPICS base. It is, however, independent of record/device support. Thus it
can be used by other code, e.g. a sequence program.</p>

<h3>Asynchronous Driver Components</h3>
<ul>
  <li><span style="font-weight: bold">asynQueueManager</span> 
    <p>Provides the following services.</p>
    <ul>
      <li>A thread for each communication interface.</li>
      <li>queueRequest. This is a non-blocking method, i.e. it can be called
        from scan threads. A callback specified by the user is called by the
        interface thread. The user callback can then make an arbitray number
        of calls to the driver. These calls may be blocking calls.</li>
      <li>It provides a transaction service, i.e. user code can lock out
        other users while it makes multiple queueRequests.</li>
    </ul>
  </li>
  <li><span style="font-weight: bold">asynDriver</span> 
    <p>asynDriver is a set of methods that must be implemented by all
    drivers.</p>
  </li>
  <li><span style="font-weight: bold">octetDriver</span> 
    <p>octetDriver is a set of methods implemented by any driver that accepts
    octet messages (messages consisting of 8 bit bytes) and returns octet
    responses. This interface will be sufficient for lots of device specific
    code. For example the code for streams protocal files needs only this
    interface. The term octet is used instead of ascii because the only
    requirement is messages consist of 8 bit bytes.</p>
  </li>
</ul>

<h3>Overview of implementation</h3>

<p>During initialization a driver registers each hardware interface with
asynQueueManager.</p>

<p>User code connects to a combination of asynQueueManager and one or more
drivers.This determines the methods it can call.</p>

<p>User code communicates with drivers via the following method:</p>
<ol>
  <li>It calls: 
    <pre> pasynQueueManager-&gt;queueRequest(...)</pre>
  </li>
  <li>The callback specified in queueRequest calls the driver.</li>
</ol>

<h3>Comments:</h3>
<ol>
  <li>Streams, devAscii, and mpfSerial need only asynQueueManager and
    octetDriver. gpibCore needs only asynQueueManager octetDriver, and
    gpibDriverUser.</li>
  <li>It is expected that most users will connect to these interfaces via
    device support. However other code can call it. Examples are sequence
    programs, test programs,utility commands, etc.</li>
  <li>It is expected that for some devices, support will consist of more than
    one type of support. For example most functions could be accessed via
    steams but gpibDriverUser could be used to handle unsollicited SRQs.</li>
</ol>

<center>
<h2>asynDriver</h2>
</center>

<h3>asynDriver.h</h3>

<p>Include file asynDriver.h contains the following definitions:</p>
<pre>typedef struct asynPvt asynPvt;
typedef enum {
    asynSuccess,asynTimeout,asynError
}asynStatus;

typedef enum {
    asynQueuePriorityLow,asynQueuePriorityMedium,asynQueuePriorityHigh
}asynQueuePriority;

typedef enum {
    asynTimoutFirst, /*timeout for first input character.*/
    asynTimoutRead,
    asynTimeoutWrite
}asynTimeoutType;

typedef void (*userCallback)(void *puserPvt);

typedef struct asynUser {
    char *errorMessage;
    int errorMessageSize;
    double timeout;  /*Timeout for I/O operations*/
    void *puserPvt;
}asynUser;

typedef void (*peekHandler)(void *puserPvt,
    char byte,int isReceive,int gotEOI);

typedef struct driverInterface{
    const char *driverType;
    void *pinterface;
}driverInterface;

typedef struct deviceDriver{
    driverInterface *pdriverInterface;
    void *pdrvPvt;
}deviceDriver;

typedef struct asynQueueManager {
    void (*report)(int details);
    asynUser  *(*createAsynUser)(
        userCallback queue,userCallback timeout,void *puserPvt);
    asynStatus (*freeAsynUser)(asynUser *pasynUser);
    asynStatus (*connectDevice)(asynUser *pasynUser, const char *deviceName);
    asynStatus (*disconnectDevice)(asynUser *pasynUser);
    deviceDriver *(*findDriver)(asynUser *pasynUser,
        const char *driverType,int processModuleOK);
    asynStatus (*queueRequest)(asynUser *pasynUser,
        asynQueuePriority priority,double timeout);
    void (*cancelRequest)(asynUser *pasynUser);
    asynStatus (*lock)(asynUser *pasynUser);
    asynStatus (*unlock)(asynUser *pasynUser);
    /* drivers call the following*/
    asynStatus (*registerDevice)(
        const char *deviceName,
        deviceDriver *padeviceDriver,int ndeviceDrivers,
        unsigned int priority,unsigned int stackSize);
    /*process modules call the following */
    asynStatus (*registerProcessModule)(
        const char *processModuleName,const char *deviceName,
        deviceDriver *padeviceDriver,int ndeviceDrivers);
}asynQueueManager;
epicsShareExtern asynQueueManager *pasynQueueManager;

/*Methods supported by ALL asyn drivers*/
#define asynDriverType "asynDriver"
typedef struct  asynDriver {
    void       (*report)(void *pdrvPvt,asynUser *pasynUser,int details);
    /*following are to connect/disconnect to/from hardware*/
    asynStatus (*connect)(void *pdrvPvt,asynUser *pasynUser);
    asynStatus (*disconnect)(void *pdrvPvt,asynUser *pasynUser);
}asynDriver;

/* Methods supported by low level octet drivers. */
#define octetDriverType "octetDriver"
typedef struct octetDriver{
    int        (*read)(void *pdrvPvt,asynUser *pasynUser,int addr,char *data,int maxchars);
    int        (*write)(void *pdrvPvt,asynUser *pasynUser,
                        int addr,const char *data,int numchars);
    asynStatus (*flush)(void *pdrvPvt,asynUser *pasynUser,int addr);
    asynStatus (*setTimeout)(void *pdrvPvt,asynUser *pasynUser,
                             asynTimeoutType type,double timeout);
    asynStatus (*setEos)(void *pdrvPvt,asynUser *pasynUser,
                         const char *eos,int eoslen);
    asynStatus (*installPeekHandler)(void *pdrvPvt,asynUser *pasynUser,
                                    peekHandler handler);
    asynStatus (*removePeekHandler)(void *pdrvPvt,asynUser *pasynUser);
}octetDriver;</pre>

<h3>asynUser</h3>

<p>asynUser describes a structure that user code must provide for most
asynQueueManager and driver methods. Code must allocate and free an asynUser
by calling asynUserCalloc and asynUserFree.</p>

<table border="1">
  <caption>asynUser</caption>
  <tbody>
    <tr>
      <td>errorMessage</td>
      <td>When either asynQueueManager or a driver returns a
        status!=asynSuccess it can also put an error message into
        errorMessage. They should do this via a call to 
        <pre>epicsSnprintf(pasynUser-&gt;errorMessage,pasynUser-&gt;errorMessageSize,"&lt;format&gt;",...)</pre>
      </td>
    </tr>
    <tr>
      <td>errorMessageSize</td>
      <td>The size of errorMessage. asynQueueManager determines this. It can
        not be changed.</td>
    </tr>
    <tr>
      <td>timeout</td>
      <td>The number of seconds before timeout for I/O requests.</td>
    </tr>
    <tr>
      <td>puserPvt</td>
      <td>For use by the user. This can be specified on the call to
        asynUserCalloc and should never be changed.</td>
    </tr>
  </tbody>
</table>

<h3>asynQueueManager</h3>

<p>asynQueueManager describes the asynQueueManager methods.</p>

<table border="1">
  <caption>asynQueueManager</caption>
  <tbody>
    <tr>
      <td>report</td>
      <td>Reports status about the asynQueueManager. It in turn calls
        asynDriver report.</td>
    </tr>
    <tr>
      <td>createAsynUser</td>
      <td>Creates an asynUser. The caller specifies two callbacks, one for
        successful queueRequests and one if a queueRequest has a timeout. The
        timeout callback is optional. The caller also specifies puserPvt.
        errorMessageSize characters are allocated for errorMessage. The
        amount of storage can not be changed. This method doesn't return if
        it is unable to allocate the storage.</td>
    </tr>
    <tr>
      <td>freeAsynUser</td>
      <td>Free an asynUser. The user must free it only via this call. The
        call will fail if the asynUser is queued or locked or connected to a
        device.</td>
    </tr>
    <tr>
      <td>connectDevice</td>
      <td>User level code calls this at initialization to connect to a
        communication interface.. It passes the name of the device. This is
        the name specified in the call to registerDevice. If processModuleOK
        is true and a processModule is reqistered for the device and
        driverType then it's deviceDriver is returned; otherwise the
        deviceDriver of the actual device driver is returned.</td>
    </tr>
    <tr>
      <td>disconnectDevice</td>
      <td>Disconnect. If the asynUser is queued or locked this request will
        fail.</td>
    </tr>
    <tr>
      <td>findDriver</td>
      <td>Find a driver interface. It returns the address of a deviceDriver
        or 0 if the driverType is not supported. The user will need the
        address of the drivers interface and the address of pdrvPvt so that
        calls can be made to the driver. For example: 
        <pre>deviceDriver *pdeviceDriver;
octetDriver *poctetDriver;
void *poctetDriverPvt;
...
pdeviceDriver = pasynQueueManager-&gt;findDriver(
        pasynUser,octetDriverType,1);
if(!pdeviceDriver) { /*error do something*/}
poctetDriver = (octetDriver *)pdeviceDriver-&gt;pdriverInterface-&gt;pinterface;
poctetDriverPvt = pdeviceDriver-&gt;pdrvPvt;
...
poctetDriver-&gt;read(poctetDriverPvt,pasynUser,...
        </pre>
      </td>
    </tr>
    <tr>
      <td>queueRequest</td>
      <td>User code never calls a driver directly. Instead it calls
        queueRequest. After the thread associated with the driver takes this
        request from the queue, it calls the user's callback. The callback
        makes calls to the driver. If the user attempts to call queueRequest,
        but the asynUser is already on a queue, asynError is returned. The
        timeout is from when the request is queued until it is taken from the
        queue. A value less than or equal to 0.0 means no timeout.</td>
    </tr>
    <tr>
      <td>cancelRequest</td>
      <td>If a asynUser is queued remove it from the queue. If it is not on a
        queue nothing is done. In particular if the callback is active, this
        call has no effect.</td>
    </tr>
    <tr>
      <td>lock/unlock</td>
      <td>lock/unlock are used to block other users from calling a driver
        while a user is making a series of queueRequest calls. After a call
        is made to lock, asynQueueManager locks as soon as the first
        queueRequest with the specified lock is taken from the queue. At that
        point all other entries in the queue must wait until unlock is
        called. These methods fail if a request is currently queued.</td>
    </tr>
    <tr>
      <td>registerDevice</td>
      <td>This method is called by drivers. A call is made for each
        communication interface instance.</td>
    </tr>
    <tr>
      <td>registerProcessModule</td>
      <td>This method is called by a process manager, i.e. code that wants to
        be called instead of the low level driver itself. Normally it adds
        additional functionality to the low level driver, It in turn normally
        calls the low level driver. It must be called after the driver calls
        registerDriver and before the client code calls findDriver.</td>
    </tr>
  </tbody>
</table>

<h3>asynDriver</h3>

<p>asynDriver describes the methods provided by all drivers.</p>

<table border="1">
  <caption>asynDriver</caption>
  <tbody>
    <tr>
      <td>report</td>
      <td>Generates a report about the hardware device.</td>
    </tr>
    <tr>
      <td>connect</td>
      <td>Connect to the hardware device or communication path. This is
        called by asynQueueManager after the driver has called
        registerDriver. It may also be called by command utilities that first
        call disconnect and then connect.</td>
    </tr>
    <tr>
      <td>disconnect</td>
      <td>Disconnect from the hardware device. This is normally called by
        command utilities that want to stop and then restart communication to
        a device.</td>
    </tr>
  </tbody>
</table>

<h3>octetDriver</h3>

<p>NOTES:</p>
<ul>
  <li>This is just a guess at what methods octetDriver should provide.</li>
  <li>The name octet is used instead of ascii because it implys that
    communication is done via 8 bit characters.</li>
</ul>

<p>octetDriver describes the methods provided by drivers that use octet
strings for sending commands and receiving responses from a device.</p>

<table border="1">
  <caption>octetDriver</caption>
  <tbody>
    <tr>
      <td>read</td>
      <td>Read a message from the device.</td>
    </tr>
    <tr>
      <td>write</td>
      <td>Send a message to the device.</td>
    </tr>
    <tr>
      <td>flush</td>
      <td>Flush the input buffer.</td>
    </tr>
    <tr>
      <td>setTimeout</td>
      <td>Specify timeouts</td>
    </tr>
    <tr>
      <td>setEos</td>
      <td>Specify end of string characters</td>
    </tr>
    <tr>
      <td>installPeekHandler</td>
      <td>Install a peek handler. When a peek handler is installed then the
        driver calls the peekHandler for every byte it send or receives.</td>
    </tr>
    <tr>
      <td>removePeekHandler</td>
      <td>Remove the peek handler</td>
    </tr>
  </tbody>
</table>

<center>
<h2>Discussion of asynDriver</h2>
</center>

<p>File asynDriver.h describes four structures:</p>
<ul>
  <li>asynUser - Structure for interfacing between user code and
    asynQueueManager or drivers.</li>
  <li>driverInterface and deviceDriver - Structures for registering and
    location driver interfaces and a pdrvPvt.</li>
  <li>asynQueueManager - Interface describing the asynQueueManager
  methods.</li>
  <li>asynDriver - Interface describing methods implemented by all
  drivers</li>
  <li>octetDriver - Interface describing methods implemented by all drivers
    that handle octet messages</li>
</ul>

<p>The following is the skeleton for code that communicates with a device via
octet messages..</p>
<pre>#include &lt;asynDriver.h&gt;
...
#define BUFSIZE 80
typedef struct myData {
    asynUser    *pasynUser;
    octetDriver *poctetDriver;
    void *pdrvPvt;
    char buffer[BUFSIZE];
}myData;

void queueCallback(userPvt *puserPvt)
    myData *pmydata = (myData *)puserPvt;
    octetDriver *poctetDriver = pmydata-&gt;poctetDriver;
    asynUser *pasynUser = pmydata-&gt;pasynUser;
    asynStatus status;
    int retlen;


    status = poctetDriver-&gt;setEos(pmyData-&gt;pdrvPvt,pasynUser,"\n",1);
    if(status) {
        printf("queueCallback setEos failed %s\n",pasynUser-&gt;errorMessage);
    }
    retlen = poctetDriver-&gt;read(pmyData-&gt;pdrvPvt,pasynUser,0,pmydata-&gt;buffer,BUFSIZE);
    if(retlen&lt;=0) {
        printf("queueCallback read failed %s\n",pasynUser-&gt;errorMessage);
    } else {
        printf("queueCallback read returned: retlen %d data %s\n",
            retlen,pmydata-&gt;buffer);
    }
}

void mainThread(void)
{
    myData *pmyData;
    asynUser *pasynUser;
    asynStatus status;
    deviceDriver *pdeviceDriver;

    pmyData = calloc(1,sizeof(myData));
    pasynUser = pasynQueueManager-&gt;createAsynUser(queueCallback,0,pmyData);
    pmyData-&gt;pasynUser = pasynUser;
    status = pasynQueueManager-&gt;connectDevice(pasynUser,"serialPort1")
    if(status) {
        printf("can't connect to serialPort1 %s\n",pasynUser-&gt;errorMessage);
        exit(1);
    }
    pdeviceDriver = (octetDriver *)pasynQueueManager-&gt;findDriver(
        pasynUser,octetDriverType,1);
    if(!pdeviceDriver) {
        printf("%s driver not supported\n",octetDriverType);
        exit(-1);
    }
    pmyData-&gt;poctetDriver = (octetDriver *)pdeviceDriver-&gt;pdriverInterface-&gt;pinterface;
    pmyData-&gt;pdrvPvt = pdeviceDriver-&gt;pdrvPvt;
    status = pasynQueueManager-&gt;queueRequest(pasynUser,asynQueuePriorityLow, 0.0);
    if(status) {
        printf("queueRequest failed %s\n",pasynUser-&gt;errorMessage);
        exit(1);
    }
    /*Note that callback will be called by another thread*/
    ...
}</pre>

<p>The flow of control is as follows:</p>
<ol>
  <li>A driver registers itself to asynQueueManager.</li>
  <li>mainThread allocates myData and an asynUser.</li>
  <li>mainThread connects to a a device and to a driver for that device.</li>
  <li>When it is ready to communicate with the driver it calls
  queueRequest.</li>
  <li>The thread associated with the device calls queueCallback.</li>
  <li>queueCallback calls the driver's setEos and read methods.</li>
</ol>

<center>
<h2>gpibDriver</h2>
</center>

<p>NOTE: This definition is based on the features gpibCore provides.</p>

<p>gpibDriver is an example of how complicated support can be structured. It
defines two interfaces.</p>
<ul>
  <li>gpibDriverUser - This is the interface that user code uses. It provides
    the following: 
    <ul>
      <li>A set of gpib specific methods that user code can call.</li>
      <li>Code that handles generic GPIB functions like SRQ polling.</li>
    </ul>
  </li>
  <li>gpibDriver - A set of methods implemented by gpib drivers</li>
</ul>

<h3>gpibDriver.h</h3>

<p>Include file gpibDriver.h contains the following definitions:</p>
<pre>#include "asynDriver.h"

#define gpibDriverUserType "gpibDriverUser"
/* GPIB drivers */
typedef void (*srqHandler)(void *userPrivate,int gpibAddr,int statusByte);
typedef struct gpibDriverUser{
    /* The following are called by gpib aware users*/
    asynStatus (*registerSrqHandler)(void *pdrvPvt,asynUser *pasynUser,
        srqHandler handler, void *userPrivate);
    asynStatus (*addressedCmd) (void *pdrvPvt,asynUser *pasynUser,
        int addr, const char *data, int length);
    asynStatus (*universalCmd) (void *pdrvPvt,asynUser *pasynUser, int cmd);
    asynStatus (*ifc) (void *pdrvPvt,asynUser *pasynUser);
    asynStatus (*ren) (void *pdrvPvt,asynUser *pasynUser, int onOff);
    void (*pollAddr)(void *pdrvPvt,asynUser *pasynUser,int addr, int onOff);
    void (*srqProcessing)(void *pdrvPvt,asynUser *pasynUser, int onOff);
    void (*srqSet)(void *pdrvPvt,asynUser *pasynUser,
        double srqTimeout,double pollTimeout,double pollRate,
        int srqMaxEvents);
    void (*srqGet)(void *pdrvPvt,asynUser *pasynUser,
        double *srqTimeout,double *pollTimeout,double *pollRate,
        int *srqMaxEvents);
    /* The following are called by low level gpib drivers */
    void *(*registerDriver)(void *pdrvPvt,const char *name);
    void (*srqHappened)(void *pdrvPvt); /*pvt is gpibDriverUser pvt*/
}gpibDriverUser;

typedef struct gpibDriver {
    void (*report)(void *pdrvPvt,asynUser *pasynUser,int details);
    void (*connect)(void *pdrvPvt,asynUser *pasynUser);
    void (*disconnect)(void *pdrvPvt,asynUser *pasynUser);
    /*octetDriver methods */
    int (*read)(void *pdrvPvt,asynUser *pasynUser,int addr,char *data,int maxchars);
    int (*write)(void *pdrvPvt,asynUser *pasynUser,
                        int addr,const char *data,int numchars);
    asynStatus (*flush)(void *pdrvPvt,asynUser *pasynUser,int addr);
    asynStatus (*setEos)(void *pdrvPvt,asynUser *pasynUser,const char *eos,int eoslen);
    asynStatus (*installPeekHandler)(void *pdrvPvt,asynUser *pasynUser,peekHandler handler);
    asynStatus (*removePeekHandler)(void *pdrvPvt,asynUser *pasynUser);
    /*gpibDriver methods*/
    asynStatus (*registerSrqHandler)(void *pdrvPvt,asynUser *pasynUser,
        int addr, srqHandler handler, void *userPrivate);
    asynStatus (*addressedCmd) (void *pdrvPvt,asynUser *pasynUser,
        int addr, char *data, int length);
    asynStatus (*universalCmd) (void *pdrvPvt, asynUser *pasynUser, int cmd);
    asynStatus (*ifc) (void *pdrvPvt,asynUser *pasynUser);
    asynStatus (*ren) (void *pdrvPvt,asynUser *pasynUser, int onOff);
    int (*srqStatus) (void *pdrvPvt);
    asynStatus (*srqEnable) (void *pdrvPvt, int onOff);
    asynStatus (*serialPollBegin) (void *pdrvPvt);
    int (*serialPoll) (void *pdrvPvt, int addr, double timeout);
    asynStatus (*serialPollEnd) (void *pdrvPvt);
}gpibDriver;
</pre>

<h3>gpibDriverUser</h3>

<p>gpibDriverUser describes the interface for user code. It provides gpib
specific functions like SRQ handling. It makes calls to a gpibDriver. Note
that the gpib user support also implements the asynDriver and octetDriver
interraces.</p>

<table border="1">
  <caption>gpibDriverUser</caption>
  <tbody>
    <tr>
      <td>registerSrqHandler</td>
      <td>Just passes the call to the low level driver.</td>
    </tr>
    <tr>
      <td>addressedCmd</td>
      <td>Just passes the call to the low level driver.</td>
    </tr>
    <tr>
      <td>universalCmd</td>
      <td>Just passes the call to the low level driver.</td>
    </tr>
    <tr>
      <td>ifc</td>
      <td>Just passes the call to the low level driver.</td>
    </tr>
    <tr>
      <td>ren</td>
      <td>Just passes the call to the low level driver.</td>
    </tr>
    <tr>
      <td>pollAddr</td>
      <td>Enable or disable SRQ polling of specified address.</td>
    </tr>
    <tr>
      <td>log</td>
      <td>Enable or disable logging of messages to/from specified
      address.</td>
    </tr>
    <tr>
      <td>srqProcessing</td>
      <td>Enable/disable srq handling from specified address</td>
    </tr>
    <tr>
      <td>srqSet</td>
      <td>Specify SRQ polling parameters.</td>
    </tr>
    <tr>
      <td>srqGet</td>
      <td>Get current SRQ polling parameters.</td>
    </tr>
    <tr>
      <td>registerDriver</td>
      <td>Register a driver. When gpibDriverUser receives this request it
        calls asynQueueManager registerDriver.</td>
    </tr>
    <tr>
      <td>srqHappened</td>
      <td>Called by driver when it detects that a GPIB device issues an
      SRQ.</td>
    </tr>
  </tbody>
</table>

<h3>gpibDriver</h3>

<p>gpibDriver is the interface that is implemented by gpib drivers, e.g. the
NI1014. It provides:</p>

<table border="1">
  <caption>gpibDriver</caption>
  <tbody>
    <tr>
      <td>asynDriver methods</td>
      <td>All the methods of asynDriver</td>
    </tr>
    <tr>
      <td>octetDriver methods</td>
      <td>All the methods of octetDriver</td>
    </tr>
    <tr>
      <td>registerSrqHandler</td>
      <td>Register a callback to handle SRQs for specified addesss.</td>
    </tr>
    <tr>
      <td>addressedCmd</td>
      <td>Issue a GPIB addressed command.</td>
    </tr>
    <tr>
      <td>universalCmd</td>
      <td>Issue a GPIB universial command.</td>
    </tr>
    <tr>
      <td>ifc</td>
      <td>Issue a GPIB Interface Clear command.</td>
    </tr>
    <tr>
      <td>ren</td>
      <td>Issue a GPIB Remote Enable command</td>
    </tr>
    <tr>
      <td>srqStatus</td>
      <td>Returns (0,1) if SRQ (is not, is) set</td>
    </tr>
    <tr>
      <td>srqEnable</td>
      <td>Enable or disable SRQs.</td>
    </tr>
    <tr>
      <td>serialPollBegin</td>
      <td>Start of serial poll.</td>
    </tr>
    <tr>
      <td>serialPoll</td>
      <td>Poll the specified address and return its response.</td>
    </tr>
    <tr>
      <td>serialPollEnd</td>
      <td>End of serial poll.</td>
    </tr>
  </tbody>
</table>
</body>
</html>
