<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <title>asynDriver</title>
  <meta name="GENERATOR" content="amaya 5.1" />
</head>

<body>

<center>
<h1>Asynchronous Driver Support</h1>

<p>Marty Kraimer, Benjamin Franksen, Pete Owens, Eric Norum, and Dirk
Zimoch</p>
</center>

<center>
<h2>Goals</h2>
</center>

<p><span style="font-weight: bold">asynDriver is a general purpose facility
for</span><span style="font-weight: bold">interfacing device specific code to
low level communication drivers</span>.</p>

<p>A primary target for asynDriver is EPICS IOC device support but, other
than using libCom, it is independent of EPICS IOC support.</p>

<p>The plan is:</p>
<ul>
  <li>Provide a facility that could be used by gpibCore, streams,
    devAscii/drvAscii, devOnrl, and mpfSerial. 
    <ul>
      <li>Each would have to be modified so that the device support component
        is compatible with existing uses but replace the driver part with
        asynDriver.</li>
      <li>The benefit is that all could share the same set of low level
        drivers.</li>
    </ul>
  </li>
  <li>Initially support the following communication protocals 
    <ul>
      <li>gpib</li>
      <li>vxi11</li>
      <li>serial, i.e. RS232,, etc.</li>
    </ul>
  </li>
  <li>In the future support other protocals especially for ethernet based
    devices.</li>
</ul>

<h3>NOTES:</h3>
<ul>
  <li>gpibCore is the Operating System Independent version of the
    Winans/Franksen gpib support.</li>
  <li>streams is the protocal file based support for serial/gpib/can from
    Dirk Zimoch.</li>
  <li>devAscii/drvAscii is support from KECK Observatory.</li>
  <li>devOnrl is the support from John Sinclair at Oak Ridge National
  Lab.</li>
  <li>mpfSerial is the serial support provided with MPF (Message Passing
    Facility)</li>
</ul>

<h3>Statement</h3>

<p>At the present time each of the systems mentioned above are used at EPICS
facilities for accessing gpib and/or serial devices. Because lots of existing
device support and thousands of database records use the above support, users
will not be easily persuaded to switch from their existing solution. Thus
what is proposed is to implement a framework below the device support level
that can be used by all of the above systems so that all can share the same
drivers.</p>

<center>
<h2>Overview of asynDriver support</h2>
</center>

<p>Multiple layers can exist between the asynchronous driver support and an
actual low level driver. For example gpib support is implemented as a
gpibDriverUser interface which is called by user code and a gpibDriver
interface which is called by gpibDriverUser.</p>

<p>A driver can implement multiple interfaces. For example gpib implements
asynDriver, octetDriver, and gpibDriverUser.</p>

<p>Asynchronous driver support uses the Operating System Independent features
of EPICS base. It is, however, independent of record/device support. Thus it
can be used by other code, e.g. a sequence program.</p>

<h3>Asynchronous Driver Components</h3>
<ul>
  <li><span style="font-weight: bold">asynQueueManager</span> 
    <p>Provides the following services.</p>
    <ul>
      <li>A thread for each communication interface.</li>
      <li>For user code it provides queueRequest. This is a non-blocking
        method, i.e. it can be called from scan threads. A callback specified
        by the user is called by the interface thread. The user callback can
        then make an arbitray number of calls to the driver. These calls may
        be blocking calls.</li>
      <li>It provides a transaction service, i.e. user code can lock out
        other users while it makes multiple queueRequests.</li>
    </ul>
  </li>
  <li><span style="font-weight: bold">asynDriver</span> 
    <p>asynDriver is a set of methods that must be implemented by all
    drivers.</p>
  </li>
  <li><span style="font-weight: bold">octetDriver</span> 
    <p>octetDriver is a set of methods implemented by any driver that accepts
    octet messages (messages consisting of 8 bit bytes) and returns octet
    responses. This interface will be sufficient for lots of device specific
    code. For example the code for streams protocal files probably needs only
    this interface. The term octet is used instead of ascii because the only
    requirement is messages consist of 8 bit bytes. It is expected that most
    uses will use ascii characters.</p>
  </li>
</ul>

<h3>Overview of implementation</h3>

<p>During initialization each driver registers each hardware interface with a
more generic layer. For example a gpibDriver reqisters with gpibDriverUser,
which in turn registers with asynQueueManager.</p>

<p>User code connects to a combination of asynQueueManager and one or more
drivers.This determines the methods it can call.</p>

<p>User code communicates with drivers via the following method:</p>
<ol>
  <li>It calls: 
    <pre> pasynQueueManager-&gt;queueRequest(...)</pre>
  </li>
  <li>The callback specified in queueRequest calls the driver.</li>
</ol>

<h3>Comments:</h3>
<ol>
  <li>Streams, devAscii, and mpfSerial need only asynQueueManager and
    octetDriver. gpibCore needs only asynQueueManager octetDriver, and
    gpibDriverUser.</li>
  <li>It is expected that most users will connect to these interfaces via
    device support. However other code can call it. Examples are sequence
    programs, test programs,utility commands, etc.</li>
  <li>It is expected that for some devices, support will consist of more than
    one type of support. For example most functions could be accessed via
    steams but gpibDriverUser could be used to handle unsollicited SRQs.</li>
</ol>

<center>
<h2>asynDriver</h2>
</center>

<h3>asynDriver.h</h3>

<p>Include file asynDriver.h contains the following definitions:</p>
<pre>typedef void asynPvt;
typedef void userPvt;
typedef void drvPvt;
typedef void lockPvt;

typedef enum {
asynSuccess,asynTimeout,asynError
}asynStatus;

typedef enum {
    asynQueuePriorityLow,asynQueuePriorityMedium,asynQueuePriorityHigh
}asynQueuePriority;

typedef enum {
    asynTimoutFirst, /*timeout for first input character.*/
    asynTimoutRead,
    asynTimeoutWrite
}asynTimeout;

typedef enum {
   asynCancelSuccess,
   asynCancelCallbackActive,
   asynCancelError
}asynCancelStatus;

typedef void (*userCallback)(userPvt *puserPvt);

typedef struct asynUser {
    userCallback callback;
    userPvt *puserPvt;
    char *errorMessage;
    int errorMessageSize;
    asynPvt *pasynPvt;
    drvPvt *pdrvPvt;
}asynUser;

typedef void (*peekHandler)(userPvt *puserPvt,
    char byte,int isReceive,int gotEOI);

typedef struct asynQueueManager {
    void (*report)(int details);
    /* The following are called by user code */
    asynUser *(*createAsynUser)(userCallback callback, userPvt *puserPvt);
    void (*freeAsynUser)(asynUser *pasynUser);
    asynStatus (*connectDevice)(asynUser *pasynUser, const char *name);
    asynStatus (*disconnectDevice)(asynUser *pasynUser);
    /*The following is used to locate driver interface*/
    void *(*findDriver)(asynUser *pasynUser,const char *driverType);
    /*The following are non blocking methods for user code*/
    asynStatus (*queueRequest)(asynUser *pasynUser,
                               void *lockPvt,asynQueuePriority priority);
    asynCancelStatus (*cancelRequest)(asynUser *pasynUser);
    lockPvt *(*createLock)(asynUser *pasynUser);
    void (*freeLock)(asynUser *pasynUser,lockPvt *plockPvt)
    void (*lock)(asynUser *pasynUser,lockPvt *plockPvt,double timeout);
    void (*unlock)(asynUser *pasynUser,lockPvt *plockPvt);
    /*peek only works if driver supports octetDriver interface*/
    void (*peek)(asynUser *pasynUser,double seconds);
    /* drivers call the following*/
    asynPvt *(*registerDriver)(drvPvt *pdrvPvt, const char *name,
                              char **papdriverType, /*all driver types*/
                              unsigned int priority,/*epicsThreadPriority*/
                              unsigned int stackSize);/*stack size*/
}asynQueueManager;
extern asynQueueManager *pasynQueueManager;
^L
/*Methods supported by ALL asyn drivers*/
#define asynDriverType "asynDriver"
typedef struct  asynDriver {
    void (*report)(asynUser *pasynUser,int details);
    /*following are to connect/disconnect to/from hardware*/
    asynStatus (*connect)(asynUser *pasynUser);
    asynStatus (*disconnect)(asynUser *pasynUser);
}asynDriver;

/* Methods supported by low level octet drivers. */
#define octetDriverType "octetDriver"
typedef struct octetDriver{
    int (*read)(asynUser *pasynUser,int addr,char *data,int maxchars);
    int (*write)(asynUser *pasynUser,
                        int addr,const char *data,int numchars);
    asynStatus (*flush)(asynUser *pasynUser,int addr);
    asynStatus (*setTimeout)(asynUser *pasynUser,
                             asynTimeout type,double timeout);
    asynStatus (*setEos)(asynUser *pasynUser,const char *eos,int eoslen);
    asynStatus (*installPeekHandler)(asynUser *pasynUser,peekHandler handler);
    asynStatus (*removePeekHandler)(asynUser *pasynUser);
}octetDriver;
</pre>

<h3>asynUser</h3>

<p>asynUser describes a structure that user code must provide for most
asynQueueManager and driver methods. Code must allocate and free an asynUser
by calling asynUserCalloc and asynUserFree.</p>

<table border="1">
  <caption>asynUser</caption>
  <tbody>
    <tr>
      <td>callback</td>
      <td>User callback. This can be specified on the call to asynUserCalloc.
        The user can change it as long as asynUser is not currently
      queued.</td>
    </tr>
    <tr>
      <td>puserPvt</td>
      <td>For use by the user. This can be specified on the call to
        asynUserCalloc. The user can change it as long as asynUser is not
        currently queued.</td>
    </tr>
    <tr>
      <td>errorMessage</td>
      <td>When either asynQueueManager or a driver returns a
        status!=asynSuccess it can also put an error message into
        errorMessage. They should do this via a call to 
        <pre>epicsSnprintf(pasynUser-&gt;errorMessage,pasynUser-&gt;errorMessageSize,"&lt;format&gt;",...)</pre>
      </td>
    </tr>
    <tr>
      <td>errorMessageSize</td>
      <td>The size of errorMessage. asynQueueManager determines this. It can
        not be changed.</td>
    </tr>
    <tr>
      <td>pasynPvt</td>
      <td>For private use by asynQueueManager</td>
    </tr>
    <tr>
      <td>pdrvPvt</td>
      <td>For private use by driver. It is the value the driver passes to
        registerDriver.</td>
    </tr>
  </tbody>
</table>

<h3>asynQueueManager</h3>

<p>asynQueueManager describes the asynQueueManager methods.</p>

<table border="1">
  <caption>asynQueueManager</caption>
  <tbody>
    <tr>
      <td>report</td>
      <td>This reports status about the asynQueueManager. It in turn calls
        asynDriver report.</td>
    </tr>
    <tr>
      <td>createAsynUser</td>
      <td>Creates an asynUser. It sets userCallback and puserPvt to the
        values the caller specifies. The caller can change these values as
        long a the asynUser is not queued. errorMessageSize characters are
        allocated for errorMessage. The amount of storage can not be changed.
        This method doesn't return if it is unable to allocate the
      storage.</td>
    </tr>
    <tr>
      <td>freeAsynUser</td>
      <td>Free an asynUser. The user must free it only via this call. If the
        asynUser is queued it will be removed from the queue. If the asynUser
        is active the call will fail.</td>
    </tr>
    <tr>
      <td>connectDevice</td>
      <td>User level code calls this at initialization to connect to a
        communication interface.. It passes the name of the device. This is
        the name specified in the call to registerDriver.</td>
    </tr>
    <tr>
      <td>disconnectDevice</td>
      <td>Disconnect. If the asynUser is queued it will be removed from the
        queue. If the asynUser is active the call will fail.</td>
    </tr>
    <tr>
      <td>findDriver</td>
      <td>Find a driver interface. It returns the address of the interface or
        0 if the driverType is not supported.</td>
    </tr>
    <tr>
      <td>queueRequest</td>
      <td>User code never calls a driver directly. Instead it calls
        queueRequest. After the thread associated with the driver takes this
        request from the queue, it calls the user's callback. The callback
        makes calls to the driver. If the user attempts to call queueRequest,
        but the asynUser is already on a queue, asynError is returned. It is
        OK to call queueRequest from the users callback routine.</td>
    </tr>
    <tr>
      <td>cancelRequest</td>
      <td>If a asynUser is queued remove it from the queue. If it is not on a
        queue nothing is done. In particular if the callback is active, this
        call has no effect.</td>
    </tr>
    <tr>
      <td>createLock/freeLock</td>
      <td>createLock/freeLock create and free locks. The value returned by
        createLock is what is passed to lock, unlock, and queueRequest.</td>
    </tr>
    <tr>
      <td>lock/unlock</td>
      <td>lock/unlock are used to block other users from calling a driver
        while a user is making a series of queueRequest calls. After a call
        is made to lock, asynQueueManager "locks" as soon as the first
        queueRequest with the specified lock is taken from the queue. At that
        point all other entries in the queue must wait until unlock is
        called. The timeout specifies how long to wait after a queue request
        is made until obtaining the lock. If timeout is less than 0 then it
        means forever.</td>
    </tr>
    <tr>
      <td>peek</td>
      <td>For the specified number of seconds report all characters send
        to/from the device.</td>
    </tr>
    <tr>
      <td>registerDriver</td>
      <td>This method is called by drivers. A call is made for each
        communication interrace. The asynQueueManager creates a thread for
        each call to registerDriver.</td>
    </tr>
  </tbody>
</table>

<h3>asynDriver</h3>

<p>asynDriver describes the methods provided by all drivers.</p>

<table border="1">
  <caption>asynDriver</caption>
  <tbody>
    <tr>
      <td>report</td>
      <td>Generates a report about the hardware device.</td>
    </tr>
    <tr>
      <td>connect</td>
      <td>Connect to the hardware device or communication path. This is
        called by asynQueueManager after the driver has called
        registerDriver. It may also be called by command utilities that first
        call disconnect and then connect.</td>
    </tr>
    <tr>
      <td>disconnect</td>
      <td>Disconnect from the hardware device. This is normally called by
        command utilities that want to stop and then restart communication to
        a device.</td>
    </tr>
  </tbody>
</table>

<h3>octetDriver</h3>

<p>NOTES:</p>
<ul>
  <li>This is just a guess at what methods octetDriver should provide.</li>
  <li>Octet instead of ascii is used because it implys that communication is
    done via 8 bit characters.</li>
</ul>

<p>octetDriver describes the methods provided by drivers that use octet
strings for sending commands and receiving responses from a device.</p>

<table border="1">
  <caption>octetDriver</caption>
  <tbody>
    <tr>
      <td>read</td>
      <td>Read a message from the device.</td>
    </tr>
    <tr>
      <td>write</td>
      <td>Send a message to the device.</td>
    </tr>
    <tr>
      <td>flush</td>
      <td>Flush the input buffer.</td>
    </tr>
    <tr>
      <td>setTimeout</td>
      <td>Specify timeouts</td>
    </tr>
    <tr>
      <td>setEos</td>
      <td>Specify end of string characters</td>
    </tr>
    <tr>
      <td>installPeekHandler</td>
      <td>Install a peek handler. When a peek handler is installed then the
        driver calls the peekHandler for every byte it send or receives.</td>
    </tr>
    <tr>
      <td>removePeekHandler</td>
      <td>Remove the peek handler</td>
    </tr>
  </tbody>
</table>

<center>
<h2>Discussion of asynDriver</h2>
</center>

<p>File asynDriver.h describes four structures:</p>
<ul>
  <li>asynUser - A structure for interfacing between user code and
    asynQueueManager or drivers.</li>
  <li>asynQueueManager - An interface describing the asynQueueManager
  methods.</li>
  <li>asynDriver - An interface describing methods implemented by all
  drivers</li>
  <li>octetDriver - An interface describing methods implemented by all
    drivers that handle octet messages</li>
</ul>

<p>The following is the skeleton for code that communicates with a device via
octet messages..</p>
<pre>#include &lt;asynDriver.h&gt;
...
#define BUFSIZE 80
typedef struct myData {
    asynUser    *pasynUser;
    octetDriver *poctetDriver;
    char buffer[BUFSIZE];
}myData;

void myCallback(userPvt *puserPvt)
    myData *pmydata = (myData *)puserPvt;
    octetDriver *poctetDriver = pmydata-&gt;poctetDriver;
    asynUser *pasynUser = pmydata-&gt;pasynUser;
    asynStatus status;
    int retlen;


    status = poctetDriver-&gt;setEos(pasynUser,"\n",1);
    if(status) {
        printf("myCallback setEos failed %s\n",pasynUser-&gt;errorMessage);
    }
    retlen = poctetDriver-&gt;read(pasynUser,0,pmydata-&gt;buffer,BUFSIZE);
    if(retlen&lt;=0) {
        printf("myCallback read failed %s\n",pasynUser-&gt;errorMessage);
    } else {
        printf("myCallback read returned: retlen %d data %s\n",
            retlen,pmydata-&gt;buffer);
    }
}

void mainThread(void)
{
    myData *pmyData;
    asynUser *pasynUser;
    asynStatus status;

    pmyData = calloc(1,sizeof(myData));
    pasynUser = pasynQueueManager-&gt;createAsynUser(myCallback,pmyData);
    pmyData-&gt;pasynUser = pasynUser;
    status = pasynQueueManager-&gt;connectDevice(pasynUser,"serialPort1")
    if(status) {
        printf("can't connect to serialPort1 %s\n",pasynUser-&gt;errorMessage);
        exit(1);
    }
    pmyData-&gt;poctetDriver = (octetDriver *)pasynQueueManager-&gt;findDriver(
        pasynUser,octetDriverType);
    if(!myData-&gt;poctetDriver) {
        printf("%s driver not supported\n",octetDriverType);
        exit(-1);
    }
    status = pasynQueueManager-&gt;queueRequest(pasynUser,0);
    if(status) {
        printf("queueRequest failed %s\n",pasynUser-&gt;errorMessage);
        exit(1);
    }
    /*Note that callback will be called by another thread*/
    ...
}
</pre>

<p>The flow of control is as follows:</p>
<ol>
  <li>A driver registers itself to asynQueueManager.</li>
  <li>mainThread allocates myData and an asynUser.</li>
  <li>mainThread connects to a a device and to a driver for that device.</li>
  <li>When it is ready to communicate with the driver it calls
  queueRequest.</li>
  <li>The thread associated with the device calls myCallback.</li>
  <li>myCallback calls the driver's seteos and read methods.</li>
</ol>

<center>
<h2>gpibDriver</h2>
</center>

<p>NOTE: This definition is based on the features gpibCore provides.</p>

<p>gpibDriver is an example of how complicated support can be structured. It
defines two interfaces.</p>
<ul>
  <li>gpibDriverUser - This is the interface that user code uses. It provides
    the following: 
    <ul>
      <li>A set of gpib specific methods that user code can call.</li>
      <li>Code that handles generic GPIB functions like SRQ polling.</li>
    </ul>
  </li>
  <li>gpibDriver - A set of methods implemented by gpib drivers</li>
</ul>

<h3>gpibDriver.h</h3>

<p>Include file gpibDriver.h contains the following definitions:</p>
<pre>#include "asynDriver.h"
#define gpibDriverUserType "gpibDriverUser"
/* GPIB drivers */
typedef struct gpibDriverUser{
    /* The following are called by gpib aware users*/
    asynStatus (*registerSrqHandler)(asynUser *pasynUser,
        int addr, srqHandlerFunc handler, void *parm);
    asynStatus (*addressedCmd) (asynUser *pasynUser,
        int addr, char *data, int length, int timeout);
    asynStatus (*universalCmd) (drvPvt * pvt, int cmd);
    asynStatus (*ifc) (drvPvt * pvt);
    asynStatus (*ren) (drvPvt * pvt, int onOff);
    void (*pollAddr)(drvPvt *pvt,int addr, int onOff);
    void (*srqProcessing)(drvPvt *pvt, int onOff);
    void (*srqSet)(drvPvt *pvt,
        double srqTimeout,double pollTimeout,double pollRate,
        int srqMaxEvents);
    void (*srqGet)(drvPvt *pvt,
        double *srqTimeout,double *pollTimeout,double *pollRate,
        int *srqMaxEvents);
    /* The following are called by low level gpib drivers */
    drvPvt *(*registerDriver)(drvPvt pvt,const char *name);
    void (*srqHappened)(drvPvt pvt); /*pvt is gpibDriverUser pvt*/
}gpibDriverUser;


typedef struct gpibDriver {
    /*asynDriver methods */
    void (*report)(asynUser *pasynUser,int details);
    void (*connect)(drvPvt *pdrvPvt);
    void (*disconnect)(drvPvt *pdrvPvt);
    /*octetDriver methods */
    int (*read)(asynUser *pasynUser,int addr,char *data,int maxchars);
    int (*write)(asynUser *pasynUser,
                        int addr,const char *data,int numchars);
    asynStatus (*flush)(asynUser *pasynUser,int addr);
    asynStatus (*setTimeout)(asynUser *pasynUser,
                             asynTimeout type,double timeout);
    asynStatus (*setEos)(asynUser *pasynUser,const char *eos,int eoslen);
    asynStatus (*installPeekHandler)(asynUser *pasynUser,peekHandler handler);
    asynStatus (*removePeekHandler)(asynUser *pasynUser);
    /*gpibDriver methods*/
    asynStatus (*registerSrqHandler)(drvPvt pvt,
        int addr, srqHandlerFunc handler, void *parm);
    asynStatus (*addressedCmd) (drvPvt pvt,
        int addr, char *data, int length, int timeout);
    asynStatus (*universalCmd) (drvPvt * pvt, int cmd);
    asynStatus (*ifc) (drvPvt * pvt);
    asynStatus (*ren) (drvPvt * pvt, int onOff);
    int (*srqStatus) (drvPvt * pvt);
    asynStatus (*srqEnable) (drvPvt * pvt, int onOff);
    asynStatus (*serialPollBegin) (drvPvt * pvt);
    int (*serialPoll) (drvPvt * pibLink, int addr, double timeout);
    asynStatus (*serialPollEnd) (drvPvt * pibLink);
}gpibDriver;</pre>

<h3>gpibDriverUser</h3>

<p>gpibDriverUser describes the interface for user code. It provides gpib
specific functions like SRQ handling. It makes calls to a gpibDriver. Note
that the gpib user support also implements the asynDriver and octetDriver
interraces.</p>

<table border="1">
  <caption>gpibDriverUser</caption>
  <tbody>
    <tr>
      <td>registerSrqHandler</td>
      <td>Just passes the call to the low level driver.</td>
    </tr>
    <tr>
      <td>addressedCmd</td>
      <td>Just passes the call to the low level driver.</td>
    </tr>
    <tr>
      <td>universalCmd</td>
      <td>Just passes the call to the low level driver.</td>
    </tr>
    <tr>
      <td>ifc</td>
      <td>Just passes the call to the low level driver.</td>
    </tr>
    <tr>
      <td>ren</td>
      <td>Just passes the call to the low level driver.</td>
    </tr>
    <tr>
      <td>pollAddr</td>
      <td>Enable or disable SRQ polling of specified address.</td>
    </tr>
    <tr>
      <td>log</td>
      <td>Enable or disable logging of messages to/from specified
      address.</td>
    </tr>
    <tr>
      <td>srqProcessing</td>
      <td>Enable/disable srq handling from specified address</td>
    </tr>
    <tr>
      <td>srqSet</td>
      <td>Specify SRQ polling parameters.</td>
    </tr>
    <tr>
      <td>srqGet</td>
      <td>Get current SRQ polling parameters.</td>
    </tr>
    <tr>
      <td>registerDriver</td>
      <td>Register a driver. When gpibDriverUser receives this request it
        calls asynQueueManager registerDriver.</td>
    </tr>
    <tr>
      <td>srqHappened</td>
      <td>Called by driver when it detects that a GPIB device issues an
      SRQ.</td>
    </tr>
  </tbody>
</table>

<h3>gpibDriver</h3>

<p>gpibDriver is the interface that is implemented by gpib drivers, e.g. the
NI1014. It provides:</p>

<table border="1">
  <caption>gpibDriver</caption>
  <tbody>
    <tr>
      <td>asynDriver methods</td>
      <td>All the methods of asynDriver</td>
    </tr>
    <tr>
      <td>octetDriver methods</td>
      <td>All the methods of octetDriver</td>
    </tr>
    <tr>
      <td>registerSrqHandler</td>
      <td>Register a callback to handle SRQs for specified addesss.</td>
    </tr>
    <tr>
      <td>addressedCmd</td>
      <td>Issue a GPIB addressed command.</td>
    </tr>
    <tr>
      <td>universalCmd</td>
      <td>Issue a GPIB universial command.</td>
    </tr>
    <tr>
      <td>ifc</td>
      <td>Issue a GPIB Interface Clear command.</td>
    </tr>
    <tr>
      <td>ren</td>
      <td>Issue a GPIB Remote Enable command</td>
    </tr>
    <tr>
      <td>srqStatus</td>
      <td>Returns (0,1) if SRQ (is not, is) set</td>
    </tr>
    <tr>
      <td>srqEnable</td>
      <td>Enable or disable SRQs.</td>
    </tr>
    <tr>
      <td>serialPollBegin</td>
      <td>Start of serial poll.</td>
    </tr>
    <tr>
      <td>serialPoll</td>
      <td>Poll the specified address and return its response.</td>
    </tr>
    <tr>
      <td>serialPollEnd</td>
      <td>End of serial poll.</td>
    </tr>
  </tbody>
</table>
</body>
</html>
