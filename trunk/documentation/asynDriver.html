<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <title>asynDriver</title>
</head>

<body>

<center>
<h1>asynDriver: Asynchronous Driver Support</h1>

<h2>Marty Kraimer, Benjamin Franksen, Pete Owens, Eric Norum, and Dirk
Zimoch, and Jun-ichi Odagare</h2>

<h2>October 2003</h2>
</center>
<hr>

<center>
<h2>License Agreement</h2>
</center>

<p>This product is available via the open source license described at the end
of this document</p>
<hr>

<center>
<h2>MAJOR CONCERNS</h2>
</center>
<p><bold>Debug, Logging, etc</bold></p>
<p>In the past three at least three diferent methods were used to obtain
debug type information.</p>
<ul>
   <li>Debug variables.
    <p>debug variables were put in device and/or driver support. Thus was
       fine on vxWorks where the vxWorks shell has access to all external
       variables. With 3.14 it is somewhat of a pain to make them available
       on other platforms. More of a problem is that the debug flag applys
       to ALL instances of the supported device/driver. If multiple
       instances of a device are controlled from a single IOC then the
       debug flags can be almost useless. The user wants to look at all
       communication with a device that is having troubles not all devices.</p>
   </li>
   <li>logging facility
     <p>gpibCore had such a facility that was independent of debug flags</p>
   </li>
   <li>peek facility
     <p>mpfSerial provided a facility that could trap every byte sent to/from
       a serial line. This was quite usefull for finding problems</p>
    </li>
</ul>
<p>Currently the support has some debug flags and provides an
installPeekHandler method. Perhaps there is a better way.</p>
<p>How about the following: Define a new method for asynCommon.</p>
<pre>
#define TRACE_ERRORS   0x000000001
#define TRACE_IO_SHORT 0x000000002
#define TRACE_IO_FULL  0x000000004
#define TRACE_FLOW     0x000000008
trace(void *drvPvt,asynUser *pasynUser,FILE *fd, int mask);
</pre>
<p>All output will be written to fd. mask determines what is written.</p>
<ul>
   <li>TRACE_ERRORS
     <p>Show only errors, e.g. timeouts.</p>
   </li>
   <li>TRACE_IO_SHORT
     <p>Show up to first 20 characters of each message</p>
   </li>
   <li>TRACE_IO_FULL
     <p>Show all I/O messages</p>
   </li>
   <li>TRACE_FLOW
     <p>Show program flow.</p>
   </li>
</ul>
     
<p><bold>Lock should apply to device not to port</bold></p>


<center>
<h2>Introduction</h2>
</center>

<p>asynDriver is a general purpose facility for interfacing device specific
code to low level communication drivers</p>

<p>A primary target for asynDriver is EPICS IOC device support but, other
than using libCom, it is independent of EPICS IOC support.</p>

<p>This version provides</p>
<ul>
  <li>asynManager, i.e. the software layer between device support and
  drivers.</li>
  <li>devGpib: EPICS device support that replaces the device support layer of
    the Winans/Franksen gpibCore support.</li>
  <li>asynGpib: a replacement for the drvGpibCommon layer of the Franksen
    gpibCore support</li>
  <li>vxi11: A replacement for the vxi11 support of the Franksen gpibCore
    support</li>
  <li>Could be used by streams, devAscii/drvAscii, devOnrl, and mpfSerial.
    <ul>
      <li>Each would have to be modified so that the device support component
        is compatible with existing uses but replace the driver part with
        asynDriver.</li>
      <li>The benefit is that all could share the same set of low level
        drivers.</li>
    </ul>
  </li>
  <li>Plans are to soon implement several serial drivers</li>
  <li>Hoefully Dirk will get time soon to convert streams to use
  asynDriver.</li>
  <li>In the future other protocals will be supported especially for ethernet
    based devices.</li>
</ul>

<h3>NOTES:</h3>
<ul>
  <li>gpibCore is the Operating System Independent version of the
    Winans/Franksen gpib support.</li>
  <li>streams is the protocal file based support for serial/gpib/can from
    Dirk Zimoch.</li>
  <li>devAscii/drvAscii is support from KECK Observatory.</li>
  <li>devOnrl is the support from John Sinclair at Oak Ridge National
  Lab.</li>
  <li>mpfSerial is the serial support provided with MPF (Message Passing
    Facility)</li>
</ul>

<h3>Statement</h3>

<p>At the present time each of the systems mentioned above are used at EPICS
facilities for accessing gpib and/or serial devices. Because lots of existing
device support and thousands of database records use the above support, users
will not be easily persuaded to switch from their existing solution. Thus
what is proposed is to implement a framework below the device support level
that can be used by all of the above systems so that all can share the same
drivers.</p>
<hr>

<center>
<h2>Overview of asynDriver support</h2>
</center>

<p>asynDriver is a software layer between support device specific code and
communication drivers that send/recevice message to/from devices. asynDrivers
uses the following terminology:</p>
<ul>
  <li>interface
    <p>All communication between software layers is done via interfaces. An
    interface definition is a C language structure consisting entirely of
    methods (functions). An asynDriver interface is analogous to a C++ or
    Java pure virtual interface.</p>
  </li>
  <li>port
    <p>A communication entity over which message are sent.</p>
  </li>
</ul>

<p>The interfaces are defined so that most device specific code can
communicate over a large variety of different types of port. If device
support does all it's communication via reads and writes of messages
consisting of 8 bit bytes (octets) then it should work with almost all types
of port. If device support requires more complicated support such as
interrupts then the types of ports will be more limited.</p>

<p>Examples of ports are gpib interfaces, serial ports, ethernet ports, etc.
One or more devices can be attached to a particular port. For example only
one device can be attached to an RS232 port but up to 15 devices can be
attached to a GPIB controller.</p>

<p>Multiple layers can exist between device specific code and a port driver..
For port drivers that register directly with the asynManager, a process
module can be registered with the queue manager. Just like a driver a process
module implements interfaces. The asynManager:findInterface method looks
first for process module interfaces and then for driver interfaces. A process
module normally calls drivers as part of it's processing. For more
complicated protocals additional layers can be created. For example gpib
support is implemented as a asynGpib interface which is called by user code
and a asynGpibPort interface which is called by asynGpibUser.</p>

<p>A driver can implement multiple interfaces. For example asynGpib
implements asynCommon, asynOctet, and asynGpibUser.</p>

<p>Asynchronous driver support uses the Operating System Independent features
of EPICS base. It is, however, independent of record/device support. Thus it
can be used by other code, e.g. a sequence program.</p>

<h3>Asynchronous Driver Components</h3>
<ul>
  <li><span style="font-weight: bold">asynManager</span>
    <p>Provides the following services.</p>
    <ul>
      <li>A thread for each communication interface.</li>
      <li>queueRequest. This is a non-blocking method, i.e. it can be called
        from scan threads. A callback specified by the user is called by the
        interface thread. The user callback can then make an arbitray number
        of calls to the driver. These calls may be blocking calls.</li>
      <li>It provides a transaction service, i.e. user code can lock out
        other users while it makes multiple queueRequests.</li>
    </ul>
  </li>
  <li><span style="font-weight: bold">asynCommon</span>
    <p>asynCommon is a set of methods that must be implemented by all
    drivers.</p>
  </li>
  <li><span style="font-weight: bold">asynOctet</span>
    <p>asynOctet is a set of methods implemented by any driver that accepts
    octet messages (messages consisting of 8 bit bytes) and returns octet
    responses. This interface will be sufficient for lots of device specific
    code. For example the code for streams protocal files needs only this
    interface. The term octet is used instead of ascii because the only
    requirement is messages consist of 8 bit bytes.</p>
  </li>
</ul>

<h3>Overview of implementation</h3>

<p>During initialization a driver registers each hardware interface with
asynManager.</p>

<p>User code connects to a port and communicates with the port via
combination of asynManager and one or more interfaces.</p>

<p>User code communicates with drivers via the following method:</p>
<ol>
  <li>It calls:
    <pre> pasynManager-&gt;queueRequest(...)</pre>
  </li>
  <li>The callback specified in queueRequest calls the driver via one of the
    driver interfaces.</li>
</ol>

<h3>Comments:</h3>
<ol>
  <li>Streams, devAscii, and mpfSerial need only asynManager and asynOctet.
    gpibCore needs only asynManager asynOctet, and asynGpib.</li>
  <li>It is expected that most users will connect to these interfaces via
    device support. However other code can call it. Examples are sequence
    programs, test programs,utility commands, etc.</li>
  <li>It is expected that for some devices, support will consist of more than
    one type of support. For example most functions could be accessed via
    steams but asynGpibUser could be used to handle unsollicited SRQs.</li>
</ol>
<hr>

<center>
<h2>asynDriver</h2>
</center>

<h3>asynDriver.h</h3>

<p>Include file asynDriver.h contains the following definitions:</p>
<pre>typedef struct asynPvt asynPvt;
typedef enum {
    asynSuccess,asynTimeout,asynError
}asynStatus;

typedef enum {
    asynQueuePriorityLow,asynQueuePriorityMedium,asynQueuePriorityHigh
}asynQueuePriority;

typedef enum {
    asynTimoutFirst, /*timeout for first input character.*/
    asynTimoutRead,
    asynTimeoutWrite
}asynTimeoutType;

typedef void (*userCallback)(void *puserPvt);

typedef struct asynUser {
    char *errorMessage;
    int errorMessageSize;
    double timeout;  /*Timeout for I/O operations*/
    void *puserPvt;
}asynUser;

typedef void (*peekHandler)(void *puserPvt,
    char byte,int isReceive,int gotEOI);

typedef struct asynInterface{
    const char *interfaceType;
    void *pinterface;
    void *drvPvt;
}asynInterface;

typedef struct asynManager {
    void (*report)(int details);
    asynUser  *(*createAsynUser)(
        userCallback queue,userCallback timeout,void *userPvt);
    asynStatus (*freeAsynUser)(asynUser *pasynUser);
    asynStatus (*connectPort)(asynUser *pasynUser, const char *portName);
    asynStatus (*disconnectPort)(asynUser *pasynUser);
    asynInterface *(*findInterface)(asynUser *pasynUser,
        const char *interfaceType,int processModuleOK);
    asynStatus (*queueRequest)(asynUser *pasynUser,
        asynQueuePriority priority,double timeout);
    void (*cancelRequest)(asynUser *pasynUser);
    asynStatus (*lock)(asynUser *pasynUser);
    asynStatus (*unlock)(asynUser *pasynUser);
    /* drivers call the following*/
    asynStatus (*registerPort)(
        const char *portName,
        asynInterface *paasynInterface,int nasynInterface,
        unsigned int priority,unsigned int stackSize);
    /*process modules call the following */
    asynStatus (*registerProcessModule)(
        const char *processModuleName,const char *portName,
        asynInterface *paasynInterface,int nasynInterface);
}asynManager;
epicsShareExtern asynManager *pasynManager;

/*Methods supported by ALL asyn drivers*/
#define asynCommonType "asynCommon"
typedef struct  asynCommon {
    void       (*report)(void *drvPvt,int details);
    /*following are to connect/disconnect to/from hardware*/
    asynStatus (*connect)(void *drvPvt,asynUser *pasynUser);
    asynStatus (*disconnect)(void *drvPvt,asynUser *pasynUser);
}asynCommon;

/* Methods supported by low level octet drivers. */
#define asynOctetType "asynOctet"
typedef struct asynOctet{
    int        (*read)(void *drvPvt,asynUser *pasynUser,int addr,char *data,int maxchars);
    int        (*write)(void *drvPvt,asynUser *pasynUser,
                        int addr,const char *data,int numchars);
    asynStatus (*flush)(void *drvPvt,asynUser *pasynUser,int addr);
    asynStatus (*setEos)(void *drvPvt,asynUser *pasynUser,
                         int addr,const char *eos,int eoslen);
    asynStatus (*installPeekHandler)(void *drvPvt,asynUser *pasynUser,
                         peekHandler handler,void *peekHandlerPvt);
    asynStatus (*removePeekHandler)(void *drvPvt,asynUser *pasynUser);
}asynOctet;
</pre>

<h3>asynUser</h3>

<p>asynUser describes a structure that user code must provide for most
asynManager and driver methods. Code must allocate and free an asynUser by
calling asynUserCalloc and asynUserFree.</p>

<table border="1">
  <caption>asynUser</caption>
  <tbody>
    <tr>
      <td>errorMessage</td>
      <td>When either asynManager or a driver returns a status!=asynSuccess
        it can also put an error message into errorMessage. They should do
        this via a call to
        <pre>epicsSnprintf(pasynUser-&gt;errorMessage,pasynUser-&gt;errorMessageSize,"&lt;format&gt;",...)</pre>
      </td>
    </tr>
    <tr>
      <td>errorMessageSize</td>
      <td>The size of errorMessage. asynManager determines this. It can not
        be changed.</td>
    </tr>
    <tr>
      <td>timeout</td>
      <td>The number of seconds before timeout for I/O requests.</td>
    </tr>
    <tr>
      <td>puserPvt</td>
      <td>For use by the user. This can be specified on the call to
        asynUserCalloc and should never be changed.</td>
    </tr>
  </tbody>
</table>

<h3>asynManager</h3>

<p>asynManager describes the asynManager methods.</p>

<table border="1">
  <caption>asynManager</caption>
  <tbody>
    <tr>
      <td>report</td>
      <td>Reports status about the asynManager. It in turn calls asynCommon
        report.</td>
    </tr>
    <tr>
      <td>createAsynUser</td>
      <td>Creates an asynUser. The caller specifies two callbacks, one for
        successful queueRequests and one if a queueRequest has a timeout. The
        timeout callback is optional. The caller also specifies puserPvt.
        errorMessageSize characters are allocated for errorMessage. The
        amount of storage can not be changed. This method doesn't return if
        it is unable to allocate the storage.</td>
    </tr>
    <tr>
      <td>freeAsynUser</td>
      <td>Free an asynUser. The user must free it only via this call. The
        call will fail if the asynUser is queued or locked or connected to a
        device.</td>
    </tr>
    <tr>
      <td>connectPort</td>
      <td>User level code calls this at initialization to connect to a
        communication interface.. It passes the name of the device. This is
        the name specified in the call to registerPort. If processModuleOK is
        true and a processModule is reqistered for the device and
        interfaceType then it's asynPortDriver is returned; otherwise the
        asynPortDriver of the actual device driver is returned.</td>
    </tr>
    <tr>
      <td>disconnectPort</td>
      <td>Disconnect. If the asynUser is queued or locked this request will
        fail.</td>
    </tr>
    <tr>
      <td>findInterface</td>
      <td>Find a driver interface. It returns the address of a asynPortDriver
        or 0 if the interfaceType is not supported. The user will need the
        address of the drivers interface and the address of pdrvPvt so that
        calls can be made to the driver. For example:
        <pre>asynPortDriver *pasynPortDriver;
asynOctet *pasynOctet;
void *pasynOctetPvt;
...
pasynPortDriver = pasynManager-&gt;findInterface(
        pasynUser,asynOctetType,1);
if(!pasynPortDriver) { /*error do something*/}
pasynOctet = (asynOctet *)pasynPortDriver-&gt;pasynInterface-&gt;pinterface;
pasynOctetPvt = pasynPortDriver-&gt;pdrvPvt;
...
pasynOctet-&gt;read(pasynOctetPvt,pasynUser,...
        </pre>
      </td>
    </tr>
    <tr>
      <td>queueRequest</td>
      <td>User code never calls a driver directly. Instead it calls
        queueRequest. After the thread associated with the driver takes this
        request from the queue, it calls the user's callback. The callback
        makes calls to the driver. If the user attempts to call queueRequest,
        but the asynUser is already on a queue, asynError is returned. The
        timeout is from when the request is queued until it is taken from the
        queue. A value less than or equal to 0.0 means no timeout.</td>
    </tr>
    <tr>
      <td>cancelRequest</td>
      <td>If a asynUser is queued remove it from the queue. If it is not on a
        queue nothing is done. In particular if the callback is active, this
        call has no effect.</td>
    </tr>
    <tr>
      <td>lock/unlock</td>
      <td>lock/unlock are used to block other users from calling a driver
        while a user is making a series of queueRequest calls. After a call
        is made to lock, asynManager locks as soon as the first queueRequest
        with the specified lock is taken from the queue. At that point all
        other entries in the queue must wait until unlock is called. These
        methods fail if a request is currently queued.</td>
    </tr>
    <tr>
      <td>registerPort</td>
      <td>This method is called by drivers. A call is made for each
        communication interface instance.</td>
    </tr>
    <tr>
      <td>registerProcessModule</td>
      <td>This method is called by a process manager, i.e. code that wants to
        be called instead of the low level driver itself. Normally it adds
        additional functionality to the low level driver, It in turn normally
        calls the low level driver. It must be called after the driver calls
        registerDriver and before the client code calls findInterface.</td>
    </tr>
  </tbody>
</table>

<h3>asynCommon</h3>

<p>asynCommon describes the methods provided by all drivers.</p>

<table border="1">
  <caption>asynCommon</caption>
  <tbody>
    <tr>
      <td>report</td>
      <td>Generates a report about the hardware device.</td>
    </tr>
    <tr>
      <td>connect</td>
      <td>Connect to the hardware device or communication path. This is
        called by asynManager after the driver has called registerDriver. It
        may also be called by command utilities that first call disconnect
        and then connect.</td>
    </tr>
    <tr>
      <td>disconnect</td>
      <td>Disconnect from the hardware device. This is normally called by
        command utilities that want to stop and then restart communication to
        a device.</td>
    </tr>
  </tbody>
</table>

<h3>asynOctet</h3>

<p>NOTES:</p>
<ul>
  <li>This is just a guess at what methods asynOctet should provide.</li>
  <li>The name octet is used instead of ascii because it implys that
    communication is done via 8 bit characters.</li>
</ul>

<p>asynOctet describes the methods provided by drivers that use octet strings
for sending commands and receiving responses from a device.</p>

<table border="1">
  <caption>asynOctet</caption>
  <tbody>
    <tr>
      <td>read</td>
      <td>Read a message from the device.</td>
    </tr>
    <tr>
      <td>write</td>
      <td>Send a message to the device.</td>
    </tr>
    <tr>
      <td>flush</td>
      <td>Flush the input buffer.</td>
    </tr>
    <tr>
      <td>setTimeout</td>
      <td>Specify timeouts</td>
    </tr>
    <tr>
      <td>setEos</td>
      <td>Specify end of string characters</td>
    </tr>
    <tr>
      <td>installPeekHandler</td>
      <td>Install a peek handler. When a peek handler is installed then the
        driver calls the peekHandler for every byte it send or receives.</td>
    </tr>
    <tr>
      <td>removePeekHandler</td>
      <td>Remove the peek handler</td>
    </tr>
  </tbody>
</table>
<hr>

<center>
<h2>Discussion of asynCommon</h2>
</center>

<p>File asynCommon.h describes four structures:</p>
<ul>
  <li>asynUser - Structure for interfacing between user code and asynManager
    or drivers.</li>
  <li>asynInterface and asynPortDriver - Structures for registering and
    location driver interfaces and a pdrvPvt.</li>
  <li>asynManager - Interface describing the asynManager methods.</li>
  <li>asynCommon - Interface describing methods implemented by all
  drivers</li>
  <li>asynOctet - Interface describing methods implemented by all drivers
    that handle octet messages</li>
</ul>

<p>The following is the skeleton for code that communicates with a device via
octet messages..</p>
<pre>#include &lt;asynCommon.h&gt;
...
#define BUFSIZE 80
typedef struct myData {
    asynUser    *pasynUser;
    asynOctet *pasynOctet;
    void *pdrvPvt;
    char buffer[BUFSIZE];
}myData;

void queueCallback(userPvt *puserPvt)
    myData *pmydata = (myData *)puserPvt;
    asynOctet *pasynOctet = pmydata-&gt;pasynOctet;
    asynUser *pasynUser = pmydata-&gt;pasynUser;
    asynStatus status;
    int retlen;


    status = pasynOctet-&gt;setEos(pmyData-&gt;pdrvPvt,pasynUser,"\n",1);
    if(status) {
        printf("queueCallback setEos failed %s\n",pasynUser-&gt;errorMessage);
    }
    retlen = pasynOctet-&gt;read(pmyData-&gt;pdrvPvt,pasynUser,0,pmydata-&gt;buffer,BUFSIZE);
    if(retlen&lt;=0) {
        printf("queueCallback read failed %s\n",pasynUser-&gt;errorMessage);
    } else {
        printf("queueCallback read returned: retlen %d data %s\n",
            retlen,pmydata-&gt;buffer);
    }
}

void mainThread(void)
{
    myData *pmyData;
    asynUser *pasynUser;
    asynStatus status;
    asynPortDriver *pasynPortDriver;

    pmyData = calloc(1,sizeof(myData));
    pasynUser = pasynManager-&gt;createAsynUser(queueCallback,0,pmyData);
    pmyData-&gt;pasynUser = pasynUser;
    status = pasynManager-&gt;connectPort(pasynUser,"serialPort1")
    if(status) {
        printf("can't connect to serialPort1 %s\n",pasynUser-&gt;errorMessage);
        exit(1);
    }
    pasynPortDriver = (asynOctet *)pasynManager-&gt;findInterface(
        pasynUser,asynOctetType,1);
    if(!pasynPortDriver) {
        printf("%s driver not supported\n",asynOctetType);
        exit(-1);
    }
    pmyData-&gt;pasynOctet = (asynOctet *)pasynPortDriver-&gt;pasynInterface-&gt;pinterface;
    pmyData-&gt;pdrvPvt = pasynPortDriver-&gt;pdrvPvt;
    status = pasynManager-&gt;queueRequest(pasynUser,asynQueuePriorityLow, 0.0);
    if(status) {
        printf("queueRequest failed %s\n",pasynUser-&gt;errorMessage);
        exit(1);
    }
    /*Note that callback will be called by another thread*/
    ...
}</pre>

<p>The flow of control is as follows:</p>
<ol>
  <li>A driver registers itself to asynManager.</li>
  <li>mainThread allocates myData and an asynUser.</li>
  <li>mainThread connects to a a device and to a driver for that device.</li>
  <li>When it is ready to communicate with the driver it calls
  queueRequest.</li>
  <li>The thread associated with the device calls queueCallback.</li>
  <li>queueCallback calls the driver's setEos and read methods.</li>
</ol>
<hr>

<center>
<h2>asynGpib</h2>
</center>

<p>NOTE: This definition is based on the features gpibCore provides.</p>

<p>asynGpib is an example of how complicated support can be structured. It
defines two interfaces.</p>
<ul>
  <li>asynGpibUser - This is the interface that user code uses. It provides
    the following:
    <ul>
      <li>A set of gpib specific methods that user code can call.</li>
      <li>Code that handles generic GPIB functions like SRQ polling.</li>
    </ul>
  </li>
  <li>asynGpib - A set of methods implemented by gpib drivers</li>
</ul>

<h3>asynGpib.h</h3>

<p>Include file asynGpib.h contains the following definitions:</p>
<pre>#include "asynDriver.h"

#define asynGpibUserType "asynGpibUser"
/* GPIB drivers */
typedef void (*srqHandler)(void *userPrivate,int gpibAddr,int statusByte);
typedef struct asynGpibUser{
    /* The following are called by gpib aware users*/
    asynStatus (*registerSrqHandler)(void *pdrvPvt,asynUser *pasynUser,
        srqHandler handler, void *userPrivate);
    asynStatus (*addressedCmd) (void *pdrvPvt,asynUser *pasynUser,
        int addr, const char *data, int length);
    asynStatus (*universalCmd) (void *pdrvPvt,asynUser *pasynUser, int cmd);
    asynStatus (*ifc) (void *pdrvPvt,asynUser *pasynUser);
    asynStatus (*ren) (void *pdrvPvt,asynUser *pasynUser, int onOff);
    void (*pollAddr)(void *pdrvPvt,asynUser *pasynUser,int addr, int onOff);
    void (*srqProcessing)(void *pdrvPvt,asynUser *pasynUser, int onOff);
    void (*srqSet)(void *pdrvPvt,asynUser *pasynUser,
        double srqTimeout,double pollTimeout,double pollRate,
        int srqMaxEvents);
    void (*srqGet)(void *pdrvPvt,asynUser *pasynUser,
        double *srqTimeout,double *pollTimeout,double *pollRate,
        int *srqMaxEvents);
    /* The following are called by low level gpib drivers */
    void *(*registerDriver)(void *pdrvPvt,const char *name);
    void (*srqHappened)(void *pdrvPvt); /*pvt is asynGpibUser pvt*/
}asynGpibUser;

typedef struct asynGpib {
    void (*report)(void *pdrvPvt,asynUser *pasynUser,int details);
    void (*connect)(void *pdrvPvt,asynUser *pasynUser);
    void (*disconnect)(void *pdrvPvt,asynUser *pasynUser);
    /*asynOctet methods */
    int (*read)(void *pdrvPvt,asynUser *pasynUser,int addr,char *data,int maxchars);
    int (*write)(void *pdrvPvt,asynUser *pasynUser,
                        int addr,const char *data,int numchars);
    asynStatus (*flush)(void *pdrvPvt,asynUser *pasynUser,int addr);
    asynStatus (*setEos)(void *pdrvPvt,asynUser *pasynUser,const char *eos,int eoslen);
    asynStatus (*installPeekHandler)(void *pdrvPvt,asynUser *pasynUser,peekHandler handler);
    asynStatus (*removePeekHandler)(void *pdrvPvt,asynUser *pasynUser);
    /*asynGpib methods*/
    asynStatus (*registerSrqHandler)(void *pdrvPvt,asynUser *pasynUser,
        int addr, srqHandler handler, void *userPrivate);
    asynStatus (*addressedCmd) (void *pdrvPvt,asynUser *pasynUser,
        int addr, char *data, int length);
    asynStatus (*universalCmd) (void *pdrvPvt, asynUser *pasynUser, int cmd);
    asynStatus (*ifc) (void *pdrvPvt,asynUser *pasynUser);
    asynStatus (*ren) (void *pdrvPvt,asynUser *pasynUser, int onOff);
    int (*srqStatus) (void *pdrvPvt);
    asynStatus (*srqEnable) (void *pdrvPvt, int onOff);
    asynStatus (*serialPollBegin) (void *pdrvPvt);
    int (*serialPoll) (void *pdrvPvt, int addr, double timeout);
    asynStatus (*serialPollEnd) (void *pdrvPvt);
}asynGpib;</pre>

<h3>asynGpibUser</h3>

<p>asynGpibUser describes the interface for user code. It provides gpib
specific functions like SRQ handling. It makes calls to a asynGpib. Note that
the gpib user support also implements the asynCommon and asynOctet
interraces.</p>

<table border="1">
  <caption>asynGpibUser</caption>
  <tbody>
    <tr>
      <td>registerSrqHandler</td>
      <td>Just passes the call to the low level driver.</td>
    </tr>
    <tr>
      <td>addressedCmd</td>
      <td>Just passes the call to the low level driver.</td>
    </tr>
    <tr>
      <td>universalCmd</td>
      <td>Just passes the call to the low level driver.</td>
    </tr>
    <tr>
      <td>ifc</td>
      <td>Just passes the call to the low level driver.</td>
    </tr>
    <tr>
      <td>ren</td>
      <td>Just passes the call to the low level driver.</td>
    </tr>
    <tr>
      <td>pollAddr</td>
      <td>Enable or disable SRQ polling of specified address.</td>
    </tr>
    <tr>
      <td>log</td>
      <td>Enable or disable logging of messages to/from specified
      address.</td>
    </tr>
    <tr>
      <td>srqProcessing</td>
      <td>Enable/disable srq handling from specified address</td>
    </tr>
    <tr>
      <td>srqSet</td>
      <td>Specify SRQ polling parameters.</td>
    </tr>
    <tr>
      <td>srqGet</td>
      <td>Get current SRQ polling parameters.</td>
    </tr>
    <tr>
      <td>registerDriver</td>
      <td>Register a driver. When asynGpibUser receives this request it calls
        asynManager registerDriver.</td>
    </tr>
    <tr>
      <td>srqHappened</td>
      <td>Called by driver when it detects that a GPIB device issues an
      SRQ.</td>
    </tr>
  </tbody>
</table>

<h3>asynGpib</h3>

<p>asynGpib is the interface that is implemented by gpib drivers, e.g. the
NI1014. It provides:</p>

<table border="1">
  <caption>asynGpib</caption>
  <tbody>
    <tr>
      <td>asynCommon methods</td>
      <td>All the methods of asynCommon</td>
    </tr>
    <tr>
      <td>asynOctet methods</td>
      <td>All the methods of asynOctet</td>
    </tr>
    <tr>
      <td>registerSrqHandler</td>
      <td>Register a callback to handle SRQs for specified addesss.</td>
    </tr>
    <tr>
      <td>addressedCmd</td>
      <td>Issue a GPIB addressed command.</td>
    </tr>
    <tr>
      <td>universalCmd</td>
      <td>Issue a GPIB universial command.</td>
    </tr>
    <tr>
      <td>ifc</td>
      <td>Issue a GPIB Interface Clear command.</td>
    </tr>
    <tr>
      <td>ren</td>
      <td>Issue a GPIB Remote Enable command</td>
    </tr>
    <tr>
      <td>srqStatus</td>
      <td>Returns (0,1) if SRQ (is not, is) set</td>
    </tr>
    <tr>
      <td>srqEnable</td>
      <td>Enable or disable SRQs.</td>
    </tr>
    <tr>
      <td>serialPollBegin</td>
      <td>Start of serial poll.</td>
    </tr>
    <tr>
      <td>serialPoll</td>
      <td>Poll the specified address and return its response.</td>
    </tr>
    <tr>
      <td>serialPollEnd</td>
      <td>End of serial poll.</td>
    </tr>
  </tbody>
</table>
<hr>

<center>
<h2><a name="License Agreement"></a>License Agreement</h2>
</center>
<pre>Copyright (c) 2002 University of Chicago All rights reserved.
asynDriver is distributed subject to the following license conditions:

SOFTWARE LICENSE AGREEMENT
Software: asynDriver

 1. The "Software", below, refers to devGpib (in either source code, or
    binary form and accompanying documentation). Each licensee is
    addressed as "you" or "Licensee."

 2. The copyright holders shown above and their third-party licensors
    hereby grant Licensee a royalty-free nonexclusive license, subject to
    the limitations stated herein and U.S. Government license rights.

 3. You may modify and make a copy or copies of the Software for use
    within your organization, if you meet the following conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement.
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy.

 4. You may modify a copy or copies of the Software or any portion of it,
    thus forming a work based on the Software, and distribute copies of
    such work outside your organization, if you meet all of the following
    conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement;
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy;
      c. Modified copies and works based on the Software must carry
         prominent notices stating that you changed specified portions of
         the Software.

 5. Portions of the Software resulted from work developed under a U.S.
    Government contract and are subject to the following license: the
    Government is granted for itself and others acting on its behalf a
    paid-up, nonexclusive, irrevocable worldwide license in this computer
    software to reproduce, prepare derivative works, and perform publicly
    and display publicly.

 6. WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" WITHOUT WARRANTY
    OF ANY KIND. THE COPYRIGHT HOLDERS, THEIR THIRD PARTY LICENSORS, THE
    UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR
    EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE, TITLE OR NON-INFRINGEMENT, (2) DO NOT ASSUME
    ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
    OR USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE
    SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT
    THAT THE SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE
    OR THAT ANY ERRORS WILL BE CORRECTED.

 7. LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT HOLDERS, THEIR
    THIRD PARTY LICENSORS, THE UNITED STATES, THE UNITED STATES DEPARTMENT
    OF ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, INCIDENTAL,
    CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE,
    INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY
    REASON WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF
    CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR
    OTHERWISE, EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
    POSSIBILITY OF SUCH LOSS OR DAMAGES.</pre>
</body>
</html>
