<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <title>asynDriver</title>
</head>

<body>

<center>
<h1>asynDriver: Asynchronous Driver Support</h1>

<p><span style="font-weight: bold; font-size: 14pt">Release 3.3</span></p>

<p><span style="font-weight: bold; font-size: 14pt">Marty Kraimer, Eric Norum
and Mark Rivers</span></p>

<p><span style="font-weight: bold; font-size: 14pt">September 23,
2004</span></p>
</center>
<hr>

<center>
<h2>License Agreement</h2>
</center>

<p>This product is available via the <a href="#LicenseAgreement">open source
license</a> described at the end of this document.</p>
<hr>

<center>
<h2>Contents</h2>
</center>
<a href="#Purpose">Purpose</a> <br>
<a href="#Status">Status</a> <br>
<a href="#Acknowledgments">Acknowledgments</a> <br>
<a href="#Overview">Overview of asynDriver</a> <br>
<a href="#asynDriver">asynDriver Structures and Interfaces</a> <br>
<a href="#standardMessageInterfaces">Standard Message Based Interfaces</a>
<br>
<a href="#standardRegisterInterfaces">Standard Registered Based
Interfaces</a> <br>
<a href="#otherInterfaces">Other Standard Interfaces</a> <br>
<a href="#interposeInterfaces">Standard Interpose Interfaces</a> <br>
<a href="#genericEpicsSupport">Generic Device Support for EPICS records</a>
<br>
<a href="#theoryOfOperation">Theory of Operation</a> <br>
<a href="#asynRecord">asynRecord: Generic Record Support</a> <br>
<a href="#Example">Example</a> <br>
<a href="#Test">Test Example</a> <br>
<a href="#asynGpib">asynGpib</a> <br>
<a href="#PortDrivers">Port Drivers</a>
<ul>
  <li><a href="#drvAsynSerialPort">Local Serial Port</a></li>
  <li><a href="#drvAsynIPPort">TCP/IP or UDP/IP Port</a></li>
  <li><a href="#vxi11">VXI-11</a></li>
  <li><a href="#gsIP488">Green Springs IP488</a></li>
  <li><a href="#ni1014">National Instruments GPIB-1014D</a></li>
</ul>
<a href="#DiagnosticAids">Diagnostic Aids</a> <br>
<a href="#InstallBuild">Install and Build</a> <br>

<hr>

<center>
<h2><a name="Purpose"></a>Purpose</h2>
</center>

<p>asynDriver is a general purpose facility for interfacing device specific
code to low level drivers, asynDriver makes it easy to implement  non
blocking device support that works with both blocking and non blocking
drivers.</p>

<p>A primary target for asynDriver is EPICS IOC device support but, other
than using libCom, much of it is independent of EPICS.</p>

<p>The following are some of the existing EPICS general purpose device
support systems that have been converted to use asynDriver.</p>
<ul>
  <li>gpibCore is the operating-system-independent version of the
    Winans/Franksen GPIB support.</li>
  <li>MPFOSI (Message Passing Facility). It is no longer needed or supported
    since asynDriver can completely replace MPF.</li>
  <li>synApps (The APS BCDA synchrotron applications).  The mca, dxp, serial, GPIB, Ip330,
      IpUnidig, DAC128V and quadEM applications in this package have all been converted
      to asyn.
</ul>

<p>The following are some of the existing EPICS general purpose device
support systems that could be converted to use asynDriver.</p>
<ul>
  <li>STREAMS is the protocol file-based support for serial/GPIB/CAN from
    Dirk Zimoch.</li>
  <li>devAscii/drvAscii is serial support from KECK Observatory.</li>
</ul>

<p>Each of these systems is used at EPICS facilities for accessing GPIB
and/or serial devices. Because device support has been written for many
instruments and thousands of database records use the device support, users
will not be easily persuaded to switch from their existing solution. Thus,
asynDriver implements a framework below device support that can be used by
all of the above systems so that all can share the same drivers.</p>

<p>Each system needs to be modified so that the device support component is
compatible with existing use, but replace the driver part with asynDriver.
The benefit is that all could share the same set of low level drivers.</p>

<p>gpibCore and mpfSerial have already been converted and are included with
asynDriver.</p>

<p>Hopefully Dirk Zimoch will get time soon to convert STREAMS, and Allen
Honey time to convert devAscii.</p>

<p>In the future, other protocols will be supported, especially for Ethernet
based devices.</p>
<hr>

<center>
<h2><a name="Status"></a>Status</h2>
</center>

<p>This version provides</p>
<ul>
  <li>asynManager: the software layer between device support and drivers.</li>
  <li>asynRecord: EPICS record support that provides a generic interface to
    asynManager, asynCommon, asynOctet, and asynGpib.</li>
  <li>standard interfaces: Standard message and register based interfaces are
    defined. Low Level Drivers are expected to implement standard interfaces
    whenever possible. Device support communicates with low level drivers via
    standard interfaces.</li>
  <li>devEpics: Generic device support for EPICS records.</li>
  <li>devGpib: EPICS device support that replaces the device support layer of
    the Winans/Franksen gpibCore support.</li>
  <li>asynGpib: a replacement for the drvGpibCommon layer of the Franksen
    gpibCore support.</li>
  <li>drvAsynSerialPort: Support for devices connected to serial ports.</li>
  <li>drvAsynIPPort: Support for devices connected to devices connected
    through Ethernet/Serial converter boxes, TCP/IP sockets or UDP/IP
  sockets.</li>
  <li>VXI-11: A replacement for the VXI-11 support of the Franksen gpibCore
    support.</li>
  <li>gsIP488: A low level driver for the Greensprings IP488 Industry Pack
    module.</li>
  <li>ni1014: A low level driver for the National Instruments VME 1014D.</li>
</ul>
<hr>

<center>
<h2><a name="Acknowledgments"></a>Acknowledgments</h2>
</center>

<p>The idea of creating asynDriver resulted from many years of experience
with writing device support for serial and GPIB devices. The following
individuals have been most influential.</p>
<dl>
  <dt>John Winans</dt>
    <dd>John provided the original EPICS GPIB support.  Databases using
      John's support can be used without modification with devGpib. With
      small modifications, device support modules written for John's support
      can be used.</dd>
  <dt>Benjamin Franksen</dt>
    <dd>John's support only worked on vxWorks. In addition, the driver
      support was implemented as a single source file. Benjamin defined an
      interface between drvCommon and low level controllers and split the
      code into drvGpib and the low level drivers. He also created the
      support for drvVxi11.</dd>
  <dt>Eric Norum</dt>
    <dd>Eric started with Benjamin's code and converted it to use the
      Operating System Independent features of EPICS 3.14.</dd>
  <dt>Marty Kraimer</dt>
    <dd>Marty started with Eric's version and made changes to support
      secondary addressing; and to replace ioctl with code to support general
      bus management, universal commands, and addressed commands.</dd>
  <dt>Pete Owens</dt>
    <dd>Pete, for the Diamond Light Source, did a survey of several types of
      device/driver support packages for serial devices. Diamond decided to
      use the  STREAMS support developed by Dirk Zimoch.</dd>
  <dt>Dirk Zimoch</dt>
    <dd>Dirk developed STREAMS, which has a single device support model, but
      supports arbitrary low level message based drivers, i.e. GPIB, serial,
      etc.</dd>
  <dt>Jun-ichi Odagare</dt>
    <dd>Jun-ichi developed NetDev, a system that provides EPICS device
      support for network based devices. It has a single device support
      model, but provides a general framework for communicating with network
      based devices.</dd>
</dl>
<hr>

<center>
<h2><a name="Overview"></a>Overview of asynDriver</h2>
</center>

<p>asynDriver is a software layer between device specific code and drivers
that communicate with devices. It supports both blocking and non-blocking
communication and can be used with both register and message based devices.
asynDriver defines the following terminology:</p>
<ul>
  <li>interface
    <p>All communication between software layers is done via interfaces. An
    interface definition is a C language structure consisting entirely of
    function pointers. An asynDriver interface is analogous to a C++ or Java
    pure virtual interface. Although the implementation is in C, the spirit
    is object oriented. Thus this document uses the term "member" rather than
    "function pointer".</p>
  </li>
  <li>port
    <p>A physical or logical entity which provides access to a device. 
       A port provides access to one or more devices.</p>
  </li>
  <li>portDriver
    <p>Code that communicates with a port.</p>
  </li>
  <li>port thread
    <p>If a portDriver can block, a thread is created for each port, and all
    I/O to the portDriver is done via this thread.</p>
  </li>
  <li>device
    <p>A device (instrument) connected to a port. For example a GPIB
    interface can have up to 15 devices connected to it. Other ports, e.g.
    serial ports, can only support a single device. Whenever this document
    uses the word device without a qualifier, it means something that is
    connected to a port.</p>
  </li>
  <li>synchronous
    <p>Support that does not voluntarily give up control of the CPU.</p>
  </li>
  <li>asynchronous
    <p>Support that is not synchronous. Some examples of asynchronous
    operations are epicsThreadSleep, epicsEventWait, and stdio operations.
    Calls to epicsMutexTake are considered to be synchronous operations, i.e.
    they are permitted in synchronous support.</p>
  </li>
  <li>asynDriver
    <p>This is the name for the support described in this manual. It is also
    the name of the header file that describes the core interfaces.</p>
  </li>
  <li>asynManager
    <p>The code which implements the asynManager and asynTrace methods.</p>
  </li>
  <li>asynchronous Driver
    <p>A driver that may block while communicating with a device. Typical
    examples are serial, gpib, and network based drivers.</p>
  </li>
  <li>synchronous Driver
    <p>A driver that does not block while communicating with a device.  
       Typical examples are VME register based devices.</p>
  </li>
  <li>Message Based Interfaces
    <p>Interfaces that use octet arrays for read/write operations.</p>
  </li>
  <li>Register Based Interfaces
    <p>Interfaces that use integers or floats for read/write operations.</p>
  </li>
</ul>

<p>Synchronous/asynchronous and message/register are orthogonal concepts. For
example a register based driver can be either synchronous or asynchronous.
The terminology register vs message is adapted from VXI.</p>

<p>Standard interfaces are defined so that most device specific code can
communicate with multiple port drivers. For example if device support does
all its communication via reads and writes consisting of 8 bit bytes
(octets), then it should work with all port drivers that support octet
messages. If device support requires more complicated support, then the types
of ports will be more limited. Standard interfaces are also defined for
drivers that accept 32 bit integers or 64 bit floats. Additional interfaces
can be defined, and it is expected that additional standard interfaces will
be defined.</p>

<p>One or more devices can be attached to a port. For example, only one
device can be attached to an RS-232 port, but up to 15 devices can be
attached to a GPIB port.</p>

<p>Multiple layers can exist between device specific code and a port driver.
A software layer calls interposeInterface in order to be placed between
device specific code and drivers. For more complicated protocols, additional
layers can be created. For example, GPIB support is implemented as an
asynGpib interface which is called by user code, and an asynGpibPort
interface which is called by asynGpib.</p>

<p>A driver normally implements multiple interfaces. For example asynGpib
implements asynCommon, asynOctet, and asynGpib.</p>

<p>asynManager uses the Operating System Independent features of EPICS base.
It is, however, independent of record/device support. Thus, it can be used by
other code, e.g. a sequence program.</p>

<h3>Standard Interfaces</h3>

<p>This section briefly describes the interfaces provided by asynManager and
standard interfaces implemented by port drivers. asynManager  members are
called by application threads. Except for asynCommon:report, port driver
methods can only be called from the user supplied callback passed in the call
to createAsynUser.</p>

<p>The interfaces are:</p>

<p><span style="font-weight: bold">asynManager</span> provides services for
communicating with a device connected to a port. The following services are
provided:</p>
<ul>
  <li>report - A method that reports the status of a specific port or of all ports.</li>
  <li>A thread for each port that can block.</li>
  <li>Methods  to connect/disconnect to a device or port.</li>
  <li>A method for locating port driver interfaces.</li>
  <li>queueRequest. This is a non-blocking method, i.e. it can be called from
    scan threads. If the portDriver does not block, queueRequest itself calls
    the process callback specified in the call to createAsynUser. It provides
    a lock so that multiple threads do not try to access the low level driver
    simultaneously. If the portDriver can block then the request is queued
    for the port thread. The user callback can make an arbitrary number of
    calls to the driver.</li>
  <li>Methods that provide a transaction service, i.e. members
    can lock out other users while multiple queueRequests are issued.</li>
  <li>Methods for registering ports and interfaces.</li>
  <li>Methods called by a driver when it connects or disconnects from a port
    or device.</li>
  <li>A method for interposing an interface between clients and drivers.</li>
  <li>Methods for enable and autoConnect.</li>
</ul>

<p><span style="font-weight: bold">asynCommon</span> is an interface that
must be implemented by all low level drivers. The methods are:</p>
<ul>
  <li>report - Report status of port.</li>
  <li>connect - Connect to the port or device.</li>
  <li>disconnect - Disconnect from the port or device.</li>
</ul>

<p><span style="font-weight: bold">asynTrace</span> is an interface for
generating diagnostic messages.</p>

<p><span style="font-weight: bold">asynDrvUser</span> is an interface for
communicating information from a user to a driver</p>

<p>In addition to these standard interfaces port drivers will implement one or
more of the message and/or register based interfaces described in later
sections.</p>

<h3>Brief Theory of Operation</h3>

<p>During initialization, port drivers register each communication port as
well as all supported interfaces.</p>

<p>User code creates an asynUser, which a "handle" for accessing asynDriver
facilities,  by calling</p>
<pre>    pasynManager-&gt;createAsynUser(processCallback,timeoutCallback);</pre>
An asynUser has the following features:
<ul>
  <li>An asynUser is the means by which asynManager manages multiple requests
    for accessing a port.</li>
  <li>processCallback is the addresss of a user supplied callback
  routine.</li>
  <li>timeoutCallback is the address of caller supplied callback that will be
    called if a queueRequest remains on the  queue for too long.</li>
  <li>Device support code should create an asynUser for each "atomic" access
    to low level drivers, i.e. a set of calls that must not be interlaced
    with other calls to the low level drivers. For example device support for
    EPICS record support should create an asynUser for each record
  instance.</li>
  <li>Device support code should NOT try to share an asynUser between
    multiple sources of requests for access to a port. If this is done then
    device support must itself handle contention issues that are already
    handled by asynManager.</li>
</ul>

<p>User code connects to a low level driver via a call to</p>
<pre>    status = pasynManager-&gt;connectDevice(pasynUser,portName,addr);</pre>
This call must specify the name of the port and the address of the device. It
then calls findInterface to locate the interfaces with which it calls the
driver.

<p>User code requests access to a port by calling:</p>
<pre>    status = pasynManager-&gt;queueRequest(pasynUser,priority,timeout);</pre>
This results in either the processCallback or timeoutCallback, passed to
createAsynUser, being called. All requests to the port must be made from
processCallback. A thread that calls queueRequest is guaranteed not to block
(assuming that processCallback does not block). If queueRequest is called for
a port that can block the request is queued to a thread dedicated to the
port. If queueRequest is called for a port does not block it just calls
processCallback. In either case asynManager guarantees that multiple threads
do not simultaneously call a low level driver. This guarantee is valid only
if low level drivers are only accessed by calling queueRequest.

<p>The following examples are based on EPICS IOC record/device support.</p>

<p>The first example shows access to a port that can block.</p>

<center>
<img name="AsynFlow" src="AsynFlow.jpg" border="1">

<p>Figure 1:  Asynchronous Control Flow</p>
</center>
The sequence of record device support events that occurs starting with an
application thread is pictured above in figure 1, and explained below in the
following steps:
<ol>
  <li>Record processing calls Record device support with record.PACT=0.</li>
  <li>Record device support calls queueRequest.</li>
  <li>queueRequest places the request on the driver work queue.  The
    application thread is now able to go on and perform other operations. All
    subsequent operations for this I/O request are handled in the port driver
    thread.</li>
  <li>The port thread removes the I/O request from the work queue.</li>
  <li>The port thread calls the processCallback located in Record device
    support.</li>
  <li>processCallback calls the low-level driver.</li>
  <li>The low-level driver read or write routine blocks until the I/O
    completes or until a timeout occurs.  The low-level driver routine
    returns the results of the I/O operation to processCallback which
    completes record processing.</li>
  <li>processCallback calls the record support process method.</li>
  <li>Record support calls Record device support again, this time with record.PACT=1.</li>
  <li>Record device support updates files in the record and returns.</li>
</ol>

<p>The second example shows access to a port that can block.</p>

<center>
<img name="AsynSynFlow" src="AsynSynFlow.jpg" border="1">

<p>Figure 2:  Synchronous Control Flow</p>
</center>
The sequence of record device support events that occurs starting with an
application thread is pictured above in figure 1, and explained below in the
following steps:
<ol>
  <li>Record processing calls Record device support.</li>
  <li>Record device support calls queueRequest.</li>
  <li>Since the port is synchronous, i.e. can not block, queueRequest calls
    processCallback.</li>
  <li>processCallback calls the low-level driver read or write routine.</li>
  <li>The low-level driver routine returns the results of the I/O operation
    to processCallback which completes record processing.</li>
</ol>

<h3>Comments: MARTY AND ERIC THESE COMMENTS DO NOT BELONG HERE</h3>
<ol>
  <li>STREAMS, devAscii, and mpfSerial need only asynManager and asynOctet.
    devGpib needs only asynManager, asynCommon, asynOctet, and asynGpib.</li>
  <li>It is expected that most users will connect to these interfaces via
    device support. However, other code can call it. Examples are sequence
    programs, test programs, utility commands, etc.</li>
  <li>Device support can consist of more than one type of support. For
    example most functions could be accessed via STREAMS, but asynGpib could
    be used to handle SRQs (service requests).</li>
</ol>
<hr>

<center>
<h2><a name="asynDriver"></a>asynDriver Structures and Interfaces</h2>
</center>

<p>asynDriver.h describes the following:</p>
<ul>
  <li>asynStatus - An enum that describes the status returned by many
  methods.</li>
  <li>asynException - An enum that describes exceptions.</li>
  <li>asynQueuePriority - An enum that describes the queue priorities.</li>
  <li>asynUser - A struture that contains generic information and is the
    "handle" for calling most methods.</li>
  <li>asynInterface - a structure that describes an interface.</li>
  <li>asynManager - An interface for communicating with asynDriver.</li>
  <li>asynCommon - An interface providing methods that must be implemented by
    all low level drivers.</li>
  <li>asynTrace - An interface plus associated functions and definitions that
    implement the trace facility.</li>
</ul>

<h3>asynStatus</h3>

<p>Defines the status returned by most methods.  If a method returns a status
other than asynSuccess, and one of the arguments to the method is pasynUser,
then the method is expected to write a message into
pasynUser-&gt;errorMessage.</p>
<pre>typedef enum {
    asynSuccess,asynTimeout,asynOverflow,asynError
}asynStatus;</pre>

<table border="1">
  <caption>asynStatus</caption>
  <tbody>
    <tr>
      <td>asynSuccess</td>
      <td>The request was successful.</td>
    </tr>
    <tr>
      <td>asynTimeout</td>
      <td>The request failed with a timeout.</td>
    </tr>
    <tr>
      <td>asynOverflow</td>
      <td>The driver has lost input data. This can happen if an internal
        buffer or the user supplied buffer is too small. Whenever possible,
        low level drivers must be written so that the user can read input in
        small pieces.</td>
    </tr>
    <tr>
      <td>asynError</td>
      <td>Some other error occured.</td>
    </tr>
  </tbody>
</table>

<h3>asynException</h3>

<p>Defines the exceptions for method exceptionOccurred</p>
<pre>typedef enum {
    asynExceptionConnect,asynExceptionEnable,asynExceptionAutoConnect,
    asynExceptionTraceMask,asynExceptionTraceIOMask,
    asynExceptionTraceFile,asynExceptionTraceIOTruncateSize
} asynException;</pre>

<table border="1">
  <caption>asynException</caption>
  <tbody>
    <tr>
      <td>asynExceptionConnect</td>
      <td>The connection state of the port or device has changed.</td>
    </tr>
    <tr>
      <td>asynExceptionEnable</td>
      <td>The enable state of the port or device has changed.</td>
    </tr>
    <tr>
      <td>asynExceptionAutoConnect</td>
      <td>The autoConnect state of the port or device has changed.</td>
    </tr>
    <tr>
      <td>asynExceptionTraceMask</td>
      <td>The traceMask for the port or device has changed.</td>
    </tr>
    <tr>
      <td>asynExceptionTraceIOMask</td>
      <td>The traceIOMask for the port or device has changed.</td>
    </tr>
    <tr>
      <td>asynExceptionTraceFile</td>
      <td>The trace file for the port or device has changed.</td>
    </tr>
    <tr>
      <td>asynExceptionTraceIOTruncateSize</td>
      <td>The traceIOTruncateSize for the port or device has changed.</td>
    </tr>
  </tbody>
</table>

<h3>asynQueuePriority</h3>

<p>This defines the priority passed to queueRequest.</p>
<pre>typedef enum {
    asynQueuePriorityLow,asynQueuePriorityMedium,asynQueuePriorityHigh,
    asynQueuePriorityConnect
}asynQueuePriority;</pre>

<table border="1">
  <caption>asynQueuePriority</caption>
  <tbody>
    <tr>
      <td>asynQueuePriorityLow</td>
      <td>Lowest queue priority.</td>
    </tr>
    <tr>
      <td>asynQueuePriorityMedium</td>
      <td>Medium queue priority.</td>
    </tr>
    <tr>
      <td>asynQueuePriorityHigh</td>
      <td>High queue priority.</td>
    </tr>
    <tr>
      <td>asynQueuePriorityConnect</td>
      <td>Queue a connect or disconnect request. This priority must be used
        only for connect/disconnect requests.</td>
    </tr>
  </tbody>
</table>

<h3>asynUser</h3>

<p>Describes a structure that user code passes to most asynManager and driver
methods. Code must allocate and free an asynUser by calling
asynManager:createAsynUser (or asynManager:dupliateAsynUser) 
and asynManager:freeAsynUser.</p>
<pre>typedef struct asynUser {
    char *errorMessage;
    int errorMessageSize;
    /* The following must be set by the user */
    double       timeout;  /*Timeout for I/O operations */
    void         *userPvt;   /* pointer to user private */
    void         *userData;a /* pointer to user data */
    /*The following is for user to/from driver communication*/
    void         *drvUser;
    int          auxStatus; /*For auxillary status*/
}asynUser;</pre>

<table border="1">
  <caption>asynUser</caption>
  <tbody>
    <tr>
      <td>errorMessage</td>
      <td>When a method returns asynError it should put an error message
        into errorMessage via a call to:
        <pre>epicsSnprintf(pasynUser-&gt;errorMessage,pasynUser-&gt;errorMessageSize,</pre>
        <pre>              "&lt;format&gt;",...)</pre>
      </td>
    </tr>
    <tr>
      <td>errorMessageSize</td>
      <td>The size of errorMessage. The user can not change this value.</td>
    </tr>
    <tr>
      <td>timeout</td>
      <td>The number of seconds before timeout for I/O requests. This is set
        by the user and can be changed between calls to drivers.

        <p>The user must provide a non zero value or many low level drivers
        will timeout. A timeout value &lt;= 0.0 means wait forever.</p>
      </td>
    </tr>
    <tr>
      <td>userPvt</td>
      <td>For use by the user. The user should set this immediately after the
        call to pasynManager-&gt;createAsynUser.

        <p>If this is changed while asynUser is queued, the results are
        undefined, e.g. it could cause a crash.</p>
      </td>
    </tr>
    <tr>
      <td>userData</td>
      <td>Also for use by the user.</td>
    </tr>
    <tr>
      <td>drvUser</td>
      <td>A driver can use this to hold asynUser specific data. The
        asynDrvUser interface is used for communication between asynUser and
        the driver.</td>
    </tr>
    <tr>
      <td>auxStatus</td>
      <td>Any method can provide additional return information in auxStatus.
        The meaning is determined by the method.</td>
    </tr>
  </tbody>
</table>

<h3>asynInterface</h3>

<p>This defines an interface registered with asynPortManager:registerPort or
asynManager:interposeInterface.</p>
<pre>typedef struct asynInterface{
    const char *interfaceType; /*For example, asynCommonType */
    void *pinterface;          /*For example, pasynCommon */
    void *drvPvt;
}asynInterface;</pre>

<table border="1">
  <caption>asynInterface</caption>
  <tbody>
    <tr>
      <td>interfaceType</td>
      <td>A character string describing the interface.</td>
    </tr>
    <tr>
      <td>pinterface</td>
      <td>A pointer to the interface. The user must cast this to the correct
        type.</td>
    </tr>
    <tr>
      <td>drvPvt</td>
      <td>For the exclusive use of the code that called registerPort or
        interposeInterface.</td>
    </tr>
  </tbody>
</table>

<h3>asynManager</h3>

<p>This is the main interface for communicating with asynDriver.</p>
<pre>/*registerPort attributes*/
#define ASYN_MULTIDEVICE  0x0001
#define ASYN_CANBLOCK     0x0002

typedef void (*userCallback)(asynUser *pasynUser);
typedef void (*exceptionCallback)(asynUser *pasynUser,asynException exception);

typedef struct asynManager {
    void      (*report)(FILE *fp,int details,const char *portName);
    asynUser  *(*createAsynUser)(userCallback process,userCallback timeout);
    asynUser  *(*duplicateAsynUser)(asynUser *pasynUser,
                                 userCallback queue,userCallback timeout);
    asynStatus (*freeAsynUser)(asynUser *pasynUser);
    void       *(*memMalloc)(size_t size);
    void       (*memFree)(void *pmem,size_t size);
    asynStatus (*isMultiDevice)(asynUser *pasynUser,
                                const char *portName,int *yesNo);
    /* addr = (-1,&gt;=0) =&gt; connect to (port,device) */
    asynStatus (*connectDevice)(asynUser *pasynUser,
                                const char *portName,int addr);
    asynStatus (*disconnect)(asynUser *pasynUser);
    asynStatus (*exceptionCallbackAdd)(asynUser *pasynUser,
                                       exceptionCallback callback);
    asynStatus (*exceptionCallbackRemove)(asynUser *pasynUser);
    asynInterface *(*findInterface)(asynUser *pasynUser,
                            const char *interfaceType,int interposeInterfaceOK);
    asynStatus (*queueRequest)(asynUser *pasynUser,
                              asynQueuePriority priority,double timeout);
    asynStatus (*cancelRequest)(asynUser *pasynUser,int *wasQueued);
    asynStatus (*canBlock)(asynUser *pasynUser,int *yesNo);
    asynStatus (*lock)(asynUser *pasynUser);   /*lock portName,addr */
    asynStatus (*unlock)(asynUser *pasynUser);
    asynStatus (*getAddr)(asynUser *pasynUser,int *addr);
    /* drivers call the following*/
    asynStatus (*registerPort)(const char *portName,
                              int attributes,int autoConnect,
                              unsigned int priority,unsigned int stackSize);
    asynStatus (*registerInterface)(const char *portName,
                              asynInterface *pasynInterface);
    asynStatus (*exceptionConnect)(asynUser *pasynUser);
    asynStatus (*exceptionDisconnect)(asynUser *pasynUser);
    /*any code can call the following*/
    asynStatus (*interposeInterface)(const char *portName, int addr,
                              asynInterface *pasynInterface,
                              asynInterface **ppPrev);
    asynStatus (*enable)(asynUser *pasynUser,int yesNo);
    asynStatus (*autoConnect)(asynUser *pasynUser,int yesNo);
    asynStatus (*isConnected)(asynUser *pasynUser,int *yesNo);
    asynStatus (*isEnabled)(asynUser *pasynUser,int *yesNo);
    asynStatus (*isAutoConnect)(asynUser *pasynUser,int *yesNo);
}asynManager;
epicsShareExtern asynManager *pasynManager;</pre>

<table border="1">
  <caption>asynManager</caption>
  <tbody>
    <tr>
      <td>report</td>
      <td>Reports status about the asynPortManager. If portName is non-NULL it reports
          for a specific port.  If portName is NULL then it reports for each registered 
          port. It also calls
        asynCommon:report for each port being reported.</td>
    </tr>
    <tr>
      <td>createAsynUser</td>
      <td>Creates an asynUser. The caller specifies two callbacks, process
        and timeout. These callback are only called as a result of a
        queueRequest. The timeout callback is optional. errorMessageSize
        characters are allocated for errorMessage. The amount of storage can
        not be changed. This method doesn't return if it is unable to
        allocate the storage.</td>
    </tr>
    <tr>
      <td>duplicateAsynUser</td>
      <td>Creates an asynUser by calling createAsynUser. It then initializes
        the new asynUser as follows: The fields .timeout,
        .userPvt, .userData, and .drvUser are initialized with values taken from pasynUser.
        Its connectDevice state is the same as that for pasynUser.</td>
    </tr>
    <tr>
      <td>freeAsynUser</td>
      <td>Free an asynUser. The user must free an asynUser only via this
        call. If the asynUser is connected to a port, disconnect is called.
        If the disconnect fails, this call will also fail. The storage for
        the asynUser is saved on a free list and will be reused in later
        calls to createAsynUser or duplicateAsynUser. Thus continually calling  
        createAsynUser (or duplicateAsynUser) and freeAsynUser is efficient.</td>
    </tr>
    <tr>
      <td>memMalloc</td>
      <td>Allocate memory. memMalloc/memFree maintain a set of freelists of
        different sizes. Thus any application that needs storage for a short
        time can use memMalloc/memFree to allocate and free the storage
        without causing memory fragmentation.</td>
    </tr>
    <tr>
      <td>memFree</td>
      <td>Free memory allocated by memMalloc. Size MUST be the same as the
        value specified in the call to memMalloc.</td>
    </tr>
    <tr>
      <td>isMultiDevice</td>
      <td>Answers the question "Does the port support multiple devices?" This
        method can be called before calling connectDevice.</td>
    </tr>
    <tr>
      <td>connectDevice</td>
      <td>Device code calls this to connect to a device. It passes the name
        of the communication port and the address of the device. The port
        Name is the same as that specified in the call to registerPort. The
        call will fail if the asynUser is already connected. If the port does
        not support multiple devices, than addr is ignored. The call will
        fail if the asynUser is already connected to a device. connectDevice
        only connects a user to the port driver for the portName,addr. The
        port driver may or may not be connected to the actual device. Thus,
        connectDevice and asynCommon:connect are completely different.

        <p>See the Theory of Operation section for a description of the
        difference between single and multi-device port drivers.</p>
      </td>
    </tr>
    <tr>
      <td>disconnect</td>
      <td>Disconnect from the port,addr to which connectDevice is connected.
        The call will fail  if the asynUser is queued or locked, or has an
        exception callback (MARTY - WHAT ABOUT A PROCESS CALLBACK?). Note that asynManager:disconnect and
        asynCommon:disconnect are completely different.</td>
    </tr>
    <tr>
      <td>exceptionCallbackAdd</td>
      <td>Callback will be called whenever one of the exceptions defined by
        asynException occurs. The callback can call isConnected, isEnabled,
        or isAutoConnect to find the new state.</td>
    </tr>
    <tr>
      <td>exceptionCallbackRemove</td>
      <td>Callback is removed. This must be called before disconnect.</td>
    </tr>
    <tr>
      <td>findInterface</td>
      <td>Find a driver interface. If interposeInterfaceOK is true, then
        findInterface returns the last interface registered or interposed.
        Otherwise, the interface registered by registerPort is returned. It
        returns 0 if the interfaceType is not supported.

        <p>The user  needs the address of the driver's interface and of
        pdrvPvt so that calls can be made to the driver. For example:</p>
        <pre>asynInterface *pasynInterface;
asynOctet *pasynOctet;
void *pasynOctetPvt;
...
pasynInterface = pasynManager-&gt;findInterface(
        pasynUser,asynOctetType,1);
if(!pasynInterface) { /*error do something*/}
pasynOctet = (asynOctet *)pasynInterface-&gt;pinterface;
pasynOctetPvt = pasynInterface-&gt;pdrvPvt;
/* The following call must be made from a callback */
pasynOctet-&gt;read(pasynOctetPvt,pasynUser,...
        </pre>
      </td>
    </tr>
    <tr>
      <td>queueRequest</td>
      <td>When registerPort is called, the caller must specify if it can
        block, i.e. attribute bit ASYN_CANBLOCK is set or cleared. If the
        port has been registered with ASYN_CANBLOCK true then the request is
        put on a queue for the thread associated with the queue. If the port
        has been registered with ASYN_CANBLOCK false then queueRequest just
        locks the port and calls the user callback. In either case the queue
        callback specified in the call to createAsynUser is called.

        <p>If the asynUser is already on a queue, asynError is returned. The
        timeout starts when the request is queued. A value less than or equal
        to 0.0 means no timeout. The request is removed from the queue before
        the callback is called. Thus callbacks are allowed to unlock and
        issue new queue requests. The priority asynQueuePriorityConnect must
        be used for asynCommon:connect and asynCommon:disconnect calls, and
        must NOT be used for any other calls.</p>

        <p> If a timeout callback was not passed to createAsynUser and a
        queueRequest with a non-zero timeout is requested, an error message
        is issued and no timeout will occur.</p>
      </td>
    </tr>
    <tr>
      <td>cancelRequest</td>
      <td>If a asynUser is queued, remove it from the queue. If either the
        process or timeout callback is active when cancelRequest is called
        than cancelRequest will not return until the callback completes.</td>
    </tr>
    <tr>
      <td>canBlock</td>
      <td>yesNo is set to (0,1), i.e. (false,true) if calls to the low level
        driver can block. The value is determined  by the attributes passed
        to registerPort.</td>
    </tr>
    <tr>
      <td>lock/unlock</td>
      <td>
        lock/unlock are used to block other users from accessing a device
        while a user is making a series of queueRequests. Only the addr
        specified in the connectDevice request is locked. asynManager locks
        when a queueRequest is taken from the queue. At that point all other
        entries in the queue must wait until unlock is called by the same
        pasynUser that locked. lock/unlock fail if a request is currently
        queued. The addr argument passed to connectDevice determines if the
        port or only a device is locked.
      </td>
    </tr>
    <tr>
      <td>getAddr</td>
      <td>*addr is set equal to the address which the user specified in the
        call to connectDevice or -1 if the port does not support multiple
        devices.

        <p>See the Theory of Operation section for a description of the
        difference between single and multi-device port drivers.</p>
      </td>
    </tr>
    <tr>
      <td>registerPort</td>
      <td>This method is called by drivers. A call is made for each
        communication interface instance. Attributes is a set of bits.
        Currently two bits are defined: ASYN_MULTIDEVICE and ASYN_CANBLOCK.
        The driver must specify these properly. autoConnect, which is (0,1)
        for (no,yes), provides the initial value for the port and all devices
        connected to the port. If priority is 0, then a default will be
        assigned. If stackSize is 0, a default is assigned. The portName
        argument specifies the name by which the upper levels of the asyn
        code will refer to this communication interface instance.</td>
    </tr>
    <tr>
      <td>registerInterface</td>
      <td>This is called by port drivers for each supported interface.</td>
    </tr>
    <tr>
      <td>exceptionConnect</td>
      <td>This method must be called by the driver when and only when it
        connects to a port or device.</td>
    </tr>
    <tr>
      <td>exceptionDisconnect</td>
      <td>This method must be called by the driver when and only when it
        disconnects from a port or device.</td>
    </tr>
    <tr>
      <td>interposeInterface</td>
      <td>This is called by a software layer between client code and the port
        driver. For example, if a device echos writes then a software module
        that issues a read after each write could be created and call
        interposeInterface for interface asynOctet.

        <p>Multiple interposeInterface calls for a port/addr/interface can be
        issued. *ppPrev is set to the address of the previous asynInterface.
        Thus the software module that last called interposeInterface is
        called by user code. It in turn can call the software module that was
        the second to last to call interposeInterface. This continues until
        the actual port driver is called.</p>

        <p>interposeInterface can also be called with an asynInterface that
        has not been previously registered or replaced. In this case *ppPrev
        will be null. Thus, new interfaces that are unknown to the low level
        driver can be implemented.</p>
      </td>
    </tr>
    <tr>
      <td>enable</td>
      <td>If enable is set yes, then queueRequests are not dequeued unless
        their queue timeout occurs.</td>
    </tr>
    <tr>
      <td>autoConnect</td>
      <td>If autoConnect is true and the port or device is not connected when
        a user callback is scheduled to be called, asynManager calls
        pasynCommon-&gt;connect. See the discussion of Flow of Control below
        for details.</td>
    </tr>
    <tr>
      <td>isConnected</td>
      <td>*yesNo is set to (0,1) if the port or device (is not, is)
      connected.</td>
    </tr>
    <tr>
      <td>isEnabled</td>
      <td>*yesNo is set to (0,1) if the port or device (is not, is)
      enabled.</td>
    </tr>
    <tr>
      <td>isAutoConnect</td>
      <td>*yesNo is set to (0,1) if the portThread (will not, will)
        autoConnect for the port or device.</td>
    </tr>
  </tbody>
</table>

<h3>asynCommon</h3>
<pre>/* Device Interface supported by ALL asyn drivers*/
#define asynCommonType "asynCommon"
typedef struct  asynCommon {
    void       (*report)(void *drvPvt,FILE *fp,int details);
    /*following are to connect/disconnect to/from hardware*/
    asynStatus (*connect)(void *drvPvt,asynUser *pasynUser);
    asynStatus (*disconnect)(void *drvPvt,asynUser *pasynUser);
}asynCommon;</pre>

<p>asynCommon describes the methods that must be implemented by drivers.</p>

<table border="1">
  <caption>asynCommon</caption>
  <tbody>
    <tr>
      <td>report</td>
      <td>Generates a report about the hardware device. This is the only
        asynCommon method that does not have to be called by the queueRequest
        callback.</td>
    </tr>
    <tr>
      <td>connect</td>
      <td>Connect to the hardware device or communication path. The
        queueRequest must specify priority asynQueuePriorityConnect.</td>
    </tr>
    <tr>
      <td>disconnect</td>
      <td>Disconnect from the hardware device or communication path. The
        queueRequest must specify priority asynQueuePriorityConnect.</td>
    </tr>
  </tbody>
</table>

<h3>Trace Interface</h3>
<pre>/*asynTrace is implemented by asynManager*/
/*All asynTrace methods can be called from any thread*/
/* traceMask definitions*/
#define ASYN_TRACE_ERROR     0x0001
#define ASYN_TRACEIO_DEVICE  0x0002
#define ASYN_TRACEIO_FILTER  0x0004
#define ASYN_TRACEIO_DRIVER  0x0008
#define ASYN_TRACE_FLOW      0x0010

/* traceIO mask definitions*/
#define ASYN_TRACEIO_NODATA 0x0000
#define ASYN_TRACEIO_ASCII  0x0001
#define ASYN_TRACEIO_ESCAPE 0x0002
#define ASYN_TRACEIO_HEX    0x0004

/* asynPrint and asynPrintIO are macros that act like
   int asynPrint(asynUser *pasynUser,int reason, const char *format, ... );
   int asynPrintIO(asynUser *pasynUser,int reason,
        const char *buffer, int len, const char *format, ... );
*/
typedef struct asynTrace {
    /* lock/unlock are only necessary if caller performs I/O other than*/
    /* by calling asynTrace methods                                    */
    asynStatus (*lock)(asynUser *pasynUser);
    asynStatus (*unlock)(asynUser *pasynUser);
    asynStatus (*setTraceMask)(asynUser *pasynUser,int mask);
    int        (*getTraceMask)(asynUser *pasynUser);
    asynStatus (*setTraceIOMask)(asynUser *pasynUser,int mask);
    int        (*getTraceIOMask)(asynUser *pasynUser);
    asynStatus (*setTraceFILE)(asynUser *pasynUser,FILE *fp);
    FILE       *(*getTraceFILE)(asynUser *pasynUser);
    asynStatus (*setTraceIOTruncateSize)(asynUser *pasynUser,int size);
    int        (*getTraceIOTruncateSize)(asynUser *pasynUser);
    int        (*print)(asynUser *pasynUser,int reason, const char *pformat, ...);
    int        (*printIO)(asynUser *pasynUser,int reason,
               const char *buffer, int len,const char *pformat, ...);
}asynTrace;
epicsShareExtern asynTrace *pasynTrace;</pre>

<h3>asynTrace</h3>

<p>asynDriver provides a trace facility with the following attributes:</p>
<ul>
  <li>Tracing is turned on/off for individual devices, i.e. a portName,
  addr.</li>
  <li>Trace has a global trace mask for asynUsers not connected to a port or
    port, addr.</li>
  <li>The output is sent to a file or to stdout.</li>
  <li>A mask determines the type of information that can be displayed. The
    various choices can be ORed together.
    <ul>
      <li>ASYN_TRACE_ERROR Run time errors are reported, e.g. timeouts.</li>
      <li>ASYN_TRACEIO_DEVICE High level device support reports I/O
      activity.</li>
      <li>ASYN_TRACEIO_FILTER Any layer between device support and the low
        level driver reports any filtering it does on I/O.</li>
      <li>ASYN_TRACEIO_DRIVER Low level driver reports I/O activity.</li>
      <li>ASYN_TRACE_FLOW Report logic flow. Device support should report all
        queue requests, callbacks entered, and all calls to drivers. Layers
        between device support and low level drivers should report all calls
        they make to lower level drivers. Low level drivers report calls they
        make to other support.</li>
    </ul>
  </li>
  <li>Another mask determines how message buffers are printed. The various
    choices can be ORed together.
    <ul>
      <li>ASYN_TRACEIO_NODATA Don't print any data from the message
      buffers.</li>
      <li>ASYN_TRACEIO_ASCII Print with a "%s" style format.</li>
      <li>ASYN_TRACEIO_ESCAPE Call epicsStrPrintEscaped.</li>
      <li>ASYN_TRACEIO_HEX    Print each byte with " %2.2x".</li>
    </ul>
  </li>
</ul>

<p>In order for the trace facility to perform properly; device support and
all drivers must use the trace facility. Device and driver support can
directly call the asynTrace methods. The asynPrint and asynPrintIO macros are
provided so that it is easier for device/driver support. Support can have
calls like:</p>
<pre>    asynPrint(pasynUser,ASYN_TRACE_FLOW,"%s Calling queueRequest\n",
        someName);</pre>

<p>The asynPrintIO call is designed for device support or drivers that issue
read or write requests. They make calls like:</p>
<pre>    asynPrintIO(pasynUser,ASYN_TRACEIO_DRIVER,data,nchars,"%s nchars %d",</pre>
<pre>                someName,nchars);</pre>

<p>The asynTrace methods are implemented by asynManager. These methods can be
used by any code that has created an asynUser and is connected to a device.
All methods can be called by any thread. That is, an application thread
and/or a port thread. If a thread performs all I/O via calls to print or
printIO, then it does not have to call lock or unlock. If it does want to do
its own I/O, it must lock before any I/O and unlock after. For example:</p>
<pre>    pasynTrace-&gt;lock(pasynUser);
    fd = pasynTrace-&gt;getTraceFILE(pasynUser);
    /*perform I/O of fd */
    pasynTrace-&gt;unlock(pasynUser);</pre>

<p>If the asynUser is not connected to a port, i.e.
pasynManager-&gt;connectDevice has not been called, then a "global" device is
assumed. This is useful when asynPrint is called before connectDevice.</p>

<table border="1">
  <caption>asynTrace</caption>
  <tbody>
    <tr>
      <td>lock/unlock</td>
      <td>These are only needed if some code wants to do its own I/O instead
        of using print and printIO.  The set methods, print, and printIO all
        lock while performing their operations. The get routines do not lock
        (except for getTraceFILE) and they are safe. The worst that happens
        is that the user gets a little more or a little less output.</td>
    </tr>
    <tr>
      <td>setTraceMask</td>
      <td>Set the trace mask. Normally set by the user requesting it via a
        shell command or the devTrace device support.</td>
    </tr>
    <tr>
      <td>getTraceMask</td>
      <td>Get the trace mask. Device support that wants to issue trace
        messages calls this to see what trace options have been
      requested.</td>
    </tr>
    <tr>
      <td>setTraceIOMask</td>
      <td>Set the traceIO mask. Normally set by the user requesting it via a
        shell command or the devTrace device support.</td>
    </tr>
    <tr>
      <td>getTraceIOMask</td>
      <td>Get the traceIO mask. Support that wants to issue its own IO
        messages instead of calling asynPrintIO should call this and honor
        the mask settings. Most code will not need it.</td>
    </tr>
    <tr>
      <td>setTraceFILE</td>
      <td>Set the stream to use for output. A NULL argument means use errlog.
        Normally set by the user requesting it via a shell command or by the
        devTrace device support. If the current output stream is none of
        (NULL, stdout, stderr) then the current output stream is closed
        before the new stream is used.</td>
    </tr>
    <tr>
      <td>getTraceFILE</td>
      <td>Get the file descriptor to use for output. Device support that
        wants to issue its own IO messages instead of calling asynPrintIO
        should call this and honor the mask settings. In this case, lock must
        have been called first. Most code will not need it. If the return
        value is 0, then ouput should be directed to errlog.</td>
    </tr>
    <tr>
      <td>setTraceIOTruncateSize</td>
      <td>Determines how much data is printed by printIO. In all cases it
        determines how many bytes of the buffer are displayed. The actual
        number of characters printed depends on the traceIO mask. For example
        ASYN_TRACEIO_HEX results in 3 characters being printed for each byte.
        Normally set by the user requesting it via a shell command or the
        devTrace device support.</td>
    </tr>
    <tr>
      <td>getTraceIOTruncateSize</td>
      <td>Get the current truncate size. Called by asynPrintIO. Code that
        does its own I/O should also support the traceIO mask.</td>
    </tr>
    <tr>
      <td>print</td>
      <td>If reason ORed with the current traceMask is not zero, then the
        message is printed. Most code should call asynPrint instead of
        calling this method.</td>
    </tr>
    <tr>
      <td>printIO</td>
      <td>If reason ORed with the current traceMask is not zero then the
        message is printed. If len is &gt;0, then the buffer is printed using
        the traceIO mask and getTraceIOTruncateSize. Most code should call
        asynPrintIO instead of calling this method.</td>
    </tr>
  </tbody>
</table>
<hr>

<center>
<h2><a name="standardMessageInterfaces"></a>Standard Message Based
Interfaces</h2>
</center>

<p>These are interfaces for communicating with message based devices, where
message based means that the device accepts octet strings, i.e. an array of 8
bit bytes, and responds with octet strings. Three interfaces are provided:
asynOctet, asynOctetSyncIO, and asynOctetTrapReadWrite. asynOctetSyncIO
provides a synchronous inteface to asynOctet and can be used by code that is
willing to block. asynOctetTrapReadWrite is an interposeInterface that can be
used to intercept calls to asynOctet.</p>

<h3>asynOctet</h3>
<pre>#define ASYN_EOM_CNT 0x0001 /*Request count reached*/
#define ASYN_EOM_EOS 0x0002 /*End of String detected*/
#define ASYN_EOM_END 0x0004 /*End indicator detected*/

#define asynOctetType "asynOctet"
typedef struct asynOctet{
    asynStatus (*read)(void *drvPvt,asynUser *pasynUser,
                       char *data,int maxchars,int *nbytesTransfered,
                       int *eomReason);
    asynStatus (*write)(void *drvPvt,asynUser *pasynUser,
                        const char *data,int numchars,int *nbytesTransfered);
    asynStatus (*flush)(void *drvPvt,asynUser *pasynUser);
    asynStatus (*setEos)(void *drvPvt,asynUser *pasynUser,
                         const char *eos,int eoslen);
    asynStatus (*getEos)(void *drvPvt,asynUser *pasynUser,
                        char *eos, int eossize, int *eoslen);
}asynOctet;</pre>

<p>NOTE: The name octet is used instead of ASCII because it implies that
communication is done via 8-bit bytes.</p>

<p>asynOctet describes the methods implemented by drivers that use octet
strings for sending commands and receiving responses from a device.</p>

<table border="1">
  <caption>asynOctet</caption>
  <tbody>
    <tr>
      <td>read</td>
      <td>Read a message from the device.  *nbytesTransfered is the number of
        8-bit bytes read from the device. If read returns asynSuccess than
        eomReason tells why the read completed.</td>
    </tr>
    <tr>
      <td>write</td>
      <td>Send a message to the device.  *nbytesTransfered is the number of
        8-bit bytes sent to the device.</td>
    </tr>
    <tr>
      <td>flush</td>
      <td>Flush the input buffer.</td>
    </tr>
    <tr>
      <td>setEos</td>
      <td>Set End Of String. For example "\n". Note that gpib drivers usually
        accept at most a one character string. If eoslen is equal to 0, the
        behaviour depends on the interface.  The asynInterposeEos asynOctet
        interface provides a read method which will not return until the
        specified number of characters have been been read or the time limit
        has been reached.</td>
    </tr>
    <tr>
      <td>getEos</td>
      <td>Get the current End of String.</td>
    </tr>
  </tbody>
</table>

<h3>asynOctetSyncIO</h3>
<pre>typedef struct asynOctetSyncIO {
   asynStatus (*connect)(const char *port, int addr, asynUser **ppasynUser);
   asynStatus (*disconnect)(asynUser *pasynUser);
   asynStatus (*openSocket)(const char *server, int port, char **portName);
   asynStatus (*write)(asynUser *pasynUser, char const *buffer, int buffer_len,
                  double timeout,int *nbytesTransfered);
   asynStatus (*read)(asynUser *pasynUser, char *buffer, int buffer_len,
                  const char *ieos, int ieos_len, int flush, double timeout,
                  int *nbytesTransfered,int *eomReason);
   asynStatus (*writeRead)(asynUser *pasynUser,
                  const char *write_buffer, int write_buffer_len,
                  char *read_buffer, int read_buffer_len,
                  const char *ieos, int ieos_len, double timeout,
                  int *nbytesOut, int *nbytesIn, int *eomReason);
   asynStatus (*flush)(asynUser *pasynUser);
   asynStatus (*writeOnce)(const char *port, int addr,
                  char const *buffer, int buffer_len, double timeout,
                  int *nbytesTransfered);
   asynStatus (*readOnce)(const char *port, int addr,
                  char *buffer, int buffer_len,
                  const char *ieos, int ieos_len, int flush, double timeout,
                  int *nbytesTransfered,int *eomReason);
   asynStatus (*writeReadOnce)(const char *port, int addr,
                  const char *write_buffer, int write_buffer_len,
                  char *read_buffer, int read_buffer_len,
                  const char *ieos, int ieos_len, double timeout,
                  int *nbytesOut, int *nbytesIn, int *eomReason);
} asynOctetSyncIO;
epicsShareExtern asynOctetSyncIO *pasynOctetSyncIO;</pre>

<p>asynOctetSyncIO provides a convenient interface for software that needs to
perform "synchronous" I/O to an asyn device, i.e. that starts an I/O
operation and then blocks while waiting for the response.&nbsp; The code does
not need to handle callbacks or understand the details of the asynManager and
asynOctet interfaces. Examples include motor drivers running in their own
threads, SNL programs, and the shell commands described later in this
document.</p>

<table border="1">
  <caption>asynOctetSyncIO</caption>
  <tbody>
    <tr>
      <td>connect</td>
      <td>Connects to an asyn port and address, returns a pointer to an
        asynUser structure.</td>
    </tr>
    <tr>
      <td>disconnect</td>
      <td>Disconnect. This frees all resources allocated by create.</td>
    </tr>
    <tr>
      <td>openSocket</td>
      <td>Opens a new connection to a TCP/IP or UDP/IP socket, returning the
        name of a newly created asyn port.&nbsp; The name of the port created
        is of the form "server:port [protocol]", i.e. "corvette:21" or
        "164.54.160.50:21" or "corvette:21 UDP".  </td>
    </tr>
    <tr>
      <td>write</td>
      <td>Calls asynOctet-&gt;write and waits for the operation to complete
        or time out.</td>
    </tr>
    <tr>
      <td>read</td>
      <td>Calls asynOctet-&gt;setEos (if ieos_len is non-zero), asynOctet
        flush (if flush=1), and asynOctet-&gt;read. Waits for the operation
        to complete or time out.</td>
    </tr>
    <tr>
      <td>writeRead</td>
      <td>Calls pasynOcter-&gt;write, asynOctet-&gt;setEos (if ieos_len is
        non-zero), asynOctet flush, and asynOctet-&gt;read.
        Waits for the operations to complete or time out.</td>
    </tr>
    <tr>
      <td>flush</td>
      <td>Calls pasynOctet-&gt;flush and waits for the operation to
      complete.</td>
    </tr>
    <tr>
      <td>writeOnce</td>
      <td>This does a connect, write, and disconnect.</td>
    </tr>
    <tr>
      <td>readOnce</td>
      <td>This does a connect, read, and disconnect.</td>
    </tr>
    <tr>
      <td>writeReadOnce</td>
      <td>This does a connect, writeRead, and disconnect.</td>
    </tr>
  </tbody>
</table>

<h3>asynOctetTrapReadWrite</h3>
<pre>#define asynOctetTrapReadWriteType "asynOctetTrapReadWrite"
typedef void (*asynOctetTrapReadWriteCallback) (asynUser *pasynUser,
    const char *data, int numchars, asynStatus status);

/* asynOctetTrapReadWrite methods are thread-safe but might block.
*  Thus, they can be called directly by a task that is allowed to
*  block, or indirectly with asynManager-&gt;queueRequest()
*  Note that, when using asynManager-&gt;queueRequest, a callback
*  cannot be installed or removed as long as some other asynUser has
*  locked the port/address.
*
*  Before pasynUser is freed, it must remove all callbacks that it has
*  previously installed or the system might crash!
*/

typedef struct asynOctetTrapReadWrite {
    asynStatus (*installReadCallback) (void *drvPvt, asynUser *pasynUser,
        asynOctetTrapReadWriteCallback callback);
    asynStatus (*installWriteCallback) (void *drvPvt, asynUser *pasynUser,
        asynOctetTrapReadWriteCallback callback);
    asynStatus (*removeReadCallback) (void *drvPvt, asynUser *pasynUser,
        asynOctetTrapReadWriteCallback callback);
    asynStatus (*removeWriteCallback) (void *drvPvt, asynUser *pasynUser,
        asynOctetTrapReadWriteCallback callback);
} asynOctetTrapReadWrite;

int epicsShareAPI asynOctetTrapReadWriteConfig(const char *portName, int addr);</pre>

<p>asynOctetTrapReadWriteConfig intercepts all asynOctet messages and calls
all registered callbacks for read and write messages.</p>

<table border="1">
  <caption>asynOctetTrapReadWrite</caption>
  <tbody>
    <tr>
      <td>installReadCallback</td>
      <td>install a callback that gets called after each read.</td>
    </tr>
    <tr>
      <td>installWriteCallback</td>
      <td>install a callback that gets called after each write.</td>
    </tr>
    <tr>
      <td>removeReadCallback</td>
      <td>remove callback.</td>
    </tr>
    <tr>
      <td>removeWriteCallback</td>
      <td>remove callback.</td>
    </tr>
  </tbody>
</table>
<hr>

<center>
<h2><a name="standardRegisterInterfaces"></a>Standard Register Based
Interfaces</h2>
</center>

<h3>Introduction</h3>

<p>This section descibes interfaces for the following classes of drivers:</p>
<ul>
  <li>Int32 - data is passed as 32 bit integers.
    <p>This class has the following interfaces:</p>
    <ul>
      <li>asynInt32 - read, write, getBounds.</li>
      <li>asynInt32Callback - registerCallback/cancelCallback to receive
        Int32 value.</li>
      <li>asynInt32Array - read/write arrays of Int32 values.</li>
      <li>asynInt32ArrayCallback - registerCallback/cancelCallback to receive
        arrays of Int32.</li>
      <li>asynInt32SyncIO - A synchronous interface to asynInt32</li>
    </ul>
  </li>
  <li>UInt32Digital - Data is passed as 32 bit unsigned integers and a mask
    that selects bits from the integer.
    <p>This class has the following interfaces:</p>
    <ul>
      <li>asynUInt32Digital - read/write.</li>
      <li>asynUInt32DigitalCallback - registerCallback/cancelCallback to
        receive UInt32 value. It also has methods to
        setInterrupt/getInterrupt/clearInterrupt.</li>
    </ul>
  </li>
  <li>Float64 - data is passed as double precision floats.
    <p>This class has the following interfaces:</p>
    <ul>
      <li>asynFloat64 - read/write.</li>
      <li>asynFloat64Callback - registerCallback/cancelCallback to receive
        Float64 value.</li>
      <li>asynFloat64Array - read/write arrays of Float64 values.</li>
      <li>asynFloat64ArrayCallback - registerCallback/cancelCallback to
        receive arrays of Float64.</li>
    </ul>
  </li>
</ul>

<p>NOTE: UInt32Digital and Float64 should also have synchronous interfaces.
This will be provided in the next release.</p>

<h3>addr - What does it mean?</h3>

<p>If a low level driver is declared multi-device the meaning of addr is:</p>
<ul>
  <li>Int32 - The driver supports an array of Int32 values. addr selects an
    array element. For example a 16 channel ADC would support addr 0 through
    15.</li>
  <li>Int32Array - Each addr is an array of Int32 values.</li>
  <li>Float64 - The driver supports an array of Float64 values. addr selects
    an array element.</li>
  <li>Float64Array - Each addr is an array of Float64 values.</li>
  <li>UInt32Digital - This remains to be determined. One possibility is that
    addr has the value
    <pre>    ind*32*32 + shift*32 + nbits</pre>
    where:
    <ul>
      <li>ind - The index that selects an element of an Int32 array.</li>
      <li>shift - Selects the low order bit on the Int32 value.</li>
      <li>nbits - The number of bits.</li>
    </ul>
    For example a driver for a 128 bit digital I/O module would support it as
    an array of four UInt32 registers. If:
    <pre> addr = 1156 = 1*32*32 + 4*32 + 4</pre>
    then bits 0x00F0 of the second register are selected. This rule should
    provide the proper behavior for trace, etc.</li>
</ul>

<h3>asynInt32</h3>
<pre>#define asynInt32Type "asynInt32"
typedef struct asynInt32{
    asynStatus (*write)(void *drvPvt, asynUser *pasynUser, epicsInt32 value);
    asynStatus (*read)(void *drvPvt, asynUser *pasynUser, epicsInt32 *value);
    asynStatus (*getBounds)(void *drvPvt, asynUser *pasynUser,
                            epicsInt32 *low, epicsInt32 *high);
}asynInt32;</pre>

<p>asynInt32 describes the methods implemented by drivers that use integers
for communicating with a device.</p>

<table border="1">
  <caption>asynInt32</caption>
  <tbody>
    <tr>
      <td>write</td>
      <td>Write an integer value to the device.</td>
    </tr>
    <tr>
      <td>read</td>
      <td>Read an integer value from the device.</td>
    </tr>
    <tr>
      <td>getBounds</td>
      <td>Get the bounds. This is useful for EPICS device support that does linear
          conversion from device units to engineering units.</td>
    </tr>
  </tbody>
</table>

<h3>asynInt32Callback</h3>
<pre>#define asynInt32CallbackType "asynInt32Callback"
/*cancelCallback cancels based on callback and userPvt */
typedef struct asynInt32Callback {
    asynStatus (*registerCallback)(void *drvPvt, asynUser *pasynUser,
                             void (*callback)(void *userPvt, epicsInt32 data),
                             void *userPvt);
    asynStatus (*cancelCallback)(void *drvPvt, asynUser *pasynUser,
                             void (*callback)(void *userPvt, epicsInt32 data),
                             void *userPvt);
} asynInt32Callback;
 </pre>

<p>asynInt32Callback provides methods for drivers that collect data and make
it available to registered clients. An example is an interrupt based
driver.</p>

<table border="1">
  <caption>asynInt32Callback</caption>
  <tbody>
    <tr>
      <td>registerCallback</td>
      <td>Registers a callback that will be called whenever new data is available.</td>
    </tr>
    <tr>
      <td>cancelCallback</td>
      <td>Cancels the callback.  Callback and userPvt must match the values passed to
          registerCallback.</td>
    </tr>
  </tbody>
</table>

<h3>asynInt32Array</h3>
<pre>#define asynInt32ArrayType "asynInt32Array"
typedef struct asynInt32Array{
    asynStatus (*write)(void *drvPvt, asynUser *pasynUser,
                       epicsInt32 value, size_t nelements);
    asynStatus (*read)(void *drvPvt, asynUser *pasynUser,
                      epicsInt32 *value, size_t nelements, size_t *nIn);
}asynInt32Array;</pre>

<p>asynInt32Array describes the methods implemented by drivers that use
arrays of integers for communicating with a device.</p>

<table border="1">
  <caption>asynInt32Array</caption>
  <tbody>
    <tr>
      <td>write</td>
      <td>Write an array of integers to a device.</td>
    </tr>
    <tr>
      <td>read</td>
      <td>Read an array of integers from a device.</td>
    </tr>
  </tbody>
</table>

<h3>asynInt32ArrayCallback</h3>
<pre>#define asynInt32ArrayCallbackType "asynInt32ArrayCallback"
/*cancelCallback cancels based on callback and userPvt */
typedef struct asynInt32ArrayCallback {
    asynStatus (*registerCallback)(void *drvPvt, asynUser *pasynUser,
             void (*callback)(void *userPvt,epicsInt32 *val,epicsUInt32 nelem),
             void *userPvt);
    asynStatus (*cancelCallback)(void *drvPvt, asynUser *pasynUser,
             void (*callback)(void *userPvt,epicsInt32 *val,epicsUInt32 nelem),
             void *userPvt);
} asynInt32ArrayCallback;</pre>

<p>asynInt32ArrayCallback provides methods for drivers that collect data and
make it available to registered clients. An example is an interrupt based
driver.</p>

<table border="1">
  <caption>asynInt32ArrayCallback</caption>
  <tbody>
    <tr>
      <td>registerCallback</td>
      <td>Register a callback that is called whenever new data is
      available.</td>
    </tr>
    <tr>
      <td>cancelCallback</td>
      <td>Cancel the callback.  Callback and userPvt must match the values passed to
          registerCallback.</td>
    </tr>
  </tbody>
</table>

<h3>asynInt32SyncIO</h3>
<pre>#define asynInt32SyncIOType "asynInt32SyncIO"
typedef struct asynInt32SyncIO {
    asynStatus (*connect)(const char *port, int addr, asynUser **ppasynUser);
    asynStatus (*disconnect)(asynUser *pasynUser);
    asynStatus (*write)(asynUser *pasynUser, epicsInt32 value,double timeout);
    asynStatus (*read)(asynUser *pasynUser, epicsInt32 *pvalue,double timeout);
    asynStatus (*getBounds)(asynUser *pasynUser,
                            epicsInt32 *plow, epicsInt32 *phigh);
    asynStatus (*writeOnce)(const char *port, int addr,
                            epicsInt32 value,double timeout);
    asynStatus (*readOnce)(const char *port, int addr,
                            epicsInt32 *pvalue,double timeout);
    asynStatus (*getBoundsOnce)(const char *port, int addr,
                            epicsInt32 *plow, epicsInt32 *phigh);
} asynInt32SyncIO;
epicsShareExtern asynInt32SyncIO *pasynInt32SyncIO;</pre>

<p>asynInt32SyncIO describes a synchronous interrace to asynInt32. The code
that calls it must be willing to block.</p>

<table border="1">
  <caption>asynInt32SyncIO</caption>
  <tbody>
    <tr>
      <td>connect</td>
      <td>Connects to a port and address, returns a pointer to an asynUser
        structure.</td>
    </tr>
    <tr>
      <td>disconnect</td>
      <td>Disconnect. This frees all resources allocated by create.</td>
    </tr>
    <tr>
      <td>write</td>
      <td>Calls pasynInt32-&gt;write and waits for the operation to complete
        or time out.</td>
    </tr>
    <tr>
      <td>read</td>
      <td>Calls pasynInt32-&gt;read and waits for the operation to complete
        or time out.</td>
    </tr>
    <tr>
      <td>getBounds</td>
      <td>Calls pasynInt32-&gt;getBounds and waits for the operation to
        complete or time out.</td>
    </tr>
    <tr>
      <td>writeOnce</td>
      <td>This does a connect, write, and disconnect.</td>
    </tr>
    <tr>
      <td>readOnce</td>
      <td>This does a connect, read, and disconnect.</td>
    </tr>
    <tr>
      <td>getBoundsOnce</td>
      <td>This does a connect, getBounds, and disconnect.</td>
    </tr>
  </tbody>
</table>

<h3>asynUInt32Digital</h3>
<pre>#define asynUInt32DigitalType "asynUInt32Digital"
typedef struct asynUInt32Digital {
    asynStatus (*write)(void *drvPvt, asynUser *pasynUser,
         epicsUInt32 value, epicsUInt32 mask);
    asynStatus (*read)(void *drvPvt, asynUser *pasynUser,
        epicsUInt32 *value, epicsUInt32 mask);
} asynUInt32Digital;</pre>

<p>asynUInt32Digital  describes the methods for communicating via bits of an
Int32 register.</p>

<table border="1">
  <caption>asynUInt32Digital</caption>
  <tbody>
    <tr>
      <td>write</td>
      <td>Modify the bits specified by mask with the corresponding bits in
        value.</td>
    </tr>
    <tr>
      <td>read</td>
      <td>Read the bits specified by mask into value. The other bits of value
        will be set to 0.</td>
    </tr>
  </tbody>
</table>

<h3>asynUInt32DigitalCallback</h3>
<pre>typedef enum {
    interruptOnZeroToOne, interruptOnOneToZero, interruptOnBoth
} interruptReason;

#define asynUInt32DigitalCallbackType "asynUInt32DigitalCallback"
/*cancelCallback cancels based on callback, mask, and userPvt */
typedef struct asynUInt32DigitalCallback {
    asynStatus (*registerCallback)(void *drvPvt, asynUser *pasynUser,
        void (*callback)(void *userPvt, epicsUInt32 data),
        epicsUInt32 mask, void *userPvt);
    asynStatus (*cancelCallback)(void *drvPvt, asynUser *pasynUser,
        void (*callback)(void *userPvt, epicsUInt32 data),
        epicsUInt32 mask, void *userPvt);
    asynStatus (*setInterrupt)(void *drvPvt, asynUser *pasynUser,
        epicsUInt32 mask, interruptReason reason);
    asynStatus (*clearInterrupt)(void *drvPvt, asynUser *pasynUser,
        epicsUInt32 mask);
    asynStatus (*getInterrupt)(void *drvPvt, asynUser *pasynUser,
        epicsUInt32 *mask, interruptReason reason);
} asynUInt32DigitalCallback;</pre>

<p>asynUInt32Digital  describes methods for communicating with interupt
driven drivers.</p>

<table border="1">
  <caption>asynUInt32DigitalCallback</caption>
  <tbody>
    <tr>
      <td>registerCallback</td>
      <td>Register a callback that will be called whenever the driver detects
        a change in any of the bits specified by mask.</td>
    </tr>
    <tr>
      <td>cancelCallback</td>
      <td>Cancels the registered callback. Callback, mask and userPvt must
        all match the values passed to registerCallback.</td>
    </tr>
    <tr>
      <td>setInterrupt</td>
      <td>Enable interrupts on bits specified by mask.</td>
    </tr>
    <tr>
      <td>clearInterrupt</td>
      <td>Disable  interrupts on bits specified by mask.</td>
    </tr>
    <tr>
      <td>getInterrupt</td>
      <td>Get enabled interrupt bits</td>
    </tr>
  </tbody>
</table>

<h3>asynFloat64</h3>
<pre>#define asynFloat64Type "asynFloat64"
typedef struct asynFloat64 {
    asynStatus (*write)(void *drvPvt, asynUser *pasynUser, epicsFloat64 value);
    asynStatus (*read)(void *drvPvt, asynUser *pasynUser, epicsFloat64 *value);
} asynFloat64;</pre>

<p>asynFloat64  describes the methods for communicating via IEEE double
precision float values.</p>

<table border="1">
  <caption>asynFloat64</caption>
  <tbody>
    <tr>
      <td>write</td>
      <td>Write a value.</td>
    </tr>
    <tr>
      <td>read</td>
      <td>Read a value.</td>
    </tr>
  </tbody>
</table>

<h3>asynFloat64Callback</h3>
<pre>#define asynFloat64CallbackType "asynFloat64Callback"
/*cancelCallback cancels based on callback and userPvt */
typedef struct asynFloat64Callback {
    asynStatus (*registerCallback)(void *drvPvt, asynUser *pasynUser,
                        void (*callback)(void *userPvt, epicsFloat64 data),
                        void *userPvt);
    asynStatus (*cancelCallback)(void *drvPvt, asynUser *pasynUser,
                        void (*callback)(void *userPvt, epicsFloat64 data),
                        void *userPvt);
} asynFloat64Callback;</pre>

<p>asynFloat64Callback is like asynInt32Callback except that it uses Float64
values</p>

<table border="1">
  <caption>asynFloat64Callback</caption>
  <tbody>
    <tr>
      <td>registerCallback</td>
      <td>Register a callback that is called whenever new data is
      available.</td>
    </tr>
    <tr>
      <td>cancelCallback.  Callback and userPvt must match the values passed to
          registerCallback.</td>
      <td>Cancel the callback</td>
    </tr>
  </tbody>
</table>

<h3>asynFloat64Array</h3>
<pre>#define asynFloat64ArrayType "asynFloat64Array"
typedef struct asynFloat64Array {
    asynStatus (*write)(void *drvPvt, asynUser *pasynUser,
                       epicsFloat64 *value, size_t nelements);
    asynStatus (*read)(void *drvPvt, asynUser *pasynUser,
                       epicsFloat64 *value, size_t nelements, size_t *nIn);
} asynFloat64Array;</pre>

<p>asynFloat64Array  describes the methods for communicating via IEEE double
precision float values.</p>

<table border="1">
  <caption>asynFloat64Array</caption>
  <tbody>
    <tr>
      <td>write</td>
      <td>Write an array of values.</td>
    </tr>
    <tr>
      <td>read</td>
      <td>Read an array of values.</td>
    </tr>
  </tbody>
</table>

<h3>asynFloat64ArrayCallback</h3>
<pre>#define asynFloat64ArrayCallbackType "asynFloat64ArrayCallback"
/*cancelCallback cancels based on callback and userPvt */
typedef struct asynFloat64ArrayCallback {
    asynStatus (*registerCallback)(void *drvPvt, asynUser *pasynUser,
         void (callback)(void *userPvt, epicsFloat64 *data,epicsUInt32 nelems),
         void *userPvt);
    asynStatus (*cancelCallback)(void *drvPvt, asynUser *pasynUser,
         void (callback)(void *userPvt, epicsFloat64 *data,epicsUInt32 nelems),
         void *userPvt);
} asynFloat64ArrayCallback;</pre>

<p>asynFloat64ArrayCallback is like asynInt32Callback except that it uses an
array of Float64 values</p>

<table border="1">
  <caption>asynFloat64ArrayCallback</caption>
  <tbody>
    <tr>
      <td>registerCallback</td>
      <td>Register a callback that is called whenever new data is
      available.</td>
    </tr>
    <tr>
      <td>cancelCallback</td>
      <td>Cancel the callback</td>
    </tr>
  </tbody>
</table>
<hr>

<center>
<h2><a name="otherInterfaces"></a>Other Standard Interfaces</h2>
</center>

<h3>asynDrvUser</h3>
<pre>#define asynDrvUserType "asynDrvUser"
typedef struct  asynDrvUser {
    /*The following do not have to be called via queueRequest callback*/
    asynStatus (*create)(void *drvPvt,asynUser *pasynUser,
        const char *drvInfo, const char **pptypeName,size_t *psize);
    asynStatus (*getType)(void *drvPvt,asynUser *pasynUser,
        const char **pptypeName,size_t *psize);
    asynStatus (*destroy)(void *drvPvt,asynUser *pasynUser);
}asynDrvUser;</pre>

<p>asynDrvUser provides methods that allow an asynUser to communicate user
specific information to/from a port driver</p>

<table border="1">
  <caption>asynDrvUser</caption>
  <tbody>
    <tr>
      <td>create</td>
      <td>The driver can create any resources it needs. It can use
        asynUser.drvUser to provide access to the resources. If the asynUser
        and the driver both know about how to access the resources they must
        agree and a name for the resource and a size. If pptypeName is not
        null the the driver can give a value to *pptypeName. If psize is not
        null the driver can give a value to *psize. Unless asynUser receives
        a typeName and size that it recognizes it must not access
        asynUser.drvUser.</td>
    </tr>
    <tr>
      <td>getType</td>
      <td>If other code, e.g. an interposeInterface wants to access
        asynUser.drvUser it must call this and verify that typeName and size
        are what it expects.</td>
    </tr>
    <tr>
      <td>destroy</td>
      <td>Destroy the resources created by create and set asynUser.drvUser
        null.</td>
    </tr>
  </tbody>
</table>

<h3>asynOption</h3>
<pre>#define asynOptionType "asynOption"
/*The following are generic methods to set/get device options*/
typedef struct asynOption {
    asynStatus (*setOption)(void *drvPvt, asynUser *pasynUser,
                                const char *key, const char *val);
    asynStatus (*getOption)(void *drvPvt, asynUser *pasynUser,
                                const char *key, char *val, int sizeval);
}asynOption;</pre>

<p>asynOption provides a generic way of setting driver specific options. For
example the serial port driver uses this to specify baud rate, stop bits,
etc.</p>

<table border="1">
  <caption>asynOption</caption>
  <tbody>
    <tr>
      <td>setOption</td>
      <td>Set value associated with key.</td>
    </tr>
    <tr>
      <td>getOption</td>
      <td>Get value associated with key.</td>
    </tr>
  </tbody>
</table>
<hr>

<center>
<h2><a name="interposeInterfaces"></a>Standard Interpose Interfaces</h2>
</center>

<h2>asynInterposeEos</h2>

<p>This can be used to simulate EOS processing for asynOctet if the port
driver doesn't provide EOS support. If an EOS is specified it looks for the
eos on each read. It is started by the shell command:</p>
<pre>    asynInterposeEosConfig port addr</pre>

<p>where</p>
<ul>
  <li>port is the name of the port.</li>
  <li>addr is the address</li>
</ul>

<p>this command should appear immediately after the command that initializes
a port</p>

<h2>asynInterposeFlush</h2>

<p>This can be used to simulate flush processing for asynOctet if the port
driver doesn't provide support for flush. It just reads and discards
characters until no more characters arive before timeout seconds have
occured. It is started by the shell command:</p>
<pre>    asynInterposeFlushConfig port addr timeout</pre>

<p>where</p>
<ul>
  <li>port is the name of the port.</li>
  <li>addr is the address</li>
  <li>timeout is the time to wait for more characters</li>
</ul>

<p>this command should appear immediately after the command that initializes
a port</p>
<hr>

<center>
<h2><a name="genericEpicsSupport"></a>Generic Device Support for EPICS
records</h2>
</center>

<p>NOTE: The generic device support for epics records is in an early stage of
development. It will likely
evolve rapidly over the next several releases of asynDriver.</p>

<p>Generic device support is provided for standard EPICS records. This
support should be usable for a large class of low level register based
drivers. For truly complicated devices other support is required.</p>

<p>The support uses the following conventions for DTYP and INP or OUT.</p>
<pre>    field(DTYP,"asynXXX")
    field(INP,"@asyn(portName,addr,timeout) drvParams")
     or
    field(OUT,"@asyn(portName,addr,timeout) drvParams")</pre>
<pre>where</pre>
<ul>
  <li>XXX - The name of the type of interface supported.</li>
  <li>portName - The name of the port.</li>
  <li>addr - The address. If addr is not specified the default is 0.</li>
  <li>timeout - The timeout value for asynUser.timeout. If not specified the
    default is 1.0.</li>
  <li>drvParams - This is passed to the low level driver via the asynDrvUser
    interface. This this is a way to pass information to the low level driver
    at initialization time.</li>
</ul>

<p>For example:</p>
<pre>    field(DTYP,"asynInt32")
    field(INP,"@asyn(portA,0,.1) thisIsForDriver")</pre>

<h2>analog device support</h2>

<p>The following support is available:</p>
<pre>device(ai,INST_IO,asynAiInt32,"asynInt32")
device(ai,INST_IO,asynAiFloat64,"asynFloat64")
device(ai,INST_IO,asynAiInt32Average,"asynInt32Average")
device(ai,INST_IO,asynAiFloat64Average,"asynFloat64Average")
device(ai,INST_IO,asynAiInt32Interrupt,"asynInt32Interrupt")
device(ai,INST_IO,asynAiFloat64Interrupt,"asynFloat64Interrupt")
device(ao,INST_IO,asynAoInt32,"asynInt32")
device(ao,INST_IO,asynAoFloat64,"asynFloat64")</pre>

<p>Support for drivers that implement interface Int32 and/or Float64. The
Interrupt and Average support requires that the driver supports the
asynInt32Callback and/or asynFloat64Callback interfaces.  If Interrupt is
chosen the record normally has SCAN set to "I/O Intr". A record with one of
the Average supports is normally periodically scanned. Each time the record
processes it receives the average of all the values obtained via callbacks since the last
time the record processed.</p>

<h2>digital device support</h2>

<p>The following support is available:</p>
<pre>device(bi,INST_IO,asynBiUInt32Digital,"asynUInt32Digital")
device(bo,INST_IO,asynBoUInt32Digital,"asynUInt32Digital")
device(longin,INST_IO,asynLiUInt32Digital,"asynUInt32Digital")
device(longout,INST_IO,asynLoUInt32Digital,"asynUInt32Digital")
device(mbbi,INST_IO,asynMbbiUInt32Digital,"asynUInt32Digital")
device(mbbo,INST_IO,asynMbboUInt32Digital,"asynUInt32Digital")
device(mbbiDirect,INST_IO,asynMbbiDirectUInt32Digital,"asynUInt32Digital")
device(mbboDirect,INST_IO,asynMbboDirectUInt32Digital,"asynUInt32Digital")
</pre>

<p>
<p>Support for drivers that implement interface asynUInt32Digital
and optionally asynUInt32DigitalCallback. If asynUInt32DigitalCallback is
available then input records can be declared "I/O Intr" scanned.
</p>

</p>
<h2>octet device support</h2>

<p>The following support is available:</p>
<pre>device(stringin,INST_IO,asynSiOctetCmdResponse,"asynOctetCmdResponse")
device(stringin,INST_IO,asynSiOctetWriteRead,"asynOctetWriteRead")
device(stringin,INST_IO,asynSiOctetRead,"asynOctetRead")
device(stringout,INST_IO,asynSoOctetWrite,"asynOctetWrite")
device(waveform,INST_IO,asynWfOctetCmdResponse,"asynOctetCmdResponse")
device(waveform,INST_IO,asynWfOctetWriteRead,"asynOctetWriteRead")
device(waveform,INST_IO,asynWfOctetRead,"asynOctetRead")
device(waveform,INST_IO,asynWfOctetWrite,"asynOctetWrite")</pre>

<p>Support for drivers that implement interface asynOctet. The support is for
stringin/stringout and waveform records. The waveform support is similar to
the string support. The waveform records must define FTVL to be CHAR or
UCHAR, i.e. it must be an array of octets. The waveform provides the
following features not provided by the string support:</p>
<ul>
  <li>unlimited size - string records hold a maximum of 40 characters.</li>
  <li>non ascii - Thus arbitrary octet arrays are supported.</li>
</ul>

<p>Four types of support are provided:</p>
<ul>
  <li>CmdResponse The INP field is of the form:
    <pre>    field(INP,"@asyn(portName,addr,timeout) cmd")</pre>
    During record initialization, cmd is converted by dbTranslateEscape. The
    resultant string is the command to send to the device. When the record is
    processed the command is sent to the device and the response read into
    the record.</li>
  <li>WriteRead The INP field is of the form:
    <pre>    field(INP,"@asyn(portName,addr,timeout) pvname")</pre>
    pvname must refer to a field in a record in the same IOC. During record
    initialization the pvname is locatedd. When the record is processed dbGet
    is called to read the current value of pvname. This value is sent to the
    device. A read is then issued and the result stored in the record. For
    asynSiOctetWriteRead, the value obtained from pvname is passed through
    dbTranslateEscape before sending it. For asynWfOctetWriteRead it is not
    passed through dbTranslateEscape. MARTY THIS IS NOT BEING DONE. FIX
  IT.</li>
  <li>Write The INP(OUT) field is of the form:
    <pre>    field(INP,"@asyn(portName,addr,timeout) drvUser")</pre>
    drvUser is information that is passed to the portDriver if it implements
    interface asynDrvUser. When the record is processed the value stored in
    the record is sent to the device.</li>
  <li>Read The INP field is of the form:
    <pre>    field(INP,"@asyn(portName,addr,timeout) drvUser")</pre>
    drvUser is information that is passed to the portDriver if it implements
    interface asynDrvUser. When the record is processed a read request is
    made. The result is read into the record.</li>
</ul>
<hr>

<center>
<h2><a name="theoryOfOperation"></a>Theory of Operation</h2>
</center>

<h3>Multiple Device vs Single Device Port Drivers</h3>

<p>When a low level driver calls registerPort, it declares if it handles
multiple devices. This determines how the addr argument to connectDevice is
handled and what getAddr returns.</p>
<ul>
  <li>multiDevice false
    <p>The addr argument to connectDevice is ignored and getAddr always
    returns -1</p>
  </li>
  <li>multiDevice true
    <p>If connectDevice is called with addr&lt;0, the connection is to the
    port (MARTY - WHAT IS CONNECTION TO THE PORT USED FOR?) and getAddr always returns -1. If addr&gt;=0, then the caller is
    connected to the device at the specified address. getAddr will return
    this address.</p>
  </li>
</ul>

<h3>Connection Management</h3>

<p>asynManager keeps track of the following states:</p>
<ul>
  <li>connection
    <p>Is the port or device connected? This state is initialized to
    disconnected.</p>
  </li>
  <li>enabled
    <p>Is the port or device enabled? This state is initialized to
    enabled.</p>
  </li>
  <li>autoConnect
    <p>Does asynManager call connect if it finds the port or device
    disconnected? This is initialized to the state specified in the call to
    registerPort.</p>
  </li>
</ul>

<p>If the port does not support multiple devices, then port and device status
are the same. If the port does support multiple devices, then asynManager
keeps track of the states for the port and for every device connected to the
port.</p>

<p>Whenever any of the states change for a port or device, then all users
that previously called exceptionCallbackAdd for that port or device are
called.</p>

<p>Low level drivers must call pasynManager:exceptionConnect whenever they
connect to a port or port,addr and must call exceptionDisconnect whenever
they disconnect.</p>

<h3>Flow of Control</h3>

<p>The methods asynManager:report and asynCommon:report can be called by any
thread, but the caller is blocked until the report finishes. The following
discussion applys to all methods except report.</p>

<p>The asynManager methods can be called by any thread including portThread.
None of these methods (except report) block.</p>

<p>Unless stated otherwise the methods for other interfaces must only be
called by the queue callback specified in the call to createAsynUser, i.e.
queueRequest must be called.</p>

<h3>portThread</h3>

<p>If a driver calls asynManager:registerPort with the ASYN_CANBLOCK bit of
attributes set then asynManager creates a thread for the port. Each
portThread has its own set of queues for the calls to queueRequest.
portThread runs forever implementing the following algorithm:</p>
<ol>
  <li>Wait for work by calling epicsEventMustWait. Other code such as
    queueRequest call epicsEventSignal.</li>
  <li>If the port is disabled, return 1.</li>
  <li>For every element in queue, asynQueuePriorityConnect:
    <ul>
      <li>Removes the element from the queue.</li>
      <li>Calls the user's callback</li>
    </ul>
  </li>
  <li>If the port is not connected and autoConnect is true for the port, then
    attempt to connect to the port.</li>
  <li>If the port is still not connected, return 1.</li>
  <li>For each element of the queues asynQueuePriorityHigh,
    ...,asynQueuePriorityLow.
    <ul>
      <li>If disabled, skip this element.</li>
      <li>If not connected and autoConnect is true for the device, then
        attempt to connect to the device.</li>
      <li>If not connected, skip this element.</li>
      <li>If locked by another thread, skip this element.</li>
      <li>If not locked and user has requested lock, then lock.</li>
      <li>Remove from queue and call user callback.</li>
    </ul>
  </li>
</ol>

<p>The actual code is more complicated because it unlocks before it calls
code outside asynManager. This means that the queues can be modified and
exceptions may occur.</p>
<hr>

<center>
<h2><a name="asynRecord"></a>asynRecord: Generic EPICS Record Support</h2>
</center>

<p>A special record type asynRecord is provided. Details are described in <a
href="asynRecord.html">asynRecord</a>. This section provides a brief
description of how to use it.</p>

<p></p>

<p>Each IOC can load one or more instances of asynRecord. An example is:</p>
<pre>cd $(ASYN)
dbLoadRecords("db/asynRecord.db","P=asyn,R=Test,PORT=L0,ADDR=15,IMAX=0,OMAX=0")</pre>

<p>The example creates a record with name "asynTest" (formed from the
concatenation of the P and R macros) that will connect to port "L0" and addr
15. After the ioc is started, it is possible to change PORT and/or ADDR.
Thus, a single record can be used to access all asyn devices connected to the
IOC. Multiple records are only needed if one or more devices need a dedicated
record.</p>

<p>An medm display is available for accessing an asynRecord. It is started as
follows:</p>
<pre>cd &lt;asyn&gt;/medm
medm -x -macro "P=asyn,R=Test" asynRecord.adl</pre>

<p>The following medm display appears.</p>

<p><img src="./asynRecord.gif" alt="asynRecord" width="500" height="700"></p>

<center>
<h2><a name="Example"></a>Example</h2>
</center>

<p>The following reads from a device via octet messages:</p>
<pre>#include &lt;asynDriver.h&gt;
...
#define BUFFER_SIZE 80
typedef struct myData {
    epicsEventId done;
    asynOctet    *pasynOctet;
    void         *drvPvt;
    char         buffer[BUFFER_SIZE];
}myData;

static void queueCallback(asynUser *pasynUser) {
    myData     *pmydata = (myData *)pasynUser-&gt;userPvt;
    asynOctet  *pasynOctet = pmydata-&gt;pasynOctet;
    void       *drvPvt = pmydata-&gt;drvPvt;
    asynStatus status;
    int        writeBytes,readBytes;
    int        eomReason;

    asynPrint(pasynUser,ASYN_TRACE_FLOW,"queueCallback entered\n");
    status = pasynOctet-&gt;write(drvPvt,pasynUser,pmydata-&gt;buffer,
              strlen(pmydata-&gt;buffer),&amp;writeBytes);
    if(status!=asynSuccess) {
        asynPrint(pasynUser,ASYN_TRACE_ERROR,
            "queueCallback write failed %s\n",pasynUser-&gt;errorMessage);
    } else {
        asynPrintIO(pasynUser,ASYN_TRACEIO_DEVICE,
            pmydata-&gt;buffer,strlen(pmydata-&gt;buffer),
            "queueCallback write sent %d bytes\n",writeBytes);
    }
    status = pasynOctet-&gt;read(drvPvt,pasynUser,pmydata-&gt;buffer,
         BUFFER_SIZE,&amp;readBytes,&amp;eomReason);
    if(status!=asynSuccess) {
        asynPrint(pasynUser,ASYN_TRACE_ERROR,
            "queueCallback read failed %s\n",pasynUser-&gt;errorMessage);
    } else {
        asynPrintIO(pasynUser,ASYN_TRACEIO_DEVICE,
            pmydata-&gt;buffer,BUFFER_SIZE,
            "queueCallback read returned: retlen %d eomReason 0x%x data %s\n",
            readBytes,eomReason,pmydata-&gt;buffer);
    }
    if(pmydata-&gt;done) epicsEventSignal(pmydata-&gt;done);
}

static void asynExample(const char *port,int addr,const char *message)
{
    myData        *pmyData;
    asynUser      *pasynUser;
    asynStatus    status;
    asynInterface *pasynInterface;
    int           canBlock;

    pmyData = (myData *)pasynManager-&gt;memMalloc(sizeof(myData));
    memset(pmyData,0,sizeof(myData));
    strcpy(pmyData-&gt;buffer,message);
    pasynUser = pasynManager-&gt;createAsynUser(queueCallback,0);
    pasynUser-&gt;userPvt = pmyData;
    status = pasynManager-&gt;connectDevice(pasynUser,port,addr);
    if(status!=asynSuccess) {
        printf("can't connect to serialPort1 %s\n",pasynUser-&gt;errorMessage);
        exit(1);
    }
    pasynInterface = pasynManager-&gt;findInterface(
        pasynUser,asynOctetType,1);
    if(!pasynInterface) {
        printf("%s driver not supported\n",asynOctetType);
        exit(-1);
    }
    pmyData-&gt;pasynOctet = (asynOctet *)pasynInterface-&gt;pinterface;
    pmyData-&gt;drvPvt = pasynInterface-&gt;drvPvt;
    canBlock = 0;
    pasynManager-&gt;canBlock(pasynUser,&amp;canBlock);
    if(canBlock) pmyData-&gt;done = epicsEventCreate(epicsEventEmpty);
    status = pasynManager-&gt;queueRequest(pasynUser,asynQueuePriorityLow, 0.0);
    if(status) {
        asynPrint(pasynUser,ASYN_TRACE_ERROR,
            "queueRequest failed %s\n",pasynUser-&gt;errorMessage);
    }
    if(canBlock) epicsEventWait(pmyData-&gt;done);
    status = pasynManager-&gt;freeAsynUser(pasynUser);
    if(status) {
        asynPrint(pasynUser,ASYN_TRACE_ERROR,
            "freeAsynUser failed %s\n",pasynUser-&gt;errorMessage);
    }
    epicsEventDestroy(pmyData-&gt;done);
    pasynManager-&gt;memFree(pasynUser-&gt;userPvt,sizeof(myData));
}</pre>

<p>The flow of control is as follows:</p>
<ol>
  <li>A port driver calls registerPort. This step is not shown in the above
    example.</li>
  <li>asynExample allocates myData and an asynUser.</li>
  <li>asynExample connects to a device and to the asynOctet interface for the
    port driver.</li>
  <li>When it is ready to communicate with the driver it calls
  queueRequest.</li>
  <li>queueCallback is called. It calls the port driver's write and read
    methods.</li>
</ol>
<hr>

<center>
<h2><a name="Test"></a>Test Application</h2>
</center>

<p>The asynDriver distribution includes code to test asynDriver. It is also
an example of how to interface to asynManager. The example resides in
&lt;top&gt;/testApp and contains the following components:</p>
<pre>Db/
   test.db
adl/
   test.adl
src/
   devAsynTest.c
   devAsynTest.dbd
   echoDriver.c
   interposeInterface.c</pre>

<p>echoDriver is a port driver that echos messages it receives. It implements
asynCommon and asynOctet. When asynOctet:write is called it saves the
message. When asynOctet:read is called, the saved message is returned and the
message is flushed. echoDriverInit has an argument that determines if it acts
like a multiDevice or a single device port driver.</p>

<p>An instance of echoDriver is started via the iocsh command:</p>
<pre>echoDriverInit(portName,delay,noAutoConnect,multiDevice)</pre>

<p>where</p>
<ul>
  <li>portName - the port name for this instance.</li>
  <li>delay - The time to delay after a read or write. If delay is 0 then
    echoDriver registers as a synchronous port driver, i.e. bit ASYN_CANBLOCK
    of attributes is not set. If delay&gt;0 then ASYN_CANBLOCK is set.</li>
  <li>noAutoConnect - Determines initial setting for port.</li>
  <li>multiDevice - If true then it supports two devices with addresses 0 and
    1. If false it does not set ASYN_MULTIDEVICE, i.e. it only supports a
    single device.</li>
</ul>

<p>test.db is a template containing three records: a calc record, which
forward links to a stringout record which forward links to a stringin record.
The string records attach to the device support supplied by devAsynTest.c.
The stringout and stringin records share the same asynUser. When the
stringout record processes it:</p>
<ul>
  <li>Fetches the current value from the calc record (converted to
  ascii).</li>
  <li>Calls pasynManager-&gt;lock.</li>
  <li>Calls pasynManager-&gt;queueRequest.</li>
  <li>The callback calls pasynOctet-&gt;write and then asks for the record to
    complete processing.</li>
  <li>The stringout record forward links to the stringin record.
    <p></p>
  </li>
</ul>
The stringin records does the following:
<ul>
  <li>Calls pasynManager-&gt;queueRequest.</li>
  <li>The callback routine:
    <ul>
      <li>calls pasynOctet-&gt;read</li>
      <li>Checks what it received vs what the stringout record wrote. If the
        values match, it sets its VAL field to "OK",  otherwise it writes an
        error message into VAL.</li>
      <li>Asks for the record to complete processing.</li>
    </ul>
  </li>
  <li>The stringin record calls pasynManager-&gt;unlock.</li>
</ul>

<p>devAsynTest also does additional checking for connect state and
enable/disable.</p>

<p>Executing "medm -x test.adl"  produces the display:</p>

<p><img src="./asynTest.gif" alt="asynTest" width="760" height="189"></p>

<p>It assumes that an ioc has been started via:</p>
<pre>cd &lt;top&gt;/iocBoot/ioctest
../../bin/solaris-sparc/test st.cmd</pre>

<p>This starts two versions of echoDriver as port "A" and "B". port A acts as
single device port. port B acts as a multiDevice port that has two devices.
For each of the three possible devices, the st.cmd file starts up two sets of
records from test.db The st.cmd file also loads a set of records from
asynTest.db for port A and for port B and for each of the two devices
attached to port B. It also loads a set of records from asynGeneric.db.</p>
<hr>

<center>
<h2><a name="asynGpib"></a>asynGpib</h2>
</center>

<p>GPIB has additional features that are not supported by asynCommon and
asynOctet. asynGpib defines two interfaces.</p>
<ul>
  <li>asynGpib - This is the interface that device support calls. It provides
    the following:
    <ul>
      <li>A set of GPIB specific methods that device support can call.</li>
      <li>Code that handles generic GPIB functions like SRQ polling.</li>
      <li>A registerPort method which is called by GPIB port drivers.
        <p></p>
      </li>
    </ul>
  </li>
  <li>asynGpibPort - A set of methods implemented by GPIB drivers</li>
</ul>

<h3>asynGpibDriver.h</h3>

<p>asynGpibDriver.h contains the following definitions:</p>
<pre>#include "asynDriver.h"
#define asynGpibType "asynGpib"
#define asynGpibType "asynGpib"
/* GPIB drivers */
typedef void (*srqHandler)(void *userPrivate,int gpibAddr,int statusByte);
typedef struct asynGpib asynGpib;
typedef struct asynGpibPort asynGpibPort;
/*asynGpib defines methods called by gpib aware users*/
struct asynGpib{
    /*addressedCmd,...,ren are just passed to device handler*/
    asynStatus (*addressedCmd) (void *drvPvt,asynUser *pasynUser,
        const char *data, int length);
    asynStatus (*universalCmd) (void *drvPvt,asynUser *pasynUser,int cmd);
    asynStatus (*ifc) (void *drvPvt,asynUser *pasynUser);
    asynStatus (*ren) (void *drvPvt,asynUser *pasynUser, int onOff);
    /* The following are implemented by asynGpib */
    asynStatus (*registerSrqHandler)(void *drvPvt,asynUser *pasynUser,
        srqHandler handler, void *srqHandlerPvt);
    void (*pollAddr)(void *drvPvt,asynUser *pasynUser, int onOff);
    /* The following are called by low level gpib drivers */
    /*srqHappened is passed the pointer returned by registerPort*/
    void *(*registerPort)(
        const char *portName,
        int attributes,int autoConnect,
        asynGpibPort *pasynGpibPort, void *asynGpibPortPvt,
        unsigned int priority, unsigned int stackSize);
    void (*srqHappened)(void *asynGpibPvt);
};
epicsShareExtern asynGpib *pasynGpib;

struct asynGpibPort {
    /*asynCommon methods */
    void (*report)(void *drvPvt,FILE *fd,int details);
    asynStatus (*connect)(void *drvPvt,asynUser *pasynUser);
    asynStatus (*disconnect)(void *drvPvt,asynUser *pasynUser);
    /*asynOctet methods passed through from asynGpib*/
    asynStatus (*read)(void *drvPvt,asynUser *pasynUser,
                      char *data,int maxchars,int *nbytesTransfered,
                      int *eomReason);
    asynStatus (*write)(void *drvPvt,asynUser *pasynUser,
                      const char *data,int numchars,int *nbytesTransfered);
    asynStatus (*flush)(void *drvPvt,asynUser *pasynUser);
    asynStatus (*setEos)(void *drvPvt,asynUser *pasynUser,
                const char *eos,int eoslen);
    asynStatus (*getEos)(void *drvPvt,asynUser *pasynUser,
                char *eos, int eossize, int *eoslen);
    /*asynGpib methods passed thrtough from asynGpib*/
    asynStatus (*addressedCmd) (void *drvPvt,asynUser *pasynUser,
                const char *data, int length);
    asynStatus (*universalCmd) (void *drvPvt, asynUser *pasynUser, int cmd);
    asynStatus (*ifc) (void *drvPvt,asynUser *pasynUser);
    asynStatus (*ren) (void *drvPvt,asynUser *pasynUser, int onOff);
    /*asynGpibPort specific methods */
    asynStatus (*srqStatus) (void *drvPvt,int *isSet);
    asynStatus (*srqEnable) (void *drvPvt, int onOff);
    asynStatus (*serialPollBegin) (void *drvPvt);
    asynStatus (*serialPoll) (void *drvPvt, int addr, double timeout,int *status);
    asynStatus (*serialPollEnd) (void *drvPvt);
};</pre>

<h3>asynGpib</h3>

<p>asynGpib describes the interface for device support code. It provides gpib
specific functions like SRQ handling. It makes calls to asynGpibPort. Note
that asynGpib.c also implements asynCommon and asynOctet.</p>

<table border="1">
  <caption>asynGpib</caption>
  <tbody>
    <tr>
      <td>addressedCmd</td>
      <td>The request is passed to the low level driver.</td>
    </tr>
    <tr>
      <td>universalCmd</td>
      <td>The request is passed to the low level driver.</td>
    </tr>
    <tr>
      <td>ifc</td>
      <td>The request is passed to the low level driver.</td>
    </tr>
    <tr>
      <td>ren</td>
      <td>The request is passed to the low level driver.</td>
    </tr>
    <tr>
      <td>registerSrqHandler</td>
      <td>Register an srq handler for device. The handler will be called when
        an SRQ is detected for that device.</td>
    </tr>
    <tr>
      <td>pollAddr</td>
      <td>Set SRQ polling on or off. onOff = (0,1) means (disable, enable)
        SRQ polling of specified address.</td>
    </tr>
    <tr>
      <td>registerPort</td>
      <td>Register a port. When asynGpib receives this request, it calls
        asynManager.registerPort.</td>
    </tr>
    <tr>
      <td>srqHappened</td>
      <td>Called by low level driver when it detects that a GPIB device
        issues an SRQ.</td>
    </tr>
  </tbody>
</table>

<h3>asynGpibPort</h3>

<p>asynGpibPort is the interface that is implemented by gpib drivers, e.g.
the VXI-11. It provides:</p>

<table border="1">
  <caption>asynGpibPort</caption>
  <tbody>
    <tr>
      <td>asynCommon methods</td>
      <td>All the methods of asynCommon</td>
    </tr>
    <tr>
      <td>asynOctet methods</td>
      <td>All the methods of asynOctet</td>
    </tr>
    <tr>
      <td>addressedCmd</td>
      <td>Issue a GPIB addressed command.</td>
    </tr>
    <tr>
      <td>universalCmd</td>
      <td>Issue a GPIB universal command.</td>
    </tr>
    <tr>
      <td>ifc</td>
      <td>Issue a GPIB Interface Clear command.</td>
    </tr>
    <tr>
      <td>ren</td>
      <td>Issue a GPIB Remote Enable command</td>
    </tr>
    <tr>
      <td>srqStatus</td>
      <td>If return is asynSuccess then isSet is (0,1) if SRQ (is not, is)
        active. Normally only called by asynGpib.</td>
    </tr>
    <tr>
      <td>srqEnable</td>
      <td>Enable or disable SRQs. Normally only called by asynGpib.</td>
    </tr>
    <tr>
      <td>serialPollBegin</td>
      <td>Start of serial poll. Normally only called by asynGpib.</td>
    </tr>
    <tr>
      <td>serialPoll</td>
      <td>Poll the specified address and set status to the response. Normally
        only called by asynGpib.</td>
    </tr>
    <tr>
      <td>serialPollEnd</td>
      <td>End of serial poll. Normally only called by asynGpib.</td>
    </tr>
  </tbody>
</table>
<hr>

<center>
<h2><a name="PortDrivers"></a>Port Drivers</h2>
</center>

<h3><a name="drvAsynSerialPort"></a>Local Serial Port</h3>

<p>The drvAsynSerialPort driver supports devices connected to serial ports on
the IOC.</p>

<p>Serial ports are configured with the <tt>drvAsynSerialPortConfigure</tt>
and <tt>asynSetOption</tt> commands:</p>
<pre>   drvAsynSerialPortConfigure("portName","ttyName",priority,noAutoConnect,noEos)
   asynSetOption("portName",addr,"key","value")</pre>
where the arguments are:
<ul>
  <li>portName - The portName that is registered with asynGpib.</li>
  <li>ttyName - The name of the local serial port (e.g. "/dev/ttyS0").</li>
  <li>priority - Priority at which the asyn I/O thread will run. If this is
    zero or missing,then epicsThreadPriorityMedium is used.</li>
  <li>noAutoConnect - Zero or missing indicates that portThread should
    automatically connect.  Non-zero if explicit connect command must be
    issued.</li>
  <li>noEos - Zero or missing indicates that the generic EOS handler will be
    interposed.  Non-zero will not interpose the EOS handler.</li>
  <li>addr - This argument is ignored since serial devices are configured
    with multiDevice=0.</li>
</ul>

<p>The setEos and getEos methods have no effect and return asynError.  The
read method blocks until at least one character has been received or until a
timeout occurs.  The read method transfers as many characters as possible,
limited by the specified count. asynInterposeEos can be used to support
EOS.</p>

<p>The following table summarizes the drvAsynSerialPort driver asynSetOption
keys and values. Default values are enclosed in square brackets.</p>

<table border="1">
  <tbody>
    <tr>
      <th>Key</th>
      <th>Value</th>
    </tr>
    <tr>
      <td>baud</td>
      <td>[9600] 50 75 110 134 150 200 300 600 1200 ... 230400</td>
    </tr>
    <tr>
      <td>bits</td>
      <td>[8] 7 6 5</td>
    </tr>
    <tr>
      <td>parity</td>
      <td>[none] even odd</td>
    </tr>
    <tr>
      <td>stop</td>
      <td>[1] 2</td>
    </tr>
    <tr>
      <td>clocal</td>
      <td>[Y] N</td>
    </tr>
    <tr>
      <td>ctrscts</td>
      <td>[N] Y</td>
    </tr>
  </tbody>
</table>

<p></p>

<p>The clocal and crtscts parameter names are taken from the POSIX termios
serial interface definition. The clocal parameter controls whether the modem
control lines (Data Terminal Ready, Carrier Detect/Received Line Signal
Detect) are used (clocal=N) or ignored (clocal=Y). The crtscts parameter
controls whether the hardware handshaking lines (Request To Send, Clear To
Send) are used (crtscts=Y) or ignored (crtscts=N). The default parameter
values (clocal=Y, crtscts=N) are those of a 'data-leads-only' serial
interface.</p>

<p>The vxWorks serial driver does not provide independent control of the
hardware handshaking and modem control lines, thus clocal=Y implies crtscts=N
and clocal=N implies crtscts=Y.</p>

<p>vxWorks IOC serial ports may need to be set up using hardware-specific
commands. Once this is done, the standard drvAsynSerialPortConfigure and
asynSetOption commands can be issued.  For example, the following example
shows the configuration procedure for a port on a GreenSprings octal UART
Industry-Pack module on a GreenSprings VIP616-01 carrier.</p>
<pre>ipacAddVIPC616_01("0x6000,B0000000")
tyGSOctalDrv(1)
tyGSOctalModuleInit("RS232", 0x80, 0, 0)
tyGSOctalDevCreate("/tyGS/0/0",0,0,1000,1000)
drvAsynSerialPortConfigure("L0","/tyGS/0/0",0,0,0)
asynSetOption("L0",0,"baud","9600")</pre>

<h3><a name="drvAsynIPPort"></a>TCP/IP or UDP/IP Port</h3>

<p>The drvAsynIPPort driver supports devices which communicate over a TCP/IP
or UDP/IP connection.  A typical example is a device connected through an
Ethernet/Serial converter box.</p>

<p>TCP/IP or UDP/IP connections are configured with the
<tt>drvAsynIPPortConfigure</tt> command:</p>
<pre>   drvAsynIPPortConfigure("portName","hostInfo",priority,noAutoConnect,noEos)</pre>
where the arguments are:
<ul>
  <li>portName - The portName that is registered with asynGpib.</li>
  <li>hostInfo - The Internet host name,  port number and optional IP
    protocol of the device (e.g.  "164.54.9.90:4002", "serials8n3:4002",
    "serials8n3:4002 TCP" or "164.54.17.43:5186 udp").  If no protocol is
    specified, TCP will be used.</li>
  <li>priority - Priority at which the asyn I/O thread will run. If this is
    zero or missing, then epicsThreadPriorityMedium is used.</li>
  <li>noAutoConnect - Zero or missing indicates that portThread should
    automatically connect.  Non-zero if explicit connect command must be
    issued.</li>
  <li>noEos - Zero or missing indicates that the generic EOS handler will be
    interposed.  Non-zero will not interpose the EOS handler.</li>
</ul>

<p>The setEos and getEos methods have no effect and return asynError.  The
read method blocks until at least one character has been received or until a
timeout occurs.  The read method transfers as many characters as possible,
limited by the specified count.</p>

<p>There are no asynSetOption key/value pairs associated with drvAsynIPPort
connections.</p>

<p>asynInterposeEos and asynInterposeFlush can be used to provide additional
functionality.</p>

<h3><a name="vxi11"></a>VXI-11</h3>
VXI-11 is a TCP/IP protocol for communicating with IEEE 488.2 devices. It is
an RPC based protocol. In addition to the VXI-11 standard, three additional
standards are defined.
<ul>
  <li>VXI-11.1 - A standard for communicating with VXIbus devices. These
    devices have a vxiName that starts with "vxi".</li>
  <li>VXI-11.2 - A standard for communicating with a IEEE 488.1 device. This
    means that the TCP/IP connection is talking to a GPIB controller that is
    talking to a GPIB bus. These devices have an vxiName that starts with
    "gpib".</li>
  <li>VXI-11.3 - A standard for communicating with IEEE 488.2 devices. This
    means that the TCP/IP connection is talking directly with an device.
    These devices have an vxiName that starts with "inst".</li>
</ul>

<p>Consult the following documents (available on-line) for details.</p>
<pre>VMEbus Extensions for Instrumentation
    VXI-11   TCP/IP Instrument Protocol Specification
    VXI-11.1 TCP/IP-VXIbus Interface Specification
    VXI-11.2 TCP/IP-IEEE 488.1 Interface Specification
    VXI-11.3 TCP/IP-IEEE 488.2 Instrument Interface Specification</pre>

<p>The following commands may be specified in the st.cmd file</p>
<pre>    E2050Reboot("inet_addr")
    E5810Reboot("inet_addr","password")
    vxi11Configure("portName","inet_addr",recoverWithIFC,timeout,
        "vxiName",priority,noAutoConnect)</pre>
where
<ul>
  <li>inet_addr - Internet Address</li>
  <li>password - password. If given as 0 the default E5810 is used.</li>
  <li>portName - The portName that is registered with asynGib.</li>
  <li>inet_addr - Internet address.</li>
  <li>recoverWithIFC - (0,1) =&gt; (don't, do) issue IFC when error
  occurs.</li>
  <li>timeout - I/O operation timeout in seconds as datatype double. If 0.0,
    then a default is assigned.</li>
  <li>vxiName - Must be chosen as specified above.</li>
  <li>priority - Priority at which the asyn I/O thread will run. If this is
    zero or missing, then epicsThreadPriorityMedium is used.</li>
  <li>noAutoConnect - Zero or missing indicates that portThread should
    automatically connect.  Non-zero if explicit connect command must be
    issued.</li>
</ul>

<p>The vxi11 driver implements two timeouts: ioTimeout and rpcTimeout (Remote
Procedure Call timeout). The ioTimeout is taken from asynUser:timeout. The
rpcTimeout is handled internally for each port. It has a default of 4 seconds
but can be changed by calling setOptions. For example:</p>
<pre>asynSetOption L0 -1 rpctimeout .1</pre>
Will change the rpcTimeout for port L0 to .1 seconds.

<p></p>

<h3><a name="gsIP488"></a>Green Springs IP488</h3>

<p>This is support for the Green Springs Industry Pack GPIB carrier. The
configuration command is:</p>
<pre>    gsIP488Configure(portName,carrier,module,intVec,priority,noAutoConnect)</pre>
where
<ul>
  <li>portName - An ascii string specifying the port name that will be
    registered with asynDriver.</li>
  <li>carrier - An integer identifying the Industry Pack Carrier</li>
  <li>module - An integer identifying the module on the carrier</li>
  <li>intVec - An integer specifying the interrupt vector</li>
  <li>priority - An integer specifying the priority of the port thread. A
    value of 0 will result in a defalt value being assigned</li>
  <li>noAutoConnect - Zero or missing indicates that portThread should
    automatically connect.  Non-zero if explicit connect command must be
    issued.</li>
</ul>

<p>An example is:</p>
<pre>#The following is for the Greensprings IP488 on an MV162 
ipacAddMVME162("A:l=3,3 m=0xe0000000,64")
gsIP488Configure("L0",0,0,0x61,0,0)</pre>

<h3><a name="ni1014"></a>National Instruments GPIB-1014D</h3>

<p>This is support for a National Instruments VME GPIB interface. The
configuration command is:</p>
<pre>    ni1014Config(portNameA,portNameB,base,vector,level,priority,noAutoConnect)</pre>
where
<ul>
  <li>portNameA - An ascii string specifying the port name that will be
    registered with asynDriver for portA.</li>
  <li>portNameB - An ascii string specifying the port name that will be
    registered with asynDriver for portB. If only one port should be
    registered, then leave this as a null string. The support should also
    work for a single port NI1014 but has not been tested.</li>
  <li>base - VME A16 base address.</li>
  <li>vector - VME interrupt vector.</li>
  <li>level - An integer specifying the interrupt level.</li>
  <li>priority - In integer specifying the priority of the port thread. A
    value of 0 will result in a defalt value being assigned</li>
  <li>noAutoConnect - Zero or missing indicates that portThread should
    automatically connect.  Non-zero if explicit connect command must be
    issued.</li>
</ul>

<p>An example is:</p>
<pre>ni1014Config("L0","L1",0x5000,0x64,5,0,0)</pre>

<p>NOTES:</p>
<ul>
  <li>Ports A and B are almost but not quite the same. Thus the code for
    connecting to port A is slightly different than the code for portB.</li>
  <li>In order to disconnect and reconnect either port, BOTH ports must be
    disconnected and reconnected.</li>
  <li>When the ports are connected, portA MUST be connected before port
  B.</li>
  <li>Programmed I/O, via interrupts, rather than DMA is implemented. Thus no
    A24 address space is required.</li>
</ul>
<hr>

<center>
<h2><a name="DiagnosticAids"></a>Diagnostic Aids</h2>
</center>

<h3>iocsh Commands</h3>
<pre>    asynReport(filename,level,portName)
    asynInterposeFlushConfig(portName,addr,timeout)
    asynInterposeEosConfig(portName,addr)
    asynSetTraceMask(portName,addr,mask)
    asynSetTraceIOMask(portName,addr,mask)
    asynSetTraceFile(portName,addr,filename)
    asynSetTraceIOTruncateSize(portName,addr,size)
    asynSetOption(portName,addr,key,val)
    asynShowOption(portName,addr,key)
    asynAutoConnect(portName,addr,yesNo)
    asynEnable(portName,addr,yesNo)
    asynOctetConnect(entry,portName,addr,oeos,ieos,timeout,buffer_len)
    asynOctetRead(entry,nread,flush)
    asynOctetWrite(entry,output)
    asynOctetWriteRead(entry,output,nread)
    asynOctetFlush(entry)</pre>

<p><code>asynReport</code> calls <code>asynCommon:report</code> for a specific port
if portName is specified, or for all
registered drivers and interposeInterface if portName is not specified.</p>

<p><code>asynInterposeFlushConfig</code> is a generic interposeInterface that
implements flush for low level drivers that don't implement flush. It just
issues read requests until no bytes are left to read. The timeout is used for
the read requests.</p>

<p><code>asynInterposeEosConfig</code> is a generic interposeInterface that
implements End of String processing for low level drivers that don't.</p>

<p><code>asynSetTraceMask</code> calls <code>asynTrace:setTraceMask</code>
for the specified port and address.</p>

<p><code>asynSetTraceIOMask</code> calls
<code>asynTrace:setTraceIOMask</code> for the specified port and address.</p>

<p><code>asynSetTraceFile</code> calls <code>asynTrace:setTraceFile</code>.
The filename is handled as follows:</p>
<ul>
  <li>Not specified - A NULL pointer is passed to setTraceFile. Subsequent
    messages are sent to errlog.</li>
  <li>An empty string ("") or "stdout" - stdout is passed to
  setTraceFile.</li>
  <li>Any other string - The specified file is opened with an option of "w"
    and the file pointer is passed to setTraceFile.</li>
</ul>

<p><code>asynSetTraceIOTruncateSize</code> calls
<code>asynTrace:setTraceIOTruncateSize</code></p>

<p><code>asynSetOption</code> calls <code>asynCommon:setOption</code>.
<code>asynShowOption</code> calls <code>asynCommon:getOption</code>.</p>

<p>asynOctetConnect, ...asynOctetFlush provide shell access to
asynOctetSyncIO methods. The entry is a character string constant that
identifys the port,addr.</p>

<p>where</p>
<ul>
  <li>filename - An ascii string naming a file. If null or a null string,
    then the output is sent to <code>stdout.</code></li>
  <li>level - The report level.</li>
  <li>portName - An ascii string specifying the portName of the driver.</li>
  <li>addr - In integer specifying the address of the device. For multiDevice
    ports a value of -1 means the port itself. For ports that support a
    single device, addr is ignored.</li>
  <li>mask - The mask value to set. See the mask bit definitions in
    asynDriver.h</li>
  <li>key - The key for the option desired.</li>
  <li>val - The value for the option.</li>
  <li>yesNo - The value (0,1) means (no,yes).</li>
  <li>entry - A character string that identifies the asynOctetConnect
  request.</li>
  <li>oeos,ieos - The output and input End of String terminator.&nbsp;
    Default="\r"</li>
  <li>timeout - timeout as an integer in milliseconds. The default is 1.</li>
  <li>buffer_len - length of buffer for I/O. Default=80.</li>
  <li>nread - max number of bytes to read. Default=buffer_len.</li>
  <li>flush - (0,1) means (don't, do) flush before reading. Default=0.</li>
  <li>output - output string.</li>
</ul>

<p>The commands asynOctetConnect, asynOctetRead, asynOctetWrite,
asynOctetWriteRead, asynOctetFlush allow I/O to a device from the ioc shell.
Examples are:</p>
<pre>asynOctetConnect("myid","A",0,"\n","\n",1,20)
asynOctetWrite("myid","testnew")
asynOctetRead("myid")
testnew\n
asynOctetWriteRead("myid","this is test")
this is test\n</pre>
<hr>

<center>
<h2><a name="InstallBuild"></a>Install and Build</h2>
</center>

<h3>Install and Build asynDriver</h3>
After obtaining a copy of the distribution, it must be installed and built
for use at your site. These steps only need to be performed once for the site
(unless versions of the module running under different releases of EPICS
and/or the other required modules are needed).
<ol>
  <li>Create an installation directory for the module, usually this will end
    with</li>
  <pre><tt>.../support/asyn/</tt></pre>
  <li>Place the distribution file in this directory. Then issue the commands
    (Unix style)</li>
  <pre>gunzip &lt;file&gt;.tar.gz
tar xvf &lt;file&gt;.tar</pre>
  <li>This creates a support &lt;top&gt;.</li>
  <pre>.../support/asyn/X-Y</pre>
  where X-Y is the release number. For example:
  <pre>.../support/asyn/3-1</pre>
  <li>Edit the <tt>config/RELEASE</tt> file and set the paths to your
    installation of EPICS_BASE and IPAC. IPAC is only needed if you are
    building for vxWorks.</li>
  <li>Run <tt>make</tt> in the top level directory and check for any
    compilation errors.</li>
</ol>

<h3>Using asynDriver Components with an EPICS iocCore Application</h3>

<p>Since asynDriver does NOT provide support for specific devices an
application must obtain device specific support elsewhere. This section only
explains how to include asynDriver components.</p>

<p>In the <code>configure/RELEASE</code> file add definitions for
<code>IPAC</code>, <code>ASYN</code>, and <code>EPICS_BASE</code>.</p>

<p>In the src directory where the application is built:</p>
<ul>
  <li>Add the following to <code>Makefile</code>
    <pre>        &lt;app&gt;_LIBS += asyn
    </pre>
  </li>
  <li>Add the following to <code>&lt;app&gt;Include.dbd</code> and uncomment
    the line or lines appropriate for your application:
    <pre>      include "asyn.dbd"
      #include "drvAsynSerialPort.dbd"
      #include "drvAsynIPPort.dbd"
      #include "drvVxi11.dbd"
      #include "drvGsIP488.dbd"
      #include "drvIpac.dbd"
      #registrar(mv162ipRegistrar)
    </pre>
  </li>
</ul>

<p>In the <code>st.cmd</code> file add:</p>

<p>dbLoadRecords("db/asynRecord.db", "P=&lt;ioc&gt;, R=&lt;record&gt;,
PORT=&lt;port&gt;, ADDR=&lt;addr&gt;, OMAX=&lt;omax&gt;,
IMAX=&lt;imax&gt;")</p>

<p>You must provide  values for &lt;ioc&gt;, &lt;record&gt;, &lt;port&gt;,
&lt;addr&gt;, &lt;omax&gt;, and &lt;imax&gt;.</p>

<p>Once the application is running, medm displays for an ioc can be started
by: medm -x -macro "P=&lt;ioc&gt;,R=&lt;record&gt;"
&lt;asyntop&gt;/medm/asynRecord.adl &amp;</p>

<p>You must provide correct values for &lt;ioc&gt; and &lt;record&gt;. Once
asynRecord is started, it can be connected to different devices.</p>
<hr>

<center>
<h2><a name="LicenseAgreement"></a>License Agreement</h2>
</center>
<pre>Copyright (c) 2002 University of Chicago All rights reserved.
asynDriver is distributed subject to the following license conditions:

SOFTWARE LICENSE AGREEMENT
Software: asynDriver

 1. The "Software", below, refers to asynDriver (in either source code, or
    binary form and accompanying documentation). Each licensee is
    addressed as "you" or "Licensee."

 2. The copyright holders shown above and their third-party licensors
    hereby grant Licensee a royalty-free nonexclusive license, subject to
    the limitations stated herein and U.S. Government license rights.

 3. You may modify and make a copy or copies of the Software for use
    within your organization, if you meet the following conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement.
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy.

 4. You may modify a copy or copies of the Software or any portion of it,
    thus forming a work based on the Software, and distribute copies of
    such work outside your organization, if you meet all of the following
    conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement;
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy;
      c. Modified copies and works based on the Software must carry
         prominent notices stating that you changed specified portions of
         the Software.

 5. Portions of the Software resulted from work developed under a U.S.
    Government contract and are subject to the following license: the
    Government is granted for itself and others acting on its behalf a
    paid-up, nonexclusive, irrevocable worldwide license in this computer
    software to reproduce, prepare derivative works, and perform publicly
    and display publicly.

 6. WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" WITHOUT WARRANTY
    OF ANY KIND. THE COPYRIGHT HOLDERS, THEIR THIRD PARTY LICENSORS, THE
    UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR
    EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE, TITLE OR NON-INFRINGEMENT, (2) DO NOT ASSUME
    ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
    OR USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE
    SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT
    THAT THE SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE
    OR THAT ANY ERRORS WILL BE CORRECTED.

 7. LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT HOLDERS, THEIR
    THIRD PARTY LICENSORS, THE UNITED STATES, THE UNITED STATES DEPARTMENT
    OF ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, INCIDENTAL,
    CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE,
    INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY
    REASON WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF
    CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR
    OTHERWISE, EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
    POSSIBILITY OF SUCH LOSS OR DAMAGES.</pre>
</body>
</html>
