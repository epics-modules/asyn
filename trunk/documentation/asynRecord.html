<HTML><HEAD><TITLE>asyn - asyn Record</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="Microsoft FrontPage 5.0" name=GENERATOR></HEAD>
<BODY>
<H1>asyn Record</H1>
<ADDRESS>Mark Rivers</ADDRESS>
<HR>


<H2>Contents</H2>
<UL>
  <LI><a href="#Overview">Overview</a> 
  <LI><a href="#Device Address Control Fields">Device Address Control Fields</a><LI>
  <a href="#Input/Output Control Fields">Input/Output Control Fields</a><LI>
  <a href="#Output Control Fields">Output Control Fields</a><LI>
  <a href="#Input Control Fields">Input Control Fields</a><LI>
  <a href="#Serial Control Fields">Serial Control Fields</a><LI>
  <a href="#GPIB Control Fields">GPIB Control Fields</a><LI>
  <a href="#Trace Control Fields">Trace Control Fields</a><LI>
  <a href="#Connection Management Fields">Connection Management Fields</a><LI>
  <a href="#Error Status Fields">Error Status Fields</a><LI>
  <a href="#Private Fields">Private Fields</a><LI>
  <a href="#Record Processing">Record Processing</a><LI><a href="#Restrictions">Restrictions</a><LI>
  <a href="#Obsolete serial and GPIB records">Obsolete serial and GPIB records</a><LI><a href="#medm screens">medm 
  screens</a><LI>
  <a href="#Example 1">Example 1</a><LI><a href="#Example 2">Example 2</a></UL><A name=Overview>
<H2>Overview</H2></A>
<P>The asyn record is designed to perform generic I/O to any asyn device that
supports the asynOctet interface. It is intended to allow EPICS to communicate with a new
device without rebooting the IOC, i.e. without writing any C code or 
changing the database. The asyn record is thus very useful for allowing 
Channel Access clients to communicate with devices for which no EPICS 
device support exists. In combination with the scalcout record to format output
strings and to parse response strings, it can actually eliminate the need for C
device support code in many applications. It is also useful for diagnostics. The
asyn device &quot;port&quot; and &quot;address&quot; can be dynamically changed
in the record, so a single asyn record can be switched from talking to one
device to another at run time. It provides access to asynTrace for the device, 
controlling debugging output.
<P>There are two output fields, AOUT (ASCII Output) and BOUT (Byte Output). The
OFMT (Output Format) field is used to select one of these fields or the other as
the output source to the  device. Similarly, there are two input fields, AINP (ASCII Input) and BINP (Byte Input). The IFMT 
(Input Format) field is used to select one or the other as the destination of 
data sent from the
device. The ASCII fields are type DBF_STRING, and are very convenient for
typical communication with many  devices. They permit, for example, <code>medm</code>
screens where the user can type a string and observe the response from the
instrument. The ASCII fields, however are limited to 40 characters in length,
and cannot be used to read or write binary data. The byte input and output
fields are DBF_CHAR arrays, and can be used to transfer large blocks of
arbitrary data, either ASCII or binary.<P>For local serial ports the baud 
rate, parity, etc. can be controlled by fields in the record.&nbsp; For GPIB
devices the GPIB address can be changed, and global and addressed commands can
be executed.&nbsp; asyn socket ports can be dynamically created at run time.<P>&nbsp;In 
the &quot;Access&quot; columns in the field description tables:
      <TABLE>
        <TR vAlign=top>
          <TD>R</TD>
          <TD>Read only
          <TD></TD>
        <TR vAlign=top>
          <TD>R/W</TD>
          <TD>Read and write are allowed</TD></TR>
        <TR vAlign=top>
          <TD>R/W*</TD>
          <TD>Read and write are allowed; write triggers record processing if 
            the record's SCAN field is set to "Passive".</TD></TR>
        <TR vAlign=top>
          <TD>N</TD>
          <TD>No access allowed</TD></TR></TABLE><P>&nbsp;
<HR>


<h2 align="center"><a name="Device Address Control Fields">Device Address Control Fields</a></h2>


<TABLE cellPadding=5 border=1>
  <TR>
    <TH>Name</TH>
    <TH>Access</TH>
    <TH>Prompt</TH>
    <TH>Data type</TH>
    <TH>Description</TH></TR>
  <TR vAlign=top>
    <TD>PORT</TD>
    <TD>R/W</TD>
    <TD>"asyn port&quot;</TD>
    <TD>DBF_STRING</TD>
    <TD>The asyn &quot;port&quot; name.&nbsp; This field can be changed at any time to 
    connect the record to another asyn device.</TD></TR>
  <TR vAlign=top>
    <TD>ADDR</TD>
    <TD>R/W</TD>
    <TD>&quot;asyn address&quot;</TD>
    <TD>DBF_LONG</TD>
    <TD>The asyn address.&nbsp; This field can be changed at any time to connect 
    the record to another asyn device.&nbsp; The asyn address parameter is 
    currently only used for GPIB devices, but in the future it may be used for 
    RS-485 and other applications.</TD></TR>
  <tr>
    <TD>SOCK</TD>
    <TD>R/W</TD>
    <TD>&quot;Socket address&quot;</TD>
    <TD>DBF_STRING</TD>
    <TD>The name of a server:port for a TCP/IP socket connection.&nbsp; This 
    field can be changed at any time to connect to a new TCP/IP socket.&nbsp; It 
    creates a new port with the same name as the socket string, and connects the 
    record to that port.&nbsp; Syntax is server:port, e.g. corvette:21 or 
    164.54.160.50:21</TD>
  </tr>
</TABLE>
<P>The asyn record does not have traditional INP or OUT fields for input 
and output links.&nbsp; Rather it provides the PORT and ADDR fields to allow 
dynamically changing what asyn device the record is connected to.
<P>Writing to the PORT or ADDR fields causes the asyn record to disconnect 
from the current device and connect to the specified asyn port and address.&nbsp; 
This permits a single asyn record to be used to control any asyn device.&nbsp; 
Writing to these fields does not cause the record to process, i.e. no I/O is 
done.<P>Writing to the SOCK field causes the record to create a new asyn port 
with the same name as the SOCK field.&nbsp; This is done with 
drvGenericSerialConfigure.<p>&nbsp;</p>
<HR>


<h2 align="center"><a name="Input/Output Control Fields">Input/Output Control Fields</a></h2>


<TABLE cellPadding=5 border=1>
  <TR>
    <TH>Name</TH>
    <TH>Access</TH>
    <TH>Prompt</TH>
    <TH>Data type</TH>
    <TH>Description</TH></TR>
  <TR vAlign=top>
    <TD>VAL</TD>
    <TD>R/W</TD>
    <TD>"Value field (unused)"</TD>
    <TD>DBF_STRING</TD>
    <TD>This field is unused. The functions normally assigned to the VAL field 
      in many records are performed by the AOUT, BOUT, AINP, and BINP fields in 
      the asyn record.</TD></TR>
  <TR vAlign=top>
    <TD>TMOD</TD>
    <TD>R/W</TD>
    <TD>"Transaction mode"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The type of I/O transaction to perform when the record is processed. The choices are: 
      <TABLE>
        <TBODY>
        <TR vAlign=top>
          <TD>"Write/Read" (default)</TD>
        </TR>
        <TR vAlign=top>
          <TD>"Write"</TD>
        </TR>
        <TR vAlign=top>
          <TD>"Read"</TD>
        </TR>
        <TR vAlign=top>
          <TD>&quot;Flush&quot;</TD>
        </TR></TBODY></TABLE></TD></TR>
  <tr>
    <TD>TMOT</TD>
    <TD>R/W</TD>
    <TD>"Timeout (sec)&quot;</TD>
    <TD>DBF_DOUBLE</TD>
    <TD>The timeout value for read and write operations in seconds. If a 
      response is not received from the device within this time then the record 
      sets a major alarm. -1.0 means wait forever, no timeour. Default=1.0</TD>
  </tr>
</TABLE>
&nbsp;
<p>The TMOD field controls what type of I/O is performed when the record
processes.</p>
      <TABLE>
        <TR vAlign=top>
          <TD>"Write/Read" (default)</TD>
          <TD>The output source (AOUT or BOUT as selected by OFMT) is sent to 
            the device. A response is then read back into AINP or BINP 
            (as selected by IFMT). The response must be received within the time 
            specified by TMOT. The input buffer is flushed before the write operation, so that any characters received prior to the write 
            operation are discarded.&nbsp; The Write/Read operation is &quot;atomic&quot;, 
          meaning that it is guaranteed that no other asyn I/O to the device 
          will occur between the write and read operations.</TD></TR>
        <TR vAlign=top>
          <TD>"Write"</TD>
          <TD>The output source (AOUT or BOUT as selected by OFMT) is sent to 
            the device. No response is read back.</TD></TR>
        <TR vAlign=top>
          <TD>"Read"</TD>
          <TD>Data is read from the device into the input field (AINP 
            or BINP as selected by IFMT). The response must be received within 
            the time specified by TMOT. No output is sent to the device prior to 
            the read operation.</TD></TR>
        <TR vAlign=top>
          <TD>&quot;Flush&quot;</TD>
          <TD>The input buffer is flushed.&nbsp; Nothing is sent to the device
            or read from the device.</TD></TR></TABLE>




<p>&nbsp;</p>
<HR>


<h2 align="center"><a name="Output Control Fields">Output Control Fields</a></h2>


<TABLE cellPadding=5 border=1>
  <TR>
    <TH>Name</TH>
    <TH>Access</TH>
    <TH>Prompt</TH>
    <TH>Data type</TH>
    <TH>Description</TH></TR>
  <TR vAlign=top>
    <TD>AOUT</TD>
    <TD>R/W*</TD>
    <TD>"Output string"</TD>
    <TD>DBF_STRING</TD>
    <TD>The output string which is sent to the device if OFMT="ASCII". The 
      number of bytes sent to the device will be <CODE>strlen(AOUT)</CODE>  plus <CODE>strlen(OEOS)</CODE>.</TD></TR>
  <TR vAlign=top>
    <TD>BOUT</TD>
    <TD>R/W*</TD>
    <TD>"Output byte data"</TD>
    <TD>DBF_CHAR (array)</TD>
    <TD>The output data which is sent to the device if OFMT=&quot;Binary&quot;
      or&nbsp; &quot;Hybrid&quot;. The 
      maximum length of this field is controlled by OMAX. The actual number of 
      bytes to be sent to the device when OFMT=&quot;Hybrid&quot; will be&nbsp; <CODE>strlen(AOUT)</CODE> 
      plus <CODE>strlen(OEOS). </CODE> The actual number of 
      bytes to be sent to the device when OFMP=&quot;Binary&quot; will be NOWT.</TD></TR>
  <TR vAlign=top>
    <TD>OEOS</TD>
    <TD>R/W</TD>
    <TD>"Output terminator&quot;</TD>
    <TD>DBF_STRING</TD>
    <TD>A character string that is appended to the output before 
      transmission to the device. This field is ignored if OFMT=&quot;Binary&quot;.
      Set this field to &quot;&quot; to suppress transmission 
      of a terminator. Commonly used values are &quot;\r&quot; (the default),
      &quot;\n&quot;, and &quot;\r\n&quot;.</TD></TR>
  <TR vAlign=top>
    <TD>OMAX</TD>
    <TD>R</TD>
    <TD>"Max. size of output array"</TD>
    <TD>DBF_LONG</TD>
    <TD>The allocated length of the BOUT array. This value cannot be changed 
      after IOC initialization. Default=512.</TD></TR>
  <tr>
    <TD>NOWT</TD>
    <TD>R/W</TD>
    <TD>"Number of bytes to write"</TD>
    <TD>DBF_LONG</TD>
    <TD>The number of bytes to send from the BOUT array to the  device if OFMT=&quot;Binary&quot;. This value must be less than or equal to
      OMAX. 
  Default=512.</TD>
  </tr>
  <TR vAlign=top>
    <TD>NAWT</TD>
    <TD>R/W</TD>
    <TD>"Number of bytes actually written&quot;</TD>
    <TD>DBF_LONG</TD>
    <TD>The actual number of bytes written in the last write operation. This field 
      is valid for all OFMT modes. This number includes 
      the output terminator, if any.</TD></TR>
  <TR vAlign=top>
    <TD>OFMT</TD>
    <TD>R/W</TD>
    <TD>"Output format"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The output format. The choices are: 
      <TABLE>
        <TBODY>
        <TR vAlign=top>
          <TD>"ASCII (default)"</TD>
          <TD>The data sent to the device will be taken from the AOUT 
        field.</TD></TR>
        <TR vAlign=top>
          <TD>&quot;Hybrid&quot;</TD>
          <TD>The data sent to the device will be taken from the BOUT 
        field.</TD></TR>
        <TR vAlign=top>
          <TD>"Binary"</TD>
          <TD>The data sent to the device will be taken from the BOUT 
        field.</TD></TR></TBODY></TABLE></TD></TR>
</TABLE>
<P>There are two output fields, AOUT (ASCII Output) and BOUT (Byte Output). 
The OFMT (Output Format) field is used to select one of these fields or the 
other as the output source to the device.&nbsp; 
<P>If OFMT=&quot;ASCII&quot; then the AOUT fields and OEOS fields are processed
with dbTranslateEscape() to convert control characters (e.g. &quot;\r&quot;,
&quot;\021&quot;) to bytes, these fields are combined into a single buffer, the
length of the output is determined with strlen(), and the string is sent to the
device. 
<P>If OFMT=&quot;Hybrid&quot; then the BOUT fields and OEOS fields are processed
with dbTranslateEscape() to convert control characters (e.g. &quot;\r&quot;,
&quot;\021&quot;) to bytes, these fields are combined into a single buffer, the
length of the output is determined with strlen(), and the string is sent to the
device.<P>If OFMT=&quot;Binary&quot; then the NOWT bytes from the BOUT field are
sent to the device.&nbsp; The OEOS field is ignored, and dbTranslateEscape() is
not called.




<p>&nbsp;</p>
<HR>


<h2 align="center"><a name="Input Control Fields">Input Control Fields</a></h2>


<TABLE cellPadding=5 border=1>
  <TR>
    <TH>Name</TH>
    <TH>Access</TH>
    <TH>Prompt</TH>
    <TH>Data type</TH>
    <TH>Description</TH></TR>
  <TR vAlign=top>
    <TD>AINP</TD>
    <TD>R</TD>
    <TD>"Input string"</TD>
    <TD>DBF_STRING</TD>
    <TD>The input string which is read from the device if IFMT="ASCII". The 
      string will be null terminated. Note that due to the maximum size of a 
      string in EPICS, the input string must be less than 40 characters. If 
      longer strings are required then set IFMT=&quot;Hybrid&quot; and read into the BINP 
      field.</TD></TR>
  <TR vAlign=top>
    <TD>BINP</TD>
    <TD>R</TD>
    <TD>"Input byte data"</TD>
    <TD>DBF_CHAR (array)</TD>
    <TD>The input data which is read from the device if IFMT=&quot;Hybrid&quot;
      or IFMT=&quot;Binary&quot;. The 
      maximum length of this field is controlled by IMAX. The actual number of 
      bytes read from the device is given by NORD.</TD></TR>
  <TR vAlign=top>
    <TD>IEOS</TD>
    <TD>R/W</TD>
    <TD>"Input terminator&quot;</TD>
    <TD>DBF_STRING</TD>
    <TD>A string that indicates the end of a message on input. Set this 
      field to &quot;&quot;&quot; if no input terminator should be used. This field is ignored if
      IFMT=&quot;Binary&quot;. Commonly used values are &quot;\r&quot; (the default),
      &quot;\n&quot;, and &quot;\r\n&quot;. The 
      input terminator is removed from the input buffer after the read.</TD></TR>
  <TR vAlign=top>
    <TD>IMAX</TD>
    <TD>R</TD>
    <TD>"Max. size of input array"</TD>
    <TD>DBF_LONG</TD>
    <TD>The allocated length of the BINP array. This value cannot be changed 
      after IOC initialization. Default=512.</TD></TR>
  <TR vAlign=top>
    <TD>NRRD</TD>
    <TD>R/W</TD>
    <TD>"Number of bytes to read"</TD>
    <TD>DBF_LONG</TD>
    <TD>The requested number of bytes to read. This field is valid for all IFMT
      modes. If this field is &lt;= 0, then the 
      requested number of bytes to read will be the EPICS defined 
      MAX_STRING_SIZE=40 (if IFMT="ASCII") or IMAX (if IFMT=&quot;Hybrid&quot;
      or &quot;Binary&quot;). 
    Default=0.</TD></TR>
  <TR vAlign=top>
    <TD>NORD</TD>
    <TD>R</TD>
    <TD>"Number of bytes read"</TD>
    <TD>DBF_LONG</TD>
    <TD>The actual number of bytes read in the last read operation. This field 
      is valid for all IFMT modes. This number includes 
      the input terminator, if any.</TD></TR>
  <TR vAlign=top>
    <TD>IFMT</TD>
    <TD>R/W</TD>
    <TD>"Input format"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The input format. The choices are: 
      <TABLE>
        <TBODY>
        <TR vAlign=top>
          <TD>"ASCII" (default)</TD>
          <TD>The data read from the device will be placed in the AINP 
          field.</TD></TR>
        <TR vAlign=top>
          <TD>&quot;Hybrid&quot;</TD>
          <TD>The data read from the device will be placed in the BINP field.</TD></TR>
        <TR vAlign=top>
          <TD>"Binary"</TD>
          <TD>The data read from the device will be placed in the BINP 
          field.</TD></TR></TBODY></TABLE></TD></TR>
</TABLE>
<P>There are two input 
fields, AINP (ASCII Input) and BINP (Byte Input). The IFMT (Input Format) 
field is used to select one or the other as the destination of data sent from 
the  device. 
<P>A read operation terminates when 1 of the following 4 conditions is 
met: 
<OL>
  <LI>The input terminator (IEOS) is found (if IFMT=&quot;ASCII&quot; or
    &quot;Hybrid&quot;)
  <LI>EOI asserted (GPIB only) 
  <LI>The desired number of input characters (NRRD) are received 
  <LI>The timeout (TMOT) expires </LI></OL>
<P>If IFMT=&quot;ASCII&quot; then the IEOS field is processed
with dbTranslateEscape() to convert control characters (e.g. &quot;\r&quot;,
&quot;\021&quot;) to bytes, and the asyn input terminator is set to this
string.&nbsp; The input is read into the AINP field. The input terminator
string, if present, is removed from AINP after the read, and AINP will be null
terminated. 
<P>If IFMT=&quot;Hybrid&quot; then the IEOS field is processed
with dbTranslateEscape() to convert control characters (e.g. &quot;\r&quot;,
&quot;\021&quot;) to bytes, and the asyn input terminator is set to this
string.&nbsp; The input is read into the BINP field. The input terminator
string, if present, is removed from BINP after the read, and BINP will be null
terminated. 
<P>If IFMT=&quot;Binary&quot; then the IEOS field is ignored, and no asyn input
terminator is used.&nbsp; The input is read into the BINP field. BINP will be
null terminated.
<P>The IEOS terminator field is 40 characters long.&nbsp; However, the serial 
drivers permit 2 character end-of-message strings at most. The GPIB drivers only 
permit 1 character end-of-message strings.<br>
&nbsp;<HR>


<h2 align="center"><a name="Serial Control Fields">Serial Control Fields</a></h2>


<TABLE cellPadding=5 border=1>
  <TR vAlign=top>
    <TD>BAUD</TD>
    <TD>R/W</TD>
    <TD>"Baud rate"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The baud rate for the port. Choices are "300", "600", "1200", "2400", 
      "4800", "9600", "19200", and "38400", &quot;57600&quot;, &quot;115200&quot;, and &quot;230400&quot;. Default="9600".</TD></TR>
  <TR vAlign=top>
    <TD>PRTY</TD>
    <TD>R/W</TD>
    <TD>"Parity"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The device parity. Choices are "None", "Even", and "Odd". 
      Default="None".</TD></TR>
  <TR vAlign=top>
    <TD>DBIT</TD>
    <TD>R/W</TD>
    <TD>"Data bits"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The number of data bits. Choices are "5", "6", "7", and "8". 
      Default="8".</TD></TR>
  <TR vAlign=top>
    <TD>SBIT</TD>
    <TD>R/W</TD>
    <TD>"Stop bits"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The number of stop bits. Choices are "1" and "2". Default="1".</TD></TR>
  <TR vAlign=top>
    <TD>FCTL</TD>
    <TD>R/W</TD>
    <TD>"Flow control"</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The flow control. Choices are "None" and "Hardware". 
  Default="None".</TD></TR>
</TABLE>
<P>
 The above fields are used to set the serial port 
      parameters. A write to any of these fields causes the port parameters to 
      be changed immediately, but does not cause the record to process.&nbsp;
The port parameters can currently be set only for local serial ports, including
IP-Octal on vxWorks.&nbsp; They cannot currently be set for Ethernet/serial
adapters like the Moxa units.<P>
 The baud rates actually available are device dependent.&nbsp; For the SBS 
 IP-Octal module the maximum baud rate is 38400. 
<p>&nbsp;</p>
<HR>


<h2 align="center"><a name="GPIB Control Fields">GPIB Control Fields</a></h2>


<table cellPadding="5" border="1">
  <tr>
    <TH>Name</TH>
    <TH>Access</TH>
    <TH>Prompt</TH>
    <TH>Data type</TH>
    <TH>Description</TH>
  </tr>
  <tr>
    <td>ADDR</td>
    <td>R/W</td>
    <td>&quot;GPIB address&quot;</td>
    <td>DBF_LONG</td>
    <td>The GPIB address of the device. This field can be changed at any time.
    </td>
  </tr>
  <tr vAlign="top">
    <td>SPR</td>
    <td>R</td>
    <td>&quot;Serial Poll Response&quot;</td>
    <td>DBF_UCHAR</td>
    <td>The device status byte, which is read during a Serial Poll operation.</td>
  </tr>
  <tr vAlign="top">
    <td>UCMD</td>
    <td>R/W*</td>
    <td>&quot;Universal command&quot;</td>
    <td>DBF_RECCHOICE</td>
    <td>A GPIB Universal Command to be executed. GPIB Universal Commands are 
    commands which are directed to all devices on the GPIB bus, not just 
    addressed devices. The choices are:
    <table>
      <tr vAlign="top">
        <td>&quot;None&quot;</td>
      </tr>
      <tr vAlign="top">
        <td>&quot;Device Clear (DCL)&quot;</td>
      </tr>
      <tr vAlign="top">
        <td>&quot;Local Lockout (LL0)&quot;</td>
      </tr>
      <tr vAlign="top">
        <td>&quot;Serial Poll Disable (SPD)&quot;</td>
      </tr>
      <tr vAlign="top">
        <td>&quot;Serial Poll Enable (SPE)&quot;</td>
      </tr>
      <tr vAlign="top">
        <td>&quot;Unlisten (UNL)&quot;</td>
      </tr>
      <tr vAlign="top">
        <td>&quot;Untalk (UNT)&quot;</td>
      </tr>
    </table>
    <p>If the UCMD field is set to any value except &quot;None&quot; then the appropriate 
    Universal Command is executed, and UCMD is set back to &quot;None&quot;. The record 
    processing only performs the Universal Command, i.e. it does not also 
    perform the GPIB operation indicated by TMOD.</td>
  </tr>
  <tr vAlign="top">
    <td>ACMD</td>
    <td>R/W*</td>
    <td>&quot;Addressed command&quot;</td>
    <td>DBF_RECCHOICE</td>
    <td>A GPIB Addressed Command to be executed. GPIB Addressed Commands are 
    commands which are directed to only the addressed devices on the GPIB bus. 
    The choices are:
    <table>
      <tr vAlign="top">
        <td>&quot;None&quot;</td>
      </tr>
      <tr vAlign="top">
        <td>&quot;Group Execute Trig. (GET)&quot;</td>
      </tr>
      <tr vAlign="top">
        <td>&quot;Go To Local (GTL)&quot;</td>
      </tr>
      <tr vAlign="top">
        <td>&quot;Selected Dev. Clear (SDC)&quot;</td>
      </tr>
      <tr vAlign="top">
        <td>&quot;Take Control (TCT)&quot;</td>
      </tr>
      <tr vAlign="top">
        <td>&quot;Serial Poll&quot;</td>
      </tr>
    </table>
    <p>If the ACMD field is set to any value except &quot;None&quot; then the appropriate 
    Addressed Command is executed, and ACMD is set back to &quot;None&quot;. The record 
    processing only performs the Addressed Command, i.e. it does not also 
    perform the GPIB operation indicated by TMOD.</td>
  </tr>
</table>
<p>&nbsp;</p>
<HR>


<h2 align="center"><a name="Trace Control Fields">Trace Control Fields</a></h2>


<TABLE cellPadding=5 border=1>
  <tr>
    <TH>Name</TH>
    <TH>Access</TH>
    <TH>Prompt</TH>
    <TH>Data type</TH>
    <TH>Description</TH>
  </tr>
  <TR vAlign=top>
    <TD>TB0</TD>
    <TD>R/W</TD>
    <TD>"Trace error&quot;</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The ASYN_TRACE_ERROR bit.&nbsp; Choices are &quot;Off&quot; and &quot;On&quot;.</TD></TR>
  <tr>
    <TD>TB1</TD>
    <TD>R/W</TD>
    <TD>"Trace IO device&quot;</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The ASYN_TRACEIO_DEVICE bit.&nbsp; Choices are &quot;Off&quot; and &quot;On&quot;.</TD>
  </tr>
  <tr>
    <TD>TB2</TD>
    <TD>R/W</TD>
    <TD>"Trace IO filter&quot;</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The ASYN_TRACEIO_FILTER bit.&nbsp; Choices are &quot;Off&quot; and &quot;On&quot;.</TD>
  </tr>
  <tr>
    <TD>TB3</TD>
    <TD>R/W</TD>
    <TD>"Trace IO driver&quot;</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The ASYN_TRACEIO_DRIVER bit.&nbsp; Choices are &quot;Off&quot; and &quot;On&quot;.</TD>
  </tr>
  <tr>
    <TD>TB4</TD>
    <TD>R/W</TD>
    <TD>"Trace flow&quot;</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The ASYN_TRACEIO_FLOW bit.&nbsp; Choices are &quot;Off&quot; and &quot;On&quot;.</TD>
  </tr>
  <tr>
    <TD>TIB0</TD>
    <TD>R/W</TD>
    <TD>"Trace IO ASCII&quot;</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The ASYN_TRACEIO_ASCII bit.&nbsp; Choices are &quot;Off&quot; and &quot;On&quot;.</TD>
  </tr>
  <tr>
    <TD>TIB1</TD>
    <TD>R/W</TD>
    <TD>"Trace IO escape&quot;</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The ASYN_TRACEIO_ESCAPE bit.&nbsp; Choices are &quot;Off&quot; and &quot;On&quot;.</TD>
  </tr>
  <tr>
    <TD>TIB2</TD>
    <TD>R/W</TD>
    <TD>"Trace IO hex&quot;</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>The ASYN_TRACEIO_HEX bit.&nbsp; Choices are &quot;Off&quot; and &quot;On&quot;.</TD>
  </tr>
  <tr>
    <TD>TSIZ</TD>
    <TD>R/W</TD>
    <TD>"TraceIO truncate size&quot;</TD>
    <TD>DBF_LONG</TD>
    <TD>The parameter passed to asynTraceSetTraceIOTruncateSize(). This value is
      used to limit the number of I/O bytes printed by traceIO.&nbsp;</TD>
  </tr>
  <tr>
    <TD>TFIL</TD>
    <TD>R/W</TD>
    <TD>"Trace IO file&quot;</TD>
    <TD>DBF_STRING</TD>
    <TD>The name of the file to which trace information is printed.</TD>
  </tr>
</TABLE>
<P>
 The above fields are used to control the asynTrace facility.&nbsp; They allow 
 one to turn on and off debugging output printed at the shell or written to the 
 trace file.<P>
 When the asyn record is connected to a new device with the PORT and ADDR 
 fields the above trace fields are automatically updated to reflect the current 
 asynTrace and asynTraceIO masks for that device.<P>
 The TFIL field is used to set the name of the trace file.&nbsp; It is not
 possible for the asyn record to determine the current file name if the record
 did not set it.&nbsp; In this case the file name is displayed as
 &quot;Unknown&quot;.&nbsp; Set this field to a string to a file name (including
 possibly a valid path from the IOC's current default directory) to have the
 output written to that file.&nbsp; Set the string to &quot;&quot; (null string)
 to set the output to stdout.
<p>&nbsp;</p>
<HR>


<h2 align="center"><a name="Connection Management Fields">Connection Management Fields</a></h2>


<TABLE cellPadding=5 border=1>
  <tr>
    <TH>Name</TH>
    <TH>Access</TH>
    <TH>Prompt</TH>
    <TH>Data type</TH>
    <TH>Description</TH>
  </tr>
  <TR vAlign=top>
    <TD>AUCT</TD>
    <TD>R/W</TD>
    <TD>&quot;Autoconnect&quot;</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>Sets the autoconnect option.&nbsp; Choices are &quot;noAutoConnect&quot; and &quot;autoConnect&quot;. 
    The value read reflects current state of the enabled flag, i.e. the value 
    returned from isAutoConnect().</TD></TR>
  <tr>
    <TD>ENBL</TD>
    <TD>R/W</TD>
    <TD>&quot;Disable/Enable&quot;</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>Disables or enables the port.&nbsp; Choices are &quot;Disable&quot; and
      &quot;Enable&quot;. The value read reflects current state of the enabled flag, 
    i.e. the value returned from isEnabled().</TD>
  </tr>
  <tr>
    <TD>CNCT</TD>
    <TD>R/W</TD>
    <TD>&quot;Connect/Disconnect&quot;</TD>
    <TD>DBF_RECCHOICE</TD>
    <TD>Disconnects or connects the device.&nbsp; Choices are &quot;Disconnect&quot; and 
    &quot;Connect&quot;.&nbsp; The value read reflects current state of the connected 
    flag, i.e. the value returned from isConnected().</TD>
  </tr>
</TABLE>
<p>&nbsp;</p>
<HR>


<h2 align="center"><a name="Error Status Fields">Error Status Fields</a></h2>


<TABLE cellPadding=5 border=1>
  <tr>
    <TH>Name</TH>
    <TH>Access</TH>
    <TH>Prompt</TH>
    <TH>Data type</TH>
    <TH>Description</TH>
  </tr>
  <TR vAlign=top>
    <TD>ERRS</TD>
    <TD>R</TD>
    <TD>&quot;Error status&quot;</TD>
    <TD>DBF_STRING</TD>
    <TD>Error status string for the most recent operation. This string is set to
      &quot;&quot; (null string) at the start of each connection and I/O
      operation.</TD></TR>
</TABLE>
<P>
 In addition to ERRS, the standard EPICS record fields STAT (status) and SEVR
 (severity) are used to report error status.&nbsp; For example status field may
 be set to NO_ALARM, WRITE, READ, or COMM, and the SEVR field may be set to NO_ALARM,
 MINOR, or MAJOR.<P>
 &nbsp;
<HR>


<h2 align="center"><a name="Private Fields">Private Fields</a></h2>


<P>
 &nbsp;<TABLE cellPadding=5 border=1>
  <tr>
    <TH>Name</TH>
    <TH>Access</TH>
    <TH>Prompt</TH>
    <TH>Data type</TH>
    <TH>Description</TH>
  </tr>
  <TR vAlign=top>
    <TD>IPTR</TD>
    <TD>N</TD>
    <TD>"Input buffer pointer"</TD>
    <TD>DBF_NOACCESS</TD>
    <TD>The pointer to the buffer for the BINP field.</TD></TR>
  <TR vAlign=top>
    <TD>OPTR</TD>
    <TD>N</TD>
    <TD>"Output buffer pointer"</TD>
    <TD>DBF_NOACCESS</TD>
    <TD>The pointer to the buffer for the BOUT field.</TD></TR>
  </TABLE>
<P>
&nbsp;
<HR>


<h2 align="center"><a name="Record Processing">Record Processing</a></h2>


<P>
 The asyn record processes, i.e. performs the I/O operation given by TMOD, 
 according to the normal rules for EPICS records.&nbsp; The AOUT and BOUT fields 
 are Process Passive, so the record will process if these fields are written to 
 and the SCAN field of the record is Passive.&nbsp; The scan field of the record 
 can be set to any of the periodic scan rates (e.g. &quot;1 second&quot;) for periodic 
 processing, or to &quot;Event&quot; for event processing.&nbsp; &quot;I/O Intr&quot; scanning is 
 currently not supported (but see <a href="#Restrictions">Restrictions</a> 
 below).<P>
&nbsp;<HR>


<h2 align="center"><a name="Obsolete serial and GPIB records">Obsolete serial 
and GPIB records</a></h2>


<P>
 The asyn record is designed to be a complete replacement for the older 
 generic serial (&quot;serial&quot;) and generic GPIB (&quot;gpib&quot;) records.&nbsp; These 
 records are no longer needed, and will not be supported in the future.&nbsp; 
 The following is a list of the differences between the old serial and GPIB records 
 and the new asyn record which may require changes to databases or 
 applications.<ul>
  <li>The ODEL field has been replaced by OEOS.&nbsp; It has changed from a 
  DBF_LONG to DBF_STRING in order to support multi-character terminators.</li>
  <li>The IDEL (serial) and EOS (gpib) fields have been replaced by IEOS.&nbsp; 
  They have changed from a DBF_LONG to DBF_STRING in order to support 
  multi-character terminators.</li>
  <li>The INP field has been replaced by the PORT and ADDR fields in order to 
  support run-time connection to different devices.</li>
  <li>The AOUT and OEOS fields are processed by dbTranslateEscape before being 
  sent to the device.&nbsp; In rare cases this may require changing the output 
  strings if these contained the &quot;\&quot; character.</li>
  <li>The asyn record always posts monitors on the input field (AINP or 
  BINP) when the record processes.&nbsp; The older records did not post monitors 
  on the AINP field if the value was the same as the previous read.&nbsp; This 
  caused problems for some SNL programs and data acquisition applications.</li>
  <li>The ODEL and IDEL fields were used even when OFMT or IFMT were in &quot;Binary&quot; 
  mode.&nbsp; OEOS and IEOS are now ignored when OFMT or IFMT respectively are in 
  &quot;Binary&quot; mode.</li>
  <li>The TMOT field has changed from DBF_LONG to DBF_DOUBLE, and the units have 
  changed from milliseconds to seconds.&nbsp; TMOT=-1.0 now means wait forever. 
  </li>
  </ul>
<p>&nbsp;</p>
<HR>


<H2><a name="medm screens">medm screens</a></H2><p>The following are 
  screen shots of the medm screens provided for the asyn record.</p><p>&nbsp;</p>
  <h3 align="center">Main control screen, asynRecord.adl</h3>
  <p align="center">
  <img border="0" src="asynRecord.gif" width="449" height="427"></p>
  <p align="center">
  &nbsp;</p>
  <h3 align="center">Debug screen, asynRecordDebug.adl</h3>
  <p align="center">
  <img border="0" src="asynRecordDebug.gif" width="450" height="637"></p>
  <p align="center">&nbsp;</p>
  <h3 align="center">Serial port setup screen, asynSerialPortSetup.adl</h3>
  <p align="center"><img border="0" src="asynSerialPortSetup.gif" width="258" height="210"></p>
  <p align="center">&nbsp;</p>
  <h3 align="center">GPIB setup screen, asynGPIBSetup.adl</h3>
  <p align="center"><img border="0" src="asynGPIBSetup.gif" width="383" height="195"></p>
  <p align="center">&nbsp;</p>
  <h3 align="center">Socket setup screen, asynSocketSetup.adl</h3>
  <p align="center"><img border="0" src="asynSocketSetup.gif" width="358" height="150"></p>
  <p align="center">&nbsp;</p>
  <h3 align="center">Trace control screen, asynTrace.adl</h3>
  <p align="center">
  <img border="0" src="asynTrace.gif" width="358" height="277"></p>
  <p align="center">&nbsp;</p>
  <h3 align="center">Connection management screen, asynConnect.adl</h3>
  <p align="center">
  <img border="0" src="asynConnect.gif" width="278" height="197"></p>
  <P>
<HR>
<A name=Restrictions>
<H2>Restrictions</H2></A>
<p>I/O Event Scanning (SCAN="I/O Intr&quot;) should be supported when 
the transfer mode (TMOD) is &quot;Read&quot;. In this case the record should process 
whenever a complete message is received. A complete message is defined by the 
input delimiter (IEOS) and/or the requested number of input characters (NRRD), 
being received. The timeout field (TMOT) will not apply when SCAN="I/O Intr&quot;. 
This will be added in the future.</p>
<p>Trace file and trace truncate size should be supported.&nbsp; These will be 
added in the future.</p>
<p>Enable, autoconnect, and connect should be supported.&nbsp; These will be 
added in the future.</p>
<HR>
<H2><a name="Example 1">Example #1</a></H2>The following is an IDL program that demonstrates the use 
of the asyn record. It transfers data in both ASCII and binary formats. 
Hopefully the IDL syntax is clear enough to be understood by non-IDL users, and can 
be translated into your favorite scripting language.<PRE>; This IDL program demonstrates the use of the EPICS asyn record.
; The program uses 2 asyn records.  The ports corresponding to these
; 2 records are connected with a null-modem cable
; Record 1 sends a message to record 2 in ASCII.
; Record 2 sends a message back to record 1 in binary.


; Record names
rec1 = '13LAB:serial2'
rec2 = '13LAB:serial3'
recs = [rec1, rec2] ; Array with both record names
; Set up port parameters for both records:
;   19,200 baud, 8 data bits, 1 stop bit, no parity, no flow control
;   Timeout=1 second
for i=0, 1 do begin
    rec = recs[i]
    t = caput(rec+'.BAUD', '19200')
    t = caput(rec+'.DBIT', '8')
    t = caput(rec+'.SBIT', '1')
    t = caput(rec+'.PRTY', 'None')
    t = caput(rec+'.FCTL', 'None')
    t = caput(rec+'.TMOT', 1.0)
endfor


; Put record 1 in ASCII output mode, &lt;CR&gt; output delimiter,
;   binary input mode, no input delimiter
t = caput(rec1+'.OFMT', 'ASCII')
t = caput(rec1+'.OEOS', '\r')
t = caput(rec1+'.IFMT', 'Binary')
t = caput(rec1+'.IEOS', '')
; Put a monitor on record 1 Binary input field
t = casetmonitor(rec1+'.BINP')
; Clear the monitor by reading the value
t = caget(rec1+'.BINP', junk)


; Put record 2 in Binary output mode, no output delimiter
;   ASCII input mode, &lt;CR&gt; input delimiter
t = caput(rec2+'.OFMT', 'Binary')
t = caput(rec2+'.OEOS', '')
t = caput(rec2+'.IFMT', 'ASCII')
t = caput(rec2+'.IEOS', '\r')


; Put record 2 in read transfer mode
t = caput(rec2+'.TMOD', 'Read')
; Put a monitor on record2 ASCII input field
t = casetmonitor(rec2+'.AINP')
; Clear the monitor by reading the value
t = caget(rec2+'.AINP', junk)


; Process record 2; this will cause it to wait for data
t = caput(rec2+'.PROC', 1)
; Put record 1 in Write transfer mode
t = caput(rec1+'.TMOD', 'Write')
; Send a message to port 2
message = 'Request data: '+string(systime())
print, 'Record 1 sent message: ' + message
t = caput(rec1+'.AOUT', message)


; Wait for monitor on record2 ASCII input field
while (not cacheckmonitor(rec2+'.AINP')) do wait, .1
; Read data from record 2
t = caget(rec2+'.AINP', input)
print, 'Got a message from record 1: ', input


size=256
; Put record 1 in read mode, expect &quot;size&quot; byte input
t = caput(rec1+'.TMOD', 'Read')
t = caput(rec1+'.NRRD', size)
; Process record 1; this will cause it to wait for data
t = caput(rec1+'.PROC', '1')


; Put record 2 in write mode
t = caput(rec2+'.TMOD', 'Write')
; Send an 8 bit binary sin wave, &quot;size&quot; points long from
; port 2 to port 1
send_data = byte(sin(findgen(size)/5)*126 + 127)
t = caput(rec2+'.NOWT', size)
t = caput(rec2+'.BOUT', send_data)


; Wait for monitor on channel 1 binary input
while (not cacheckmonitor(rec1+'.BINP')) do wait, .1


; Record 1 should have received &quot;size&quot; bytes. Make sure NORD=size
t = caget(rec1+'.NORD', nord)
if (nord eq size) then $
    print, 'Read array data OK' $
else $
    print, 'Error reading array data!'


; Read data from record 1
t = caget(rec1+'.BINP', rec_data, max=nord)


; Plot it
plot, rec_data


end
</PRE>
<HR>
  <H2><a name="Example 2" #2>Example #2</a></H2>The following is an IDL 
procedure that demonstrates the use 
of the asyn record to communicate with a Tektronix TDS200 Digital Oscilloscope. 
It transfers data in both ASCII and binary formats.&nbsp; It will work with 
either an RS-232 or GPIB connection to the scope.&nbsp; The record must be
loaded with IMAX at least large enough to read the waveform.&nbsp; The entire
waveform readout is 2500 channels on the TDS220.&nbsp; The buffer size required
is 1 byte per channel + 7 bytes header/checksum.&nbsp; The start and stop
parameters to the procedure can be used to read a subset of the waveform.
<p>Hopefully the IDL syntax is clear enough to be understood by non-IDL users, and 
can be translated into your favorite scripting language.</p>
<PRE>pro read_tds200, record, data, start=start, stop=stop, chan=chan


; This procedure reads waveforms from the Tektronix TDS200 series scopes
; Mark Rivers
; Modifications: 
;     March 7,  2001 Correctly put record in Write and Write/Read modes.
;     Dec. 7,   2001 Set timeout to 2 seconds before read.
;     March 30, 2004 Change IFMT from Binary to Hybrid, other fixes.


if (n_elements(start) eq 0) then start=1
if (n_elements(stop) eq 0) then stop=2500
if (n_elements(chan) eq 0) then chan=1
chan = 'CH'+strtrim(chan,2)


aout = record + '.AOUT'
binp = record + '.BINP'
tmod = record + '.TMOD'
ifmt = record + '.IFMT'
binp = record + '.BINP'
nord = record + '.NORD'
tmot = record + '.TMOT'
oeos = record + '.OEOS'
ieos = record + '.IEOS'


; Set the terminators to newline (assumes scope is set up this way)
t = caput(oeos, '\n', /wait)
t = caput(ieos, '\n', /wait)


; Set the transfer mode to write
t = caput(tmod, 'Write', /wait)


; Set the encoding to positive binary, start and stop readout channels
; Set the readout range.  Can't do as one command, exceed 40 characters
command = 'DATA:ENC RPB; DATA:START ' + strtrim(start,2)
t = caput(aout, command, /wait)
command = 'DATA:STOP ' + strtrim(stop,2)
t = caput(aout, command, /wait)


;Set DATa:WIDth to 2
;command = 'DATA:WIDTH 2'
;t = caput(aout, command, /wait)


;Set channel number
command = 'DATA:SOURCE '+ strtrim(chan,2)
t = caput(aout, command, /wait)


; Set the input mode to hybrid. Large buffer but line-feed terminator
t = caput(ifmt, 'Hybrid', /wait)


; Set the transfer mode to write/read
t = caput(tmod, 'Write/Read', /wait)


; Empirically the timeout needs to be about 5 seconds for
; 1024 channels with RS-232
t = caput(tmot, 5.0)


; Read the scope
t = caput(aout, 'Curve?', /wait)


; Get the data
t = caget(binp, data)


; Check the number of bytes read.  See if it's what's expected
n_data = stop-start+1
n_header = 2 + strlen(strtrim(n_data, 2))
n_checksum = 1
n_expected = n_header + n_data + n_checksum
t = caget(nord, n)
if (n ne n_expected) then $
   print, 'Scope returned:', n, $' bytes, expected: ', n_expected

; The first n_header bytes are header, the last byte is checksum.
; Data are offset by 127, convert to long
data = data[n_header:n-2] - 127L


return
end
</PRE>


<ADDRESS>Suggestions and comments to: <A 
href="mailto:rivers@cars.uchicago.edu">Mark Rivers </A>: 
(rivers@cars.uchicago.edu) <BR>Last modified: March 30, 2004
</ADDRESS>
</BODY>
</HTML> guaranteed that no other asyn I/O to the device