/******************************************************************************
 *
 * $RCSfile: vxi11core_xdr.c,v $ (This file is best viewed with a tabwidth of 4)
 *
 ******************************************************************************/

/***********************************************************************
* Copyright (c) 2002 The University of Chicago, as Operator of Argonne
* National Laboratory, and the Regents of the University of
* California, as Operator of Los Alamos National Laboratory, and
* Berliner Elektronenspeicherring-Gesellschaft m.b.H. (BESSY).
* asynDriver is distributed subject to a Software License Agreement
* found in file LICENSE that is included with this distribution.
***********************************************************************/

/*
 *		Types conversions for RPC protocol (core channel)
 *
 * Author: Benjamin Franksen
 *
 ******************************************************************************
 *
 * Notes:
 *
 *	This file was generated by RPCGEN from vxi/RPCL/vxi11core.rpcl.
 *
 */
#include "osiRpc.h"
#include "vxi11core.h"

bool_t
xdr_Device_Link(XDR *xdrs, void *arg, ...)
{
	Device_Link *objp = (Device_Link *)arg;
	if (!xdr_long(xdrs, objp)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Device_AddrFamily(XDR *xdrs, void *arg, ...)
{
	Device_AddrFamily *objp = (Device_AddrFamily *)arg;
	if (!xdr_enum(xdrs, (enum_t *)objp)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Device_Flags(XDR *xdrs, void *arg, ...)
{
	Device_Flags *objp = (Device_Flags *)arg;
	if (!xdr_long(xdrs, objp)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Device_ErrorCode(XDR *xdrs, void *arg, ...)
{
	Device_ErrorCode *objp = (Device_ErrorCode *)arg;
	if (!xdr_long(xdrs, objp)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Device_Error(XDR *xdrs, void *arg, ...)
{
	Device_Error *objp = (Device_Error *)arg;
	if (!xdr_Device_ErrorCode(xdrs, &objp->error)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Create_LinkParms(XDR *xdrs, void *arg, ...)
{
	Create_LinkParms *objp = (Create_LinkParms *)arg;
	if (!xdr_long(xdrs, &objp->clientId)) {
		return (FALSE);
	}
	if (!xdr_bool(xdrs, &objp->lockDevice)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->lock_timeout)) {
		return (FALSE);
	}
	if (!xdr_string(xdrs, &objp->device, ~0)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Create_LinkResp(XDR *xdrs, void *arg, ...)
{
	Create_LinkResp *objp = (Create_LinkResp *)arg;
	if (!xdr_Device_ErrorCode(xdrs, &objp->error)) {
		return (FALSE);
	}
	if (!xdr_Device_Link(xdrs, &objp->lid)) {
		return (FALSE);
	}
	if (!xdr_u_short(xdrs, &objp->abortPort)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->maxRecvSize)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Device_WriteParms(XDR *xdrs, void *arg, ...)
{
	Device_WriteParms *objp = (Device_WriteParms *)arg;
	if (!xdr_Device_Link(xdrs, &objp->lid)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->io_timeout)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->lock_timeout)) {
		return (FALSE);
	}
	if (!xdr_Device_Flags(xdrs, &objp->flags)) {
		return (FALSE);
	}
	if (!xdr_bytes(xdrs, (char **)&objp->data.data_val, (u_int *)&objp->data.data_len, ~0)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Device_WriteResp(XDR *xdrs, void *arg, ...)
{
	Device_WriteResp *objp = (Device_WriteResp *)arg;
	if (!xdr_Device_ErrorCode(xdrs, &objp->error)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->size)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Device_ReadParms(XDR *xdrs, void *arg, ...)
{
	Device_ReadParms *objp = (Device_ReadParms *)arg;
	if (!xdr_Device_Link(xdrs, &objp->lid)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->requestSize)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->io_timeout)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->lock_timeout)) {
		return (FALSE);
	}
	if (!xdr_Device_Flags(xdrs, &objp->flags)) {
		return (FALSE);
	}
	if (!xdr_char(xdrs, &objp->termChar)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Device_ReadResp(XDR *xdrs, void *arg, ...)
{
	Device_ReadResp *objp = (Device_ReadResp *)arg;
	if (!xdr_Device_ErrorCode(xdrs, &objp->error)) {
		return (FALSE);
	}
	if (!xdr_long(xdrs, &objp->reason)) {
		return (FALSE);
	}
	if (!xdr_bytes(xdrs, (char **)&objp->data.data_val, (u_int *)&objp->data.data_len, ~0)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Device_ReadStbResp(XDR *xdrs, void *arg, ...)
{
	Device_ReadStbResp *objp = (Device_ReadStbResp *)arg;
	if (!xdr_Device_ErrorCode(xdrs, &objp->error)) {
		return (FALSE);
	}
	if (!xdr_u_char(xdrs, &objp->stb)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Device_GenericParms(XDR *xdrs, void *arg, ...)
{
	Device_GenericParms *objp = (Device_GenericParms *)arg;
	if (!xdr_Device_Link(xdrs, &objp->lid)) {
		return (FALSE);
	}
	if (!xdr_Device_Flags(xdrs, &objp->flags)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->lock_timeout)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->io_timeout)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Device_RemoteFunc(XDR *xdrs, void *arg, ...)
{
	Device_RemoteFunc *objp = (Device_RemoteFunc *)arg;
	if (!xdr_u_long(xdrs, &objp->hostAddr)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->hostPort)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->progNum)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->progVers)) {
		return (FALSE);
	}
	if (!xdr_Device_AddrFamily(xdrs, &objp->progFamily)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Device_EnableSrqParms(XDR *xdrs, void *arg, ...)
{
	Device_EnableSrqParms *objp = (Device_EnableSrqParms *)arg;
	if (!xdr_Device_Link(xdrs, &objp->lid)) {
		return (FALSE);
	}
	if (!xdr_bool(xdrs, &objp->enable)) {
		return (FALSE);
	}
	if (!xdr_bytes(xdrs, (char **)&objp->handle.handle_val, (u_int *)&objp->handle.handle_len, 40)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Device_LockParms(XDR *xdrs, void *arg, ...)
{
	Device_LockParms *objp = (Device_LockParms *)arg;
	if (!xdr_Device_Link(xdrs, &objp->lid)) {
		return (FALSE);
	}
	if (!xdr_Device_Flags(xdrs, &objp->flags)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->lock_timeout)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Device_DocmdParms(XDR *xdrs, void *arg, ...)
{
	Device_DocmdParms *objp = (Device_DocmdParms *)arg;
	if (!xdr_Device_Link(xdrs, &objp->lid)) {
		return (FALSE);
	}
	if (!xdr_Device_Flags(xdrs, &objp->flags)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->io_timeout)) {
		return (FALSE);
	}
	if (!xdr_u_long(xdrs, &objp->lock_timeout)) {
		return (FALSE);
	}
	if (!xdr_long(xdrs, &objp->cmd)) {
		return (FALSE);
	}
	if (!xdr_bool(xdrs, &objp->network_order)) {
		return (FALSE);
	}
	if (!xdr_long(xdrs, &objp->datasize)) {
		return (FALSE);
	}
	if (!xdr_bytes(xdrs, (char **)&objp->data_in.data_in_val, (u_int *)&objp->data_in.data_in_len, ~0)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Device_DocmdResp(XDR *xdrs, void *arg, ...)
{
	Device_DocmdResp *objp = (Device_DocmdResp *)arg;
	if (!xdr_Device_ErrorCode(xdrs, &objp->error)) {
		return (FALSE);
	}
	if (!xdr_bytes(xdrs, (char **)&objp->data_out.data_out_val, (u_int *)&objp->data_out.data_out_len, ~0)) {
		return (FALSE);
	}
	return (TRUE);
}

/* 
 * $Log: not supported by cvs2svn $
 * Revision 1.2  2003/10/27 13:41:12  mrk
 * interim commit before alp[ha2
 *
 * Revision 1.1  2003/10/01 19:30:03  mrk
 * asynGpib and vxi11 now supported
 *
 * Revision 1.2  2003/04/10 15:17:07  mrk
 * open source license
 *
 * Revision 1.1  2003/02/20 20:42:23  mrk
 * drvHpE2050=>drvVxi11
 *
 * Revision 1.3  2002/10/21 17:49:09  mrk
 * Change $Log so warnings are not issued
 *
 * Revision 1.2  2002/10/21 15:59:49  mrk
 * build a single library
 *
 * Revision 1.1  2002/10/18 17:21:14  mrk
 * moved to here
 *
 * Revision 1.2  2001/02/22 19:57:20  norume
 * Many, many R3.14 changes.  Driver tested on RTEMS-gen68360 and Linux.
 *
 * Revision 1.1.1.1  2001/02/15 14:52:51  mrk
 * Import sources
 *
 * Revision 1.1.1.1  2000/03/21 18:06:35  franksen
 * unbundled gpib first version
 */
